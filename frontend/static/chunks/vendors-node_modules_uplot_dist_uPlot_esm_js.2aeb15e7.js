"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkaxiom_local_dash"] = self["webpackChunkaxiom_local_dash"] || []).push([["vendors-node_modules_uplot_dist_uPlot_esm_js"],{

/***/ 28890:
/*!**********************************************!*\
  !*** ./node_modules/uplot/dist/uPlot.esm.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n* Copyright (c) 2021, Leon Sorokin\n* All rights reserved. (MIT Licensed)\n*\n* uPlot.js (Î¼Plot)\n* A small, fast chart for time series, lines, areas, ohlc & bars\n* https://github.com/leeoniya/uPlot (v1.6.12)\n*/\n\nconst FEAT_TIME          = true;\n\n// binary search for index of closest value\nfunction closestIdx(num, arr, lo, hi) {\n\tlet mid;\n\tlo = lo || 0;\n\thi = hi || arr.length - 1;\n\tlet bitwise = hi <= 2147483647;\n\n\twhile (hi - lo > 1) {\n\t\tmid = bitwise ? (lo + hi) >> 1 : floor((lo + hi) / 2);\n\n\t\tif (arr[mid] < num)\n\t\t\tlo = mid;\n\t\telse\n\t\t\thi = mid;\n\t}\n\n\tif (num - arr[lo] <= arr[hi] - num)\n\t\treturn lo;\n\n\treturn hi;\n}\n\nfunction nonNullIdx(data, _i0, _i1, dir) {\n\tfor (let i = dir == 1 ? _i0 : _i1; i >= _i0 && i <= _i1; i += dir) {\n\t\tif (data[i] != null)\n\t\t\treturn i;\n\t}\n\n\treturn -1;\n}\n\nfunction getMinMax(data, _i0, _i1, sorted) {\n//\tconsole.log(\"getMinMax()\");\n\n\tlet _min = inf;\n\tlet _max = -inf;\n\n\tif (sorted == 1) {\n\t\t_min = data[_i0];\n\t\t_max = data[_i1];\n\t}\n\telse if (sorted == -1) {\n\t\t_min = data[_i1];\n\t\t_max = data[_i0];\n\t}\n\telse {\n\t\tfor (let i = _i0; i <= _i1; i++) {\n\t\t\tif (data[i] != null) {\n\t\t\t\t_min = min(_min, data[i]);\n\t\t\t\t_max = max(_max, data[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn [_min, _max];\n}\n\nfunction getMinMaxLog(data, _i0, _i1) {\n//\tconsole.log(\"getMinMax()\");\n\n\tlet _min = inf;\n\tlet _max = -inf;\n\n\tfor (let i = _i0; i <= _i1; i++) {\n\t\tif (data[i] > 0) {\n\t\t\t_min = min(_min, data[i]);\n\t\t\t_max = max(_max, data[i]);\n\t\t}\n\t}\n\n\treturn [\n\t\t_min ==  inf ?  1 : _min,\n\t\t_max == -inf ? 10 : _max,\n\t];\n}\n\nconst _fixedTuple = [0, 0];\n\nfunction fixIncr(minIncr, maxIncr, minExp, maxExp) {\n\t_fixedTuple[0] = minExp < 0 ? roundDec(minIncr, -minExp) : minIncr;\n\t_fixedTuple[1] = maxExp < 0 ? roundDec(maxIncr, -maxExp) : maxIncr;\n\treturn _fixedTuple;\n}\n\nfunction rangeLog(min, max, base, fullMags) {\n\n\tlet logFn = base == 10 ? log10 : log2;\n\n\tif (min == max) {\n\t\tmin /= base;\n\t\tmax *= base;\n\t}\n\n\tlet minExp, maxExp, minMaxIncrs;\n\n\tif (fullMags) {\n\t\tminExp = floor(logFn(min));\n\t\tmaxExp =  ceil(logFn(max));\n\n\t\tminMaxIncrs = fixIncr(pow(base, minExp), pow(base, maxExp), minExp, maxExp);\n\n\t\tmin = minMaxIncrs[0];\n\t\tmax = minMaxIncrs[1];\n\t}\n\telse {\n\t\tminExp = floor(logFn(abs(min)));\n\t\tmaxExp = floor(logFn(abs(max)));\n\n\t\tminMaxIncrs = fixIncr(pow(base, minExp), pow(base, maxExp), minExp, maxExp);\n\n\t\tmin = incrRoundDn(min, minMaxIncrs[0]);\n\t\tmax = incrRoundUp(max, minMaxIncrs[1]);\n\t}\n\n\treturn [min, max];\n}\n\nfunction rangeAsinh(min, max, base, fullMags) {\n\tlet minMax = rangeLog(min, max, base, fullMags);\n\n\tif (min == 0)\n\t\tminMax[0] = 0;\n\n\tif (max == 0)\n\t\tminMax[1] = 0;\n\n\treturn minMax;\n}\n\nconst _eqRangePart = {\n\tpad:  0,\n\tsoft: null,\n\tmode: 0,\n};\n\nconst _eqRange = {\n\tmin: _eqRangePart,\n\tmax: _eqRangePart,\n};\n\n// this ensures that non-temporal/numeric y-axes get multiple-snapped padding added above/below\n// TODO: also account for incrs when snapping to ensure top of axis gets a tick & value\nfunction rangeNum(_min, _max, mult, extra) {\n\tif (isObj(mult))\n\t\treturn _rangeNum(_min, _max, mult);\n\n\t_eqRangePart.pad  = mult;\n\t_eqRangePart.soft = extra ? 0 : null;\n\t_eqRangePart.mode = extra ? 3 : 0;\n\n\treturn _rangeNum(_min, _max, _eqRange);\n}\n\n// nullish coalesce\nfunction ifNull(lh, rh) {\n\treturn lh == null ? rh : lh;\n}\n\nfunction _rangeNum(_min, _max, cfg) {\n\tlet cmin = cfg.min;\n\tlet cmax = cfg.max;\n\n\tlet padMin = ifNull(cmin.pad, 0);\n\tlet padMax = ifNull(cmax.pad, 0);\n\n\tlet hardMin = ifNull(cmin.hard, -inf);\n\tlet hardMax = ifNull(cmax.hard,  inf);\n\n\tlet softMin = ifNull(cmin.soft,  inf);\n\tlet softMax = ifNull(cmax.soft, -inf);\n\n\tlet softMinMode = ifNull(cmin.mode, 0);\n\tlet softMaxMode = ifNull(cmax.mode, 0);\n\n\tlet delta        = _max - _min;\n\n\t// this handles situations like 89.7, 89.69999999999999\n\t// by assuming 0.001x deltas are precision errors\n//\tif (delta > 0 && delta < abs(_max) / 1e3)\n//\t\tdelta = 0;\n\n\t// treat data as flat if delta is less than 1 billionth\n\tif (delta < 1e-9)\n\t\tdelta = 0;\n\n\tlet nonZeroDelta = delta || abs(_max) || 1e3;\n\tlet mag          = log10(nonZeroDelta);\n\tlet base         = pow(10, floor(mag));\n\n\tlet _padMin  = nonZeroDelta * (delta == 0 ? (_min == 0 ? .1 : 1) : padMin);\n\tlet _newMin  = roundDec(incrRoundDn(_min - _padMin, base/10), 9);\n\tlet _softMin = _min >= softMin && (softMinMode == 1 || softMinMode == 3 && _newMin <= softMin || softMinMode == 2 && _newMin >= softMin) ? softMin : inf;\n\tlet minLim   = max(hardMin, _newMin < _softMin && _min >= _softMin ? _softMin : min(_softMin, _newMin));\n\n\tlet _padMax  = nonZeroDelta * (delta == 0 ? (_max == 0 ? .1 : 1) : padMax);\n\tlet _newMax  = roundDec(incrRoundUp(_max + _padMax, base/10), 9);\n\tlet _softMax = _max <= softMax && (softMaxMode == 1 || softMaxMode == 3 && _newMax >= softMax || softMaxMode == 2 && _newMax <= softMax) ? softMax : -inf;\n\tlet maxLim   = min(hardMax, _newMax > _softMax && _max <= _softMax ? _softMax : max(_softMax, _newMax));\n\n\tif (minLim == maxLim && minLim == 0)\n\t\tmaxLim = 100;\n\n\treturn [minLim, maxLim];\n}\n\n// alternative: https://stackoverflow.com/a/2254896\nconst fmtNum = new Intl.NumberFormat(navigator.language).format;\n\nconst M = Math;\n\nconst PI = M.PI;\nconst abs = M.abs;\nconst floor = M.floor;\nconst round = M.round;\nconst ceil = M.ceil;\nconst min = M.min;\nconst max = M.max;\nconst pow = M.pow;\nconst log10 = M.log10;\nconst log2 = M.log2;\nconst sinh =  (v, linthresh = 1) => M.sinh(v / linthresh);\nconst asinh = (v, linthresh = 1) => M.asinh(v / linthresh);\n\nconst inf = Infinity;\n\nfunction incrRound(num, incr) {\n\treturn round(num/incr)*incr;\n}\n\nfunction clamp(num, _min, _max) {\n\treturn min(max(num, _min), _max);\n}\n\nfunction fnOrSelf(v) {\n\treturn typeof v == \"function\" ? v : () => v;\n}\n\nconst retArg0 = _0 => _0;\n\nconst retArg1 = (_0, _1) => _1;\n\nconst retNull = _ => null;\n\nconst retTrue = _ => true;\n\nconst retEq = (a, b) => a == b;\n\nfunction incrRoundUp(num, incr) {\n\treturn ceil(num/incr)*incr;\n}\n\nfunction incrRoundDn(num, incr) {\n\treturn floor(num/incr)*incr;\n}\n\nfunction roundDec(val, dec) {\n\treturn round(val * (dec = 10**dec)) / dec;\n}\n\nconst fixedDec = new Map();\n\nfunction guessDec(num) {\n\treturn ((\"\"+num).split(\".\")[1] || \"\").length;\n}\n\nfunction genIncrs(base, minExp, maxExp, mults) {\n\tlet incrs = [];\n\n\tlet multDec = mults.map(guessDec);\n\n\tfor (let exp = minExp; exp < maxExp; exp++) {\n\t\tlet expa = abs(exp);\n\t\tlet mag = roundDec(pow(base, exp), expa);\n\n\t\tfor (let i = 0; i < mults.length; i++) {\n\t\t\tlet _incr = mults[i] * mag;\n\t\t\tlet dec = (_incr >= 0 && exp >= 0 ? 0 : expa) + (exp >= multDec[i] ? 0 : multDec[i]);\n\t\t\tlet incr = roundDec(_incr, dec);\n\t\t\tincrs.push(incr);\n\t\t\tfixedDec.set(incr, dec);\n\t\t}\n\t}\n\n\treturn incrs;\n}\n\n//export const assign = Object.assign;\n\nconst EMPTY_OBJ = {};\n\nconst nullNullTuple = [null, null];\n\nconst isArr = Array.isArray;\n\nfunction isStr(v) {\n\treturn typeof v == 'string';\n}\n\nfunction isObj(v) {\n\tlet is = false;\n\n\tif (v != null) {\n\t\tlet c = v.constructor;\n\t\tis = c == null || c == Object;\n\t}\n\n\treturn is;\n}\n\nfunction fastIsObj(v) {\n\treturn v != null && typeof v == 'object';\n}\n\nfunction copy(o, _isObj) {\n\t_isObj = _isObj || isObj;\n\n\tlet out;\n\n\tif (isArr(o))\n\t\tout = o.map(v => copy(v, _isObj));\n\telse if (_isObj(o)) {\n\t\tout = {};\n\t\tfor (var k in o)\n\t\t\tout[k] = copy(o[k], _isObj);\n\t}\n\telse\n\t\tout = o;\n\n\treturn out;\n}\n\nfunction assign(targ) {\n\tlet args = arguments;\n\n\tfor (let i = 1; i < args.length; i++) {\n\t\tlet src = args[i];\n\n\t\tfor (let key in src) {\n\t\t\tif (isObj(targ[key]))\n\t\t\t\tassign(targ[key], copy(src[key]));\n\t\t\telse\n\t\t\t\ttarg[key] = copy(src[key]);\n\t\t}\n\t}\n\n\treturn targ;\n}\n\n// nullModes\nconst NULL_REMOVE = 0;  // nulls are converted to undefined (e.g. for spanGaps: true)\nconst NULL_RETAIN = 1;  // nulls are retained, with alignment artifacts set to undefined (default)\nconst NULL_EXPAND = 2;  // nulls are expanded to include any adjacent alignment artifacts\n\n// sets undefined values to nulls when adjacent to existing nulls (minesweeper)\nfunction nullExpand(yVals, nullIdxs, alignedLen) {\n\tfor (let i = 0, xi, lastNullIdx = -1; i < nullIdxs.length; i++) {\n\t\tlet nullIdx = nullIdxs[i];\n\n\t\tif (nullIdx > lastNullIdx) {\n\t\t\txi = nullIdx - 1;\n\t\t\twhile (xi >= 0 && yVals[xi] == null)\n\t\t\t\tyVals[xi--] = null;\n\n\t\t\txi = nullIdx + 1;\n\t\t\twhile (xi < alignedLen && yVals[xi] == null)\n\t\t\t\tyVals[lastNullIdx = xi++] = null;\n\t\t}\n\t}\n}\n\n// nullModes is a tables-matched array indicating how to treat nulls in each series\n// output is sorted ASC on the joined field (table[0]) and duplicate join values are collapsed\nfunction join(tables, nullModes) {\n\tlet xVals = new Set();\n\n\tfor (let ti = 0; ti < tables.length; ti++) {\n\t\tlet t = tables[ti];\n\t\tlet xs = t[0];\n\t\tlet len = xs.length;\n\n\t\tfor (let i = 0; i < len; i++)\n\t\t\txVals.add(xs[i]);\n\t}\n\n\tlet data = [Array.from(xVals).sort((a, b) => a - b)];\n\n\tlet alignedLen = data[0].length;\n\n\tlet xIdxs = new Map();\n\n\tfor (let i = 0; i < alignedLen; i++)\n\t\txIdxs.set(data[0][i], i);\n\n\tfor (let ti = 0; ti < tables.length; ti++) {\n\t\tlet t = tables[ti];\n\t\tlet xs = t[0];\n\n\t\tfor (let si = 1; si < t.length; si++) {\n\t\t\tlet ys = t[si];\n\n\t\t\tlet yVals = Array(alignedLen).fill(undefined);\n\n\t\t\tlet nullMode = nullModes ? nullModes[ti][si] : NULL_RETAIN;\n\n\t\t\tlet nullIdxs = [];\n\n\t\t\tfor (let i = 0; i < ys.length; i++) {\n\t\t\t\tlet yVal = ys[i];\n\t\t\t\tlet alignedIdx = xIdxs.get(xs[i]);\n\n\t\t\t\tif (yVal === null) {\n\t\t\t\t\tif (nullMode != NULL_REMOVE) {\n\t\t\t\t\t\tyVals[alignedIdx] = yVal;\n\n\t\t\t\t\t\tif (nullMode == NULL_EXPAND)\n\t\t\t\t\t\t\tnullIdxs.push(alignedIdx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tyVals[alignedIdx] = yVal;\n\t\t\t}\n\n\t\t\tnullExpand(yVals, nullIdxs, alignedLen);\n\n\t\t\tdata.push(yVals);\n\t\t}\n\t}\n\n\treturn data;\n}\n\nconst microTask = typeof queueMicrotask == \"undefined\" ? fn => Promise.resolve().then(fn) : queueMicrotask;\n\nconst WIDTH       = \"width\";\nconst HEIGHT      = \"height\";\nconst TOP         = \"top\";\nconst BOTTOM      = \"bottom\";\nconst LEFT        = \"left\";\nconst RIGHT       = \"right\";\nconst hexBlack    = \"#000\";\nconst transparent = hexBlack + \"0\";\n\nconst mousemove   = \"mousemove\";\nconst mousedown   = \"mousedown\";\nconst mouseup     = \"mouseup\";\nconst mouseenter  = \"mouseenter\";\nconst mouseleave  = \"mouseleave\";\nconst dblclick    = \"dblclick\";\nconst resize      = \"resize\";\nconst scroll      = \"scroll\";\n\nconst pre = \"u-\";\n\nconst UPLOT          =       \"uplot\";\nconst ORI_HZ         = pre + \"hz\";\nconst ORI_VT         = pre + \"vt\";\nconst TITLE          = pre + \"title\";\nconst WRAP           = pre + \"wrap\";\nconst UNDER          = pre + \"under\";\nconst OVER           = pre + \"over\";\nconst OFF            = pre + \"off\";\nconst SELECT         = pre + \"select\";\nconst CURSOR_X       = pre + \"cursor-x\";\nconst CURSOR_Y       = pre + \"cursor-y\";\nconst CURSOR_PT      = pre + \"cursor-pt\";\nconst LEGEND         = pre + \"legend\";\nconst LEGEND_LIVE    = pre + \"live\";\nconst LEGEND_INLINE  = pre + \"inline\";\nconst LEGEND_THEAD   = pre + \"thead\";\nconst LEGEND_SERIES  = pre + \"series\";\nconst LEGEND_MARKER  = pre + \"marker\";\nconst LEGEND_LABEL   = pre + \"label\";\nconst LEGEND_VALUE   = pre + \"value\";\n\nconst doc = document;\nconst win = window;\nconst pxRatio = devicePixelRatio;\n\nfunction addClass(el, c) {\n\tif (c != null) {\n\t\tlet cl = el.classList;\n\t\t!cl.contains(c) && cl.add(c);\n\t}\n}\n\nfunction remClass(el, c) {\n\tlet cl = el.classList;\n\tcl.contains(c) && cl.remove(c);\n}\n\nfunction setStylePx(el, name, value) {\n\tel.style[name] = value + \"px\";\n}\n\nfunction placeTag(tag, cls, targ, refEl) {\n\tlet el = doc.createElement(tag);\n\n\tif (cls != null)\n\t\taddClass(el, cls);\n\n\tif (targ != null)\n\t\ttarg.insertBefore(el, refEl);\n\n\treturn el;\n}\n\nfunction placeDiv(cls, targ) {\n\treturn placeTag(\"div\", cls, targ);\n}\n\nfunction trans(el, xPos, yPos, xMax, yMax) {\n\tel.style.transform = \"translate(\" + xPos + \"px,\" + yPos + \"px)\";\n\n\tif (xPos < 0 || yPos < 0 || xPos > xMax || yPos > yMax)\n\t\taddClass(el, OFF);\n\telse\n\t\tremClass(el, OFF);\n}\n\nconst evOpts = {passive: true};\nconst evOpts2 = assign({capture: true}, evOpts);\n\nfunction on(ev, el, cb, capt) {\n\tel.addEventListener(ev, cb, capt ? evOpts2 : evOpts);\n}\n\nfunction off(ev, el, cb, capt) {\n\tel.removeEventListener(ev, cb, capt ? evOpts2 : evOpts);\n}\n\nconst months = [\n\t\"January\",\n\t\"February\",\n\t\"March\",\n\t\"April\",\n\t\"May\",\n\t\"June\",\n\t\"July\",\n\t\"August\",\n\t\"September\",\n\t\"October\",\n\t\"November\",\n\t\"December\",\n];\n\nconst days = [\n\t\"Sunday\",\n\t\"Monday\",\n\t\"Tuesday\",\n\t\"Wednesday\",\n\t\"Thursday\",\n\t\"Friday\",\n\t\"Saturday\",\n];\n\nfunction slice3(str) {\n\treturn str.slice(0, 3);\n}\n\nconst days3 = days.map(slice3);\n\nconst months3 = months.map(slice3);\n\nconst engNames = {\n\tMMMM: months,\n\tMMM:  months3,\n\tWWWW: days,\n\tWWW:  days3,\n};\n\nfunction zeroPad2(int) {\n\treturn (int < 10 ? '0' : '') + int;\n}\n\nfunction zeroPad3(int) {\n\treturn (int < 10 ? '00' : int < 100 ? '0' : '') + int;\n}\n\n/*\nfunction suffix(int) {\n\tlet mod10 = int % 10;\n\n\treturn int + (\n\t\tmod10 == 1 && int != 11 ? \"st\" :\n\t\tmod10 == 2 && int != 12 ? \"nd\" :\n\t\tmod10 == 3 && int != 13 ? \"rd\" : \"th\"\n\t);\n}\n*/\n\nconst subs = {\n\t// 2019\n\tYYYY:\td => d.getFullYear(),\n\t// 19\n\tYY:\t\td => (d.getFullYear()+'').slice(2),\n\t// July\n\tMMMM:\t(d, names) => names.MMMM[d.getMonth()],\n\t// Jul\n\tMMM:\t(d, names) => names.MMM[d.getMonth()],\n\t// 07\n\tMM:\t\td => zeroPad2(d.getMonth()+1),\n\t// 7\n\tM:\t\td => d.getMonth()+1,\n\t// 09\n\tDD:\t\td => zeroPad2(d.getDate()),\n\t// 9\n\tD:\t\td => d.getDate(),\n\t// Monday\n\tWWWW:\t(d, names) => names.WWWW[d.getDay()],\n\t// Mon\n\tWWW:\t(d, names) => names.WWW[d.getDay()],\n\t// 03\n\tHH:\t\td => zeroPad2(d.getHours()),\n\t// 3\n\tH:\t\td => d.getHours(),\n\t// 9 (12hr, unpadded)\n\th:\t\td => {let h = d.getHours(); return h == 0 ? 12 : h > 12 ? h - 12 : h;},\n\t// AM\n\tAA:\t\td => d.getHours() >= 12 ? 'PM' : 'AM',\n\t// am\n\taa:\t\td => d.getHours() >= 12 ? 'pm' : 'am',\n\t// a\n\ta:\t\td => d.getHours() >= 12 ? 'p' : 'a',\n\t// 09\n\tmm:\t\td => zeroPad2(d.getMinutes()),\n\t// 9\n\tm:\t\td => d.getMinutes(),\n\t// 09\n\tss:\t\td => zeroPad2(d.getSeconds()),\n\t// 9\n\ts:\t\td => d.getSeconds(),\n\t// 374\n\tfff:\td => zeroPad3(d.getMilliseconds()),\n};\n\nfunction fmtDate(tpl, names) {\n\tnames = names || engNames;\n\tlet parts = [];\n\n\tlet R = /\\{([a-z]+)\\}|[^{]+/gi, m;\n\n\twhile (m = R.exec(tpl))\n\t\tparts.push(m[0][0] == '{' ? subs[m[1]] : m[0]);\n\n\treturn d => {\n\t\tlet out = '';\n\n\t\tfor (let i = 0; i < parts.length; i++)\n\t\t\tout += typeof parts[i] == \"string\" ? parts[i] : parts[i](d, names);\n\n\t\treturn out;\n\t}\n}\n\nconst localTz = new Intl.DateTimeFormat().resolvedOptions().timeZone;\n\n// https://stackoverflow.com/questions/15141762/how-to-initialize-a-javascript-date-to-a-particular-time-zone/53652131#53652131\nfunction tzDate(date, tz) {\n\tlet date2;\n\n\t// perf optimization\n\tif (tz == 'UTC' || tz == 'Etc/UTC')\n\t\tdate2 = new Date(+date + date.getTimezoneOffset() * 6e4);\n\telse if (tz == localTz)\n\t\tdate2 = date;\n\telse {\n\t\tdate2 = new Date(date.toLocaleString('en-US', {timeZone: tz}));\n\t\tdate2.setMilliseconds(date.getMilliseconds());\n\t}\n\n\treturn date2;\n}\n\n//export const series = [];\n\n// default formatters:\n\nconst onlyWhole = v => v % 1 == 0;\n\nconst allMults = [1,2,2.5,5];\n\n// ...0.01, 0.02, 0.025, 0.05, 0.1, 0.2, 0.25, 0.5\nconst decIncrs = genIncrs(10, -16, 0, allMults);\n\n// 1, 2, 2.5, 5, 10, 20, 25, 50...\nconst oneIncrs = genIncrs(10, 0, 16, allMults);\n\n// 1, 2,      5, 10, 20, 25, 50...\nconst wholeIncrs = oneIncrs.filter(onlyWhole);\n\nconst numIncrs = decIncrs.concat(oneIncrs);\n\nconst NL = \"\\n\";\n\nconst yyyy    = \"{YYYY}\";\nconst NLyyyy  = NL + yyyy;\nconst md      = \"{M}/{D}\";\nconst NLmd    = NL + md;\nconst NLmdyy  = NLmd + \"/{YY}\";\n\nconst aa      = \"{aa}\";\nconst hmm     = \"{h}:{mm}\";\nconst hmmaa   = hmm + aa;\nconst NLhmmaa = NL + hmmaa;\nconst ss      = \":{ss}\";\n\nconst _ = null;\n\nfunction genTimeStuffs(ms) {\n\tlet\ts  = ms * 1e3,\n\t\tm  = s  * 60,\n\t\th  = m  * 60,\n\t\td  = h  * 24,\n\t\tmo = d  * 30,\n\t\ty  = d  * 365;\n\n\t// min of 1e-3 prevents setting a temporal x ticks too small since Date objects cannot advance ticks smaller than 1ms\n\tlet subSecIncrs = ms == 1 ? genIncrs(10, 0, 3, allMults).filter(onlyWhole) : genIncrs(10, -3, 0, allMults);\n\n\tlet timeIncrs = subSecIncrs.concat([\n\t\t// minute divisors (# of secs)\n\t\ts,\n\t\ts * 5,\n\t\ts * 10,\n\t\ts * 15,\n\t\ts * 30,\n\t\t// hour divisors (# of mins)\n\t\tm,\n\t\tm * 5,\n\t\tm * 10,\n\t\tm * 15,\n\t\tm * 30,\n\t\t// day divisors (# of hrs)\n\t\th,\n\t\th * 2,\n\t\th * 3,\n\t\th * 4,\n\t\th * 6,\n\t\th * 8,\n\t\th * 12,\n\t\t// month divisors TODO: need more?\n\t\td,\n\t\td * 2,\n\t\td * 3,\n\t\td * 4,\n\t\td * 5,\n\t\td * 6,\n\t\td * 7,\n\t\td * 8,\n\t\td * 9,\n\t\td * 10,\n\t\td * 15,\n\t\t// year divisors (# months, approx)\n\t\tmo,\n\t\tmo * 2,\n\t\tmo * 3,\n\t\tmo * 4,\n\t\tmo * 6,\n\t\t// century divisors\n\t\ty,\n\t\ty * 2,\n\t\ty * 5,\n\t\ty * 10,\n\t\ty * 25,\n\t\ty * 50,\n\t\ty * 100,\n\t]);\n\n\t// [0]:   minimum num secs in the tick incr\n\t// [1]:   default tick format\n\t// [2-7]: rollover tick formats\n\t// [8]:   mode: 0: replace [1] -> [2-7], 1: concat [1] + [2-7]\n\tconst _timeAxisStamps = [\n\t//   tick incr    default          year                    month   day                   hour    min       sec   mode\n\t\t[y,           yyyy,            _,                      _,      _,                    _,      _,        _,       1],\n\t\t[d * 28,      \"{MMM}\",         NLyyyy,                 _,      _,                    _,      _,        _,       1],\n\t\t[d,           md,              NLyyyy,                 _,      _,                    _,      _,        _,       1],\n\t\t[h,           \"{h}\" + aa,      NLmdyy,                 _,      NLmd,                 _,      _,        _,       1],\n\t\t[m,           hmmaa,           NLmdyy,                 _,      NLmd,                 _,      _,        _,       1],\n\t\t[s,           ss,              NLmdyy + \" \" + hmmaa,   _,      NLmd + \" \" + hmmaa,   _,      NLhmmaa,  _,       1],\n\t\t[ms,          ss + \".{fff}\",   NLmdyy + \" \" + hmmaa,   _,      NLmd + \" \" + hmmaa,   _,      NLhmmaa,  _,       1],\n\t];\n\n\t// the ensures that axis ticks, values & grid are aligned to logical temporal breakpoints and not an arbitrary timestamp\n\t// https://www.timeanddate.com/time/dst/\n\t// https://www.timeanddate.com/time/dst/2019.html\n\t// https://www.epochconverter.com/timezones\n\tfunction timeAxisSplits(tzDate) {\n\t\treturn (self, axisIdx, scaleMin, scaleMax, foundIncr, foundSpace) => {\n\t\t\tlet splits = [];\n\t\t\tlet isYr = foundIncr >= y;\n\t\t\tlet isMo = foundIncr >= mo && foundIncr < y;\n\n\t\t\t// get the timezone-adjusted date\n\t\t\tlet minDate = tzDate(scaleMin);\n\t\t\tlet minDateTs = roundDec(minDate * ms, 3);\n\n\t\t\t// get ts of 12am (this lands us at or before the original scaleMin)\n\t\t\tlet minMin = mkDate(minDate.getFullYear(), isYr ? 0 : minDate.getMonth(), isMo || isYr ? 1 : minDate.getDate());\n\t\t\tlet minMinTs = roundDec(minMin * ms, 3);\n\n\t\t\tif (isMo || isYr) {\n\t\t\t\tlet moIncr = isMo ? foundIncr / mo : 0;\n\t\t\t\tlet yrIncr = isYr ? foundIncr / y  : 0;\n\t\t\t//\tlet tzOffset = scaleMin - minDateTs;\t\t// needed?\n\t\t\t\tlet split = minDateTs == minMinTs ? minDateTs : roundDec(mkDate(minMin.getFullYear() + yrIncr, minMin.getMonth() + moIncr, 1) * ms, 3);\n\t\t\t\tlet splitDate = new Date(round(split / ms));\n\t\t\t\tlet baseYear = splitDate.getFullYear();\n\t\t\t\tlet baseMonth = splitDate.getMonth();\n\n\t\t\t\tfor (let i = 0; split <= scaleMax; i++) {\n\t\t\t\t\tlet next = mkDate(baseYear + yrIncr * i, baseMonth + moIncr * i, 1);\n\t\t\t\t\tlet offs = next - tzDate(roundDec(next * ms, 3));\n\n\t\t\t\t\tsplit = roundDec((+next + offs) * ms, 3);\n\n\t\t\t\t\tif (split <= scaleMax)\n\t\t\t\t\t\tsplits.push(split);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlet incr0 = foundIncr >= d ? d : foundIncr;\n\t\t\t\tlet tzOffset = floor(scaleMin) - floor(minDateTs);\n\t\t\t\tlet split = minMinTs + tzOffset + incrRoundUp(minDateTs - minMinTs, incr0);\n\t\t\t\tsplits.push(split);\n\n\t\t\t\tlet date0 = tzDate(split);\n\n\t\t\t\tlet prevHour = date0.getHours() + (date0.getMinutes() / m) + (date0.getSeconds() / h);\n\t\t\t\tlet incrHours = foundIncr / h;\n\n\t\t\t\tlet minSpace = self.axes[axisIdx]._space;\n\t\t\t\tlet pctSpace = foundSpace / minSpace;\n\n\t\t\t\twhile (1) {\n\t\t\t\t\tsplit = roundDec(split + foundIncr, ms == 1 ? 0 : 3);\n\n\t\t\t\t\tif (split > scaleMax)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tif (incrHours > 1) {\n\t\t\t\t\t\tlet expectedHour = floor(roundDec(prevHour + incrHours, 6)) % 24;\n\t\t\t\t\t\tlet splitDate = tzDate(split);\n\t\t\t\t\t\tlet actualHour = splitDate.getHours();\n\n\t\t\t\t\t\tlet dstShift = actualHour - expectedHour;\n\n\t\t\t\t\t\tif (dstShift > 1)\n\t\t\t\t\t\t\tdstShift = -1;\n\n\t\t\t\t\t\tsplit -= dstShift * h;\n\n\t\t\t\t\t\tprevHour = (prevHour + incrHours) % 24;\n\n\t\t\t\t\t\t// add a tick only if it's further than 70% of the min allowed label spacing\n\t\t\t\t\t\tlet prevSplit = splits[splits.length - 1];\n\t\t\t\t\t\tlet pctIncr = roundDec((split - prevSplit) / foundIncr, 3);\n\n\t\t\t\t\t\tif (pctIncr * pctSpace >= .7)\n\t\t\t\t\t\t\tsplits.push(split);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tsplits.push(split);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn splits;\n\t\t}\n\t}\n\n\treturn [\n\t\ttimeIncrs,\n\t\t_timeAxisStamps,\n\t\ttimeAxisSplits,\n\t];\n}\n\nconst [ timeIncrsMs, _timeAxisStampsMs, timeAxisSplitsMs ] = genTimeStuffs(1);\nconst [ timeIncrsS,  _timeAxisStampsS,  timeAxisSplitsS  ] = genTimeStuffs(1e-3);\n\n// base 2\ngenIncrs(2, -53, 53, [1]);\n\n/*\nconsole.log({\n\tdecIncrs,\n\toneIncrs,\n\twholeIncrs,\n\tnumIncrs,\n\ttimeIncrs,\n\tfixedDec,\n});\n*/\n\nfunction timeAxisStamps(stampCfg, fmtDate) {\n\treturn stampCfg.map(s => s.map((v, i) =>\n\t\ti == 0 || i == 8 || v == null ? v : fmtDate(i == 1 || s[8] == 0 ? v : s[1] + v)\n\t));\n}\n\n// TODO: will need to accept spaces[] and pull incr into the loop when grid will be non-uniform, eg for log scales.\n// currently we ignore this for months since they're *nearly* uniform and the added complexity is not worth it\nfunction timeAxisVals(tzDate, stamps) {\n\treturn (self, splits, axisIdx, foundSpace, foundIncr) => {\n\t\tlet s = stamps.find(s => foundIncr >= s[0]) || stamps[stamps.length - 1];\n\n\t\t// these track boundaries when a full label is needed again\n\t\tlet prevYear;\n\t\tlet prevMnth;\n\t\tlet prevDate;\n\t\tlet prevHour;\n\t\tlet prevMins;\n\t\tlet prevSecs;\n\n\t\treturn splits.map(split => {\n\t\t\tlet date = tzDate(split);\n\n\t\t\tlet newYear = date.getFullYear();\n\t\t\tlet newMnth = date.getMonth();\n\t\t\tlet newDate = date.getDate();\n\t\t\tlet newHour = date.getHours();\n\t\t\tlet newMins = date.getMinutes();\n\t\t\tlet newSecs = date.getSeconds();\n\n\t\t\tlet stamp = (\n\t\t\t\tnewYear != prevYear && s[2] ||\n\t\t\t\tnewMnth != prevMnth && s[3] ||\n\t\t\t\tnewDate != prevDate && s[4] ||\n\t\t\t\tnewHour != prevHour && s[5] ||\n\t\t\t\tnewMins != prevMins && s[6] ||\n\t\t\t\tnewSecs != prevSecs && s[7] ||\n\t\t\t\t                       s[1]\n\t\t\t);\n\n\t\t\tprevYear = newYear;\n\t\t\tprevMnth = newMnth;\n\t\t\tprevDate = newDate;\n\t\t\tprevHour = newHour;\n\t\t\tprevMins = newMins;\n\t\t\tprevSecs = newSecs;\n\n\t\t\treturn stamp(date);\n\t\t});\n\t}\n}\n\n// for when axis.values is defined as a static fmtDate template string\nfunction timeAxisVal(tzDate, dateTpl) {\n\tlet stamp = fmtDate(dateTpl);\n\treturn (self, splits, axisIdx, foundSpace, foundIncr) => splits.map(split => stamp(tzDate(split)));\n}\n\nfunction mkDate(y, m, d) {\n\treturn new Date(y, m, d);\n}\n\nfunction timeSeriesStamp(stampCfg, fmtDate) {\n\treturn fmtDate(stampCfg);\n}\nconst _timeSeriesStamp = '{YYYY}-{MM}-{DD} {h}:{mm}{aa}';\n\nfunction timeSeriesVal(tzDate, stamp) {\n\treturn (self, val) => stamp(tzDate(val));\n}\n\nfunction legendStroke(self, seriesIdx) {\n\tlet s = self.series[seriesIdx];\n\treturn s.width ? s.stroke(self, seriesIdx) : s.points.width ? s.points.stroke(self, seriesIdx) : null;\n}\n\nfunction legendFill(self, seriesIdx) {\n\treturn self.series[seriesIdx].fill(self, seriesIdx);\n}\n\nconst legendOpts = {\n\tshow: true,\n\tlive: true,\n\tisolate: false,\n\tmarkers: {\n\t\tshow: true,\n\t\twidth: 2,\n\t\tstroke: legendStroke,\n\t\tfill: legendFill,\n\t\tdash: \"solid\",\n\t},\n\tidx: null,\n\tvalues: [],\n};\n\nfunction cursorPointShow(self, si) {\n\tlet o = self.cursor.points;\n\n\tlet pt = placeDiv();\n\n\tlet stroke = o.stroke(self, si);\n\tlet fill = o.fill(self, si);\n\n\tpt.style.background = fill || stroke;\n\n\tlet size = o.size(self, si);\n\tlet width = o.width(self, si, size);\n\n\tif (width)\n\t\tpt.style.border = width + \"px solid \" + stroke;\n\n\tlet mar = size / -2;\n\n\tsetStylePx(pt, WIDTH, size);\n\tsetStylePx(pt, HEIGHT, size);\n\tsetStylePx(pt, \"marginLeft\", mar);\n\tsetStylePx(pt, \"marginTop\", mar);\n\n\treturn pt;\n}\n\nfunction cursorPointFill(self, si) {\n\tlet s = self.series[si];\n\treturn s.stroke(self, si);\n}\n\nfunction cursorPointStroke(self, si) {\n\tlet s = self.series[si];\n\treturn s.stroke(self, si);\n}\n\nfunction cursorPointSize(self, si) {\n\tlet s = self.series[si];\n\treturn ptDia(s.width, 1);\n}\n\nfunction dataIdx(self, seriesIdx, cursorIdx) {\n\treturn cursorIdx;\n}\n\nconst moveTuple = [0,0];\n\nfunction cursorMove(self, mouseLeft1, mouseTop1) {\n\tmoveTuple[0] = mouseLeft1;\n\tmoveTuple[1] = mouseTop1;\n\treturn moveTuple;\n}\n\nfunction filtBtn0(self, targ, handle) {\n\treturn e => {\n\t\te.button == 0 && handle(e);\n\t};\n}\n\nfunction passThru(self, targ, handle) {\n\treturn handle;\n}\n\nconst cursorOpts = {\n\tshow: true,\n\tx: true,\n\ty: true,\n\tlock: false,\n\tmove: cursorMove,\n\tpoints: {\n\t\tshow:   cursorPointShow,\n\t\tsize:   cursorPointSize,\n\t\twidth:  0,\n\t\tstroke: cursorPointStroke,\n\t\tfill:   cursorPointFill,\n\t},\n\n\tbind: {\n\t\tmousedown:   filtBtn0,\n\t\tmouseup:     filtBtn0,\n\t\tclick:       filtBtn0,\n\t\tdblclick:    filtBtn0,\n\n\t\tmousemove:   passThru,\n\t\tmouseleave:  passThru,\n\t\tmouseenter:  passThru,\n\t},\n\n\tdrag: {\n\t\tsetScale: true,\n\t\tx: true,\n\t\ty: false,\n\t\tdist: 0,\n\t\tuni: null,\n\t\t_x: false,\n\t\t_y: false,\n\t},\n\n\tfocus: {\n\t\tprox: -1,\n\t},\n\n\tleft: -10,\n\ttop: -10,\n\tidx: null,\n\tdataIdx,\n};\n\nconst grid = {\n\tshow: true,\n\tstroke: \"rgba(0,0,0,0.07)\",\n\twidth: 2,\n//\tdash: [],\n\tfilter: retArg1,\n};\n\nconst ticks = assign({}, grid, {size: 10});\n\nconst font      = '12px system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\"';\nconst labelFont = \"bold \" + font;\nconst lineMult = 1.5;\t\t// font-size multiplier\n\nconst xAxisOpts = {\n\tshow: true,\n\tscale: \"x\",\n\tstroke: hexBlack,\n\tspace: 50,\n\tgap: 5,\n\tsize: 50,\n\tlabelSize: 30,\n\tlabelFont,\n\tside: 2,\n//\tclass: \"x-vals\",\n//\tincrs: timeIncrs,\n//\tvalues: timeVals,\n//\tfilter: retArg1,\n\tgrid,\n\tticks,\n\tfont,\n\trotate: 0,\n};\n\nconst numSeriesLabel = \"Value\";\nconst timeSeriesLabel = \"Time\";\n\nconst xSeriesOpts = {\n\tshow: true,\n\tscale: \"x\",\n\tauto: false,\n\tsorted: 1,\n//\tlabel: \"Time\",\n//\tvalue: v => stamp(new Date(v * 1e3)),\n\n\t// internal caches\n\tmin: inf,\n\tmax: -inf,\n\tidxs: [],\n};\n\nfunction numAxisVals(self, splits, axisIdx, foundSpace, foundIncr) {\n\treturn splits.map(v => v == null ? \"\" : fmtNum(v));\n}\n\nfunction numAxisSplits(self, axisIdx, scaleMin, scaleMax, foundIncr, foundSpace, forceMin) {\n\tlet splits = [];\n\n\tlet numDec = fixedDec.get(foundIncr) || 0;\n\n\tscaleMin = forceMin ? scaleMin : roundDec(incrRoundUp(scaleMin, foundIncr), numDec);\n\n\tfor (let val = scaleMin; val <= scaleMax; val = roundDec(val + foundIncr, numDec))\n\t\tsplits.push(Object.is(val, -0) ? 0 : val);\t\t// coalesces -0\n\n\treturn splits;\n}\n\n// this doesnt work for sin, which needs to come off from 0 independently in pos and neg dirs\nfunction logAxisSplits(self, axisIdx, scaleMin, scaleMax, foundIncr, foundSpace, forceMin) {\n\tconst splits = [];\n\n\tconst logBase = self.scales[self.axes[axisIdx].scale].log;\n\n\tconst logFn = logBase == 10 ? log10 : log2;\n\n\tconst exp = floor(logFn(scaleMin));\n\n\tfoundIncr = pow(logBase, exp);\n\n\tif (exp < 0)\n\t\tfoundIncr = roundDec(foundIncr, -exp);\n\n\tlet split = scaleMin;\n\n\tdo {\n\t\tsplits.push(split);\n\t\tsplit = roundDec(split + foundIncr, fixedDec.get(foundIncr));\n\n\t\tif (split >= foundIncr * logBase)\n\t\t\tfoundIncr = split;\n\n\t} while (split <= scaleMax);\n\n\treturn splits;\n}\n\nfunction asinhAxisSplits(self, axisIdx, scaleMin, scaleMax, foundIncr, foundSpace, forceMin) {\n\tlet sc = self.scales[self.axes[axisIdx].scale];\n\n\tlet linthresh = sc.asinh;\n\n\tlet posSplits = scaleMax > linthresh ? logAxisSplits(self, axisIdx, max(linthresh, scaleMin), scaleMax, foundIncr) : [linthresh];\n\tlet zero = scaleMax >= 0 && scaleMin <= 0 ? [0] : [];\n\tlet negSplits = scaleMin < -linthresh ? logAxisSplits(self, axisIdx, max(linthresh, -scaleMax), -scaleMin, foundIncr): [linthresh];\n\n\treturn negSplits.reverse().map(v => -v).concat(zero, posSplits);\n}\n\nconst RE_ALL   = /./;\nconst RE_12357 = /[12357]/;\nconst RE_125   = /[125]/;\nconst RE_1     = /1/;\n\nfunction logAxisValsFilt(self, splits, axisIdx, foundSpace, foundIncr) {\n\tlet axis = self.axes[axisIdx];\n\tlet scaleKey = axis.scale;\n\tlet sc = self.scales[scaleKey];\n\n\tif (sc.distr == 3 && sc.log == 2)\n\t\treturn splits;\n\n\tlet valToPos = self.valToPos;\n\n\tlet minSpace = axis._space;\n\n\tlet _10 = valToPos(10, scaleKey);\n\n\tlet re = (\n\t\tvalToPos(9, scaleKey) - _10 >= minSpace ? RE_ALL :\n\t\tvalToPos(7, scaleKey) - _10 >= minSpace ? RE_12357 :\n\t\tvalToPos(5, scaleKey) - _10 >= minSpace ? RE_125 :\n\t\tRE_1\n\t);\n\n\treturn splits.map(v => ((sc.distr == 4 && v == 0) || re.test(v)) ? v : null);\n}\n\nfunction numSeriesVal(self, val) {\n\treturn val == null ? \"\" : fmtNum(val);\n}\n\nconst yAxisOpts = {\n\tshow: true,\n\tscale: \"y\",\n\tstroke: hexBlack,\n\tspace: 30,\n\tgap: 5,\n\tsize: 50,\n\tlabelSize: 30,\n\tlabelFont,\n\tside: 3,\n//\tclass: \"y-vals\",\n//\tincrs: numIncrs,\n//\tvalues: (vals, space) => vals,\n//\tfilter: retArg1,\n\tgrid,\n\tticks,\n\tfont,\n\trotate: 0,\n};\n\n// takes stroke width\nfunction ptDia(width, mult) {\n\tlet dia = 3 + (width || 1) * 2;\n\treturn roundDec(dia * mult, 3);\n}\n\nfunction seriesPoints(self, si) {\n\tlet { scale, idxs } = self.series[0];\n\tlet xData = self.data[0];\n\tlet p0 = self.valToPos(xData[idxs[0]], scale, true);\n\tlet p1 = self.valToPos(xData[idxs[1]], scale, true);\n\tlet dim = abs(p1 - p0);\n\n\tlet s = self.series[si];\n//\tconst dia = ptDia(s.width, pxRatio);\n\tlet maxPts = dim / (s.points.space * pxRatio);\n\treturn idxs[1] - idxs[0] <= maxPts;\n}\n\nfunction seriesFillTo(self, seriesIdx, dataMin, dataMax) {\n\tlet scale = self.scales[self.series[seriesIdx].scale];\n\tlet isUpperBandEdge = self.bands && self.bands.some(b => b.series[0] == seriesIdx);\n\treturn scale.distr == 3 || isUpperBandEdge ? scale.min : 0;\n}\n\nconst ySeriesOpts = {\n\tscale: \"y\",\n\tauto: true,\n\tsorted: 0,\n\tshow: true,\n\tband: false,\n\tspanGaps: false,\n\talpha: 1,\n\tpoints: {\n\t\tshow: seriesPoints,\n\t//\tstroke: \"#000\",\n\t//\tfill: \"#fff\",\n\t//\twidth: 1,\n\t//\tsize: 10,\n\t},\n//\tlabel: \"Value\",\n//\tvalue: v => v,\n\tvalues: null,\n\n\t// internal caches\n\tmin: inf,\n\tmax: -inf,\n\tidxs: [],\n\n\tpath: null,\n\tclip: null,\n};\n\nfunction clampScale(self, val, scaleMin, scaleMax, scaleKey) {\n/*\n\tif (val < 0) {\n\t\tlet cssHgt = self.bbox.height / pxRatio;\n\t\tlet absPos = self.valToPos(abs(val), scaleKey);\n\t\tlet fromBtm = cssHgt - absPos;\n\t\treturn self.posToVal(cssHgt + fromBtm, scaleKey);\n\t}\n*/\n\treturn scaleMin / 10;\n}\n\nconst xScaleOpts = {\n\ttime: FEAT_TIME,\n\tauto: true,\n\tdistr: 1,\n\tlog: 10,\n\tasinh: 1,\n\tmin: null,\n\tmax: null,\n\tdir: 1,\n\tori: 0,\n};\n\nconst yScaleOpts = assign({}, xScaleOpts, {\n\ttime: false,\n\tori: 1,\n});\n\nconst syncs = {};\n\nfunction _sync(key, opts) {\n\tlet s = syncs[key];\n\n\tif (!s) {\n\t\ts = {\n\t\t\tkey,\n\t\t\tplots: [],\n\t\t\tsub(plot) {\n\t\t\t\ts.plots.push(plot);\n\t\t\t},\n\t\t\tunsub(plot) {\n\t\t\t\ts.plots = s.plots.filter(c => c != plot);\n\t\t\t},\n\t\t\tpub(type, self, x, y, w, h, i) {\n\t\t\t\tfor (let j = 0; j < s.plots.length; j++)\n\t\t\t\t\ts.plots[j] != self && s.plots[j].pub(type, self, x, y, w, h, i);\n\t\t\t},\n\t\t};\n\n\t\tif (key != null)\n\t\t\tsyncs[key] = s;\n\t}\n\n\treturn s;\n}\n\nconst BAND_CLIP_FILL   = 1 << 0;\nconst BAND_CLIP_STROKE = 1 << 1;\n\nfunction orient(u, seriesIdx, cb) {\n\tconst series = u.series[seriesIdx];\n\tconst scales = u.scales;\n\tconst bbox   = u.bbox;\n\tconst scaleX = scales[u.series[0].scale];\n\n\tlet dx = u._data[0],\n\t\tdy = u._data[seriesIdx],\n\t\tsx = scaleX,\n\t\tsy = scales[series.scale],\n\t\tl = bbox.left,\n\t\tt = bbox.top,\n\t\tw = bbox.width,\n\t\th = bbox.height,\n\t\tH = u.valToPosH,\n\t\tV = u.valToPosV;\n\n\treturn (sx.ori == 0\n\t\t? cb(\n\t\t\tseries,\n\t\t\tdx,\n\t\t\tdy,\n\t\t\tsx,\n\t\t\tsy,\n\t\t\tH,\n\t\t\tV,\n\t\t\tl,\n\t\t\tt,\n\t\t\tw,\n\t\t\th,\n\t\t\tmoveToH,\n\t\t\tlineToH,\n\t\t\trectH,\n\t\t\tarcH,\n\t\t\tbezierCurveToH,\n\t\t)\n\t\t: cb(\n\t\t\tseries,\n\t\t\tdx,\n\t\t\tdy,\n\t\t\tsx,\n\t\t\tsy,\n\t\t\tV,\n\t\t\tH,\n\t\t\tt,\n\t\t\tl,\n\t\t\th,\n\t\t\tw,\n\t\t\tmoveToV,\n\t\t\tlineToV,\n\t\t\trectV,\n\t\t\tarcV,\n\t\t\tbezierCurveToV,\n\t\t)\n\t);\n}\n\n// creates inverted band clip path (towards from stroke path -> yMax)\nfunction clipBandLine(self, seriesIdx, idx0, idx1, strokePath) {\n\treturn orient(self, seriesIdx, (series, dataX, dataY, scaleX, scaleY, valToPosX, valToPosY, xOff, yOff, xDim, yDim) => {\n\t\tconst dir = scaleX.dir * (scaleX.ori == 0 ? 1 : -1);\n\t\tconst lineTo = scaleX.ori == 0 ? lineToH : lineToV;\n\n\t\tlet frIdx, toIdx;\n\n\t\tif (dir == 1) {\n\t\t\tfrIdx = idx0;\n\t\t\ttoIdx = idx1;\n\t\t}\n\t\telse {\n\t\t\tfrIdx = idx1;\n\t\t\ttoIdx = idx0;\n\t\t}\n\n\t\t// path start\n\t\tlet x0 = incrRound(valToPosX(dataX[frIdx], scaleX, xDim, xOff), 0.5);\n\t\tlet y0 = incrRound(valToPosY(dataY[frIdx], scaleY, yDim, yOff), 0.5);\n\t\t// path end x\n\t\tlet x1 = incrRound(valToPosX(dataX[toIdx], scaleX, xDim, xOff), 0.5);\n\t\t// upper y limit\n\t\tlet yLimit = incrRound(valToPosY(scaleY.max, scaleY, yDim, yOff), 0.5);\n\n\t\tlet clip = new Path2D(strokePath);\n\n\t\tlineTo(clip, x1, yLimit);\n\t\tlineTo(clip, x0, yLimit);\n\t\tlineTo(clip, x0, y0);\n\n\t\treturn clip;\n\t});\n}\n\nfunction clipGaps(gaps, ori, plotLft, plotTop, plotWid, plotHgt) {\n\tlet clip = null;\n\n\t// create clip path (invert gaps and non-gaps)\n\tif (gaps.length > 0) {\n\t\tclip = new Path2D();\n\n\t\tconst rect = ori == 0 ? rectH : rectV;\n\n\t\tlet prevGapEnd = plotLft;\n\n\t\tfor (let i = 0; i < gaps.length; i++) {\n\t\t\tlet g = gaps[i];\n\n\t\t\trect(clip, prevGapEnd, plotTop, g[0] - prevGapEnd, plotTop + plotHgt);\n\n\t\t\tprevGapEnd = g[1];\n\t\t}\n\n\t\trect(clip, prevGapEnd, plotTop, plotLft + plotWid - prevGapEnd, plotTop + plotHgt);\n\t}\n\n\treturn clip;\n}\n\nfunction addGap(gaps, fromX, toX) {\n\tif (toX > fromX) {\n\t\tlet prevGap = gaps[gaps.length - 1];\n\n\t\tif (prevGap && prevGap[0] == fromX)\t\t\t// TODO: gaps must be encoded at stroke widths?\n\t\t\tprevGap[1] = toX;\n\t\telse\n\t\t\tgaps.push([fromX, toX]);\n\t}\n}\n\nfunction pxRoundGen(pxAlign) {\n\treturn pxAlign == 0 ? retArg0 : pxAlign == 1 ? round : v => incrRound(v, pxAlign);\n}\n\n// orientation-inverting canvas functions\nfunction moveToH(p, x, y) { p.moveTo(x, y); }\nfunction moveToV(p, y, x) { p.moveTo(x, y); }\nfunction lineToH(p, x, y) { p.lineTo(x, y); }\nfunction lineToV(p, y, x) { p.lineTo(x, y); }\nfunction rectH(p, x, y, w, h) { p.rect(x, y, w, h); }\nfunction rectV(p, y, x, h, w) { p.rect(x, y, w, h); }\nfunction arcH(p, x, y, r, startAngle, endAngle) { p.arc(x, y, r, startAngle, endAngle); }\nfunction arcV(p, y, x, r, startAngle, endAngle) { p.arc(x, y, r, startAngle, endAngle); }\nfunction bezierCurveToH(p, bp1x, bp1y, bp2x, bp2y, p2x, p2y) { p.bezierCurveTo(bp1x, bp1y, bp2x, bp2y, p2x, p2y); }function bezierCurveToV(p, bp1y, bp1x, bp2y, bp2x, p2y, p2x) { p.bezierCurveTo(bp1x, bp1y, bp2x, bp2y, p2x, p2y); }\n\nfunction _drawAcc(lineTo) {\n\treturn (stroke, accX, minY, maxY, inY, outY) => {\n\t\tif (minY != maxY) {\n\t\t\tif (inY != minY && outY != minY)\n\t\t\t\tlineTo(stroke, accX, minY);\n\t\t\tif (inY != maxY && outY != maxY)\n\t\t\t\tlineTo(stroke, accX, maxY);\n\n\t\t\tlineTo(stroke, accX, outY);\n\t\t}\n\t};\n}\n\nconst drawAccH = _drawAcc(lineToH);\nconst drawAccV = _drawAcc(lineToV);\n\nfunction linear() {\n\treturn (u, seriesIdx, idx0, idx1) => {\n\t\treturn orient(u, seriesIdx, (series, dataX, dataY, scaleX, scaleY, valToPosX, valToPosY, xOff, yOff, xDim, yDim) => {\n\t\t\tlet pxRound = series.pxRound;\n\n\t\t\tlet lineTo, drawAcc;\n\n\t\t\tif (scaleX.ori == 0) {\n\t\t\t\tlineTo = lineToH;\n\t\t\t\tdrawAcc = drawAccH;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlineTo = lineToV;\n\t\t\t\tdrawAcc = drawAccV;\n\t\t\t}\n\n\t\t\tconst dir = scaleX.dir * (scaleX.ori == 0 ? 1 : -1);\n\n\t\t\tconst _paths = {stroke: new Path2D(), fill: null, clip: null, band: null, flags: BAND_CLIP_FILL};\n\t\t\tconst stroke = _paths.stroke;\n\n\t\t\tlet minY = inf,\n\t\t\t\tmaxY = -inf,\n\t\t\t\tinY, outY, outX, drawnAtX;\n\n\t\t\tlet gaps = [];\n\n\t\t\tlet accX = pxRound(valToPosX(dataX[dir == 1 ? idx0 : idx1], scaleX, xDim, xOff));\n\t\t\tlet accGaps = false;\n\n\t\t\t// data edges\n\t\t\tlet lftIdx = nonNullIdx(dataY, idx0, idx1,  1 * dir);\n\t\t\tlet rgtIdx = nonNullIdx(dataY, idx0, idx1, -1 * dir);\n\t\t\tlet lftX = incrRound(valToPosX(dataX[lftIdx], scaleX, xDim, xOff), 0.5);\n\t\t\tlet rgtX = incrRound(valToPosX(dataX[rgtIdx], scaleX, xDim, xOff), 0.5);\n\n\t\t\tif (lftX > xOff)\n\t\t\t\taddGap(gaps, xOff, lftX);\n\n\t\t\tfor (let i = dir == 1 ? idx0 : idx1; i >= idx0 && i <= idx1; i += dir) {\n\t\t\t\tlet x = pxRound(valToPosX(dataX[i], scaleX, xDim, xOff));\n\n\t\t\t\tif (x == accX) {\n\t\t\t\t\tif (dataY[i] != null) {\n\t\t\t\t\t\toutY = pxRound(valToPosY(dataY[i], scaleY, yDim, yOff));\n\n\t\t\t\t\t\tif (minY == inf) {\n\t\t\t\t\t\t\tlineTo(stroke, x, outY);\n\t\t\t\t\t\t\tinY = outY;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tminY = min(outY, minY);\n\t\t\t\t\t\tmaxY = max(outY, maxY);\n\t\t\t\t\t}\n\t\t\t\t\telse if (!accGaps && dataY[i] === null)\n\t\t\t\t\t\taccGaps = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlet _addGap = false;\n\n\t\t\t\t\tif (minY != inf) {\n\t\t\t\t\t\tdrawAcc(stroke, accX, minY, maxY, inY, outY);\n\t\t\t\t\t\toutX = drawnAtX = accX;\n\t\t\t\t\t}\n\t\t\t\t\telse if (accGaps) {\n\t\t\t\t\t\t_addGap = true;\n\t\t\t\t\t\taccGaps = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (dataY[i] != null) {\n\t\t\t\t\t\toutY = pxRound(valToPosY(dataY[i], scaleY, yDim, yOff));\n\t\t\t\t\t\tlineTo(stroke, x, outY);\n\t\t\t\t\t\tminY = maxY = inY = outY;\n\n\t\t\t\t\t\t// prior pixel can have data but still start a gap if ends with null\n\t\t\t\t\t\tif (x - accX > 1 && dataY[i - dir] === null)\n\t\t\t\t\t\t\t_addGap = true;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tminY = inf;\n\t\t\t\t\t\tmaxY = -inf;\n\n\t\t\t\t\t\tif (!accGaps && dataY[i] === null)\n\t\t\t\t\t\t\taccGaps = true;\n\t\t\t\t\t}\n\n\t\t\t\t\t_addGap && addGap(gaps, outX, x);\n\n\t\t\t\t\taccX = x;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (minY != inf && minY != maxY && drawnAtX != accX)\n\t\t\t\tdrawAcc(stroke, accX, minY, maxY, inY, outY);\n\n\t\t\tif (rgtX < xOff + xDim)\n\t\t\t\taddGap(gaps, rgtX, xOff + xDim);\n\n\t\t\tif (series.fill != null) {\n\t\t\t\tlet fill = _paths.fill = new Path2D(stroke);\n\n\t\t\t\tlet fillTo = pxRound(valToPosY(series.fillTo(u, seriesIdx, series.min, series.max), scaleY, yDim, yOff));\n\n\t\t\t\tlineTo(fill, rgtX, fillTo);\n\t\t\t\tlineTo(fill, lftX, fillTo);\n\t\t\t}\n\n\t\t\tif (!series.spanGaps)\n\t\t\t\t_paths.clip = clipGaps(gaps, scaleX.ori, xOff, yOff, xDim, yDim);\n\n\t\t\tif (u.bands.length > 0) {\n\t\t\t\t// ADDL OPT: only create band clips for series that are band lower edges\n\t\t\t\t// if (b.series[1] == i && _paths.band == null)\n\t\t\t\t_paths.band = clipBandLine(u, seriesIdx, idx0, idx1, stroke);\n\t\t\t}\n\n\t\t\treturn _paths;\n\t\t});\n\t};\n}\n\nfunction stepped(opts) {\n\tconst align = ifNull(opts.align, 1);\n\t// whether to draw ascenders/descenders at null/gap bondaries\n\tconst ascDesc = ifNull(opts.ascDesc, false);\n\n\treturn (u, seriesIdx, idx0, idx1) => {\n\t\treturn orient(u, seriesIdx, (series, dataX, dataY, scaleX, scaleY, valToPosX, valToPosY, xOff, yOff, xDim, yDim) => {\n\t\t\tlet pxRound = series.pxRound;\n\n\t\t\tlet lineTo = scaleX.ori == 0 ? lineToH : lineToV;\n\n\t\t\tconst _paths = {stroke: new Path2D(), fill: null, clip: null, band: null, flags: BAND_CLIP_FILL};\n\t\t\tconst stroke = _paths.stroke;\n\n\t\t\tconst _dir = 1 * scaleX.dir * (scaleX.ori == 0 ? 1 : -1);\n\n\t\t\tidx0 = nonNullIdx(dataY, idx0, idx1,  1);\n\t\t\tidx1 = nonNullIdx(dataY, idx0, idx1, -1);\n\n\t\t\tlet gaps = [];\n\t\t\tlet inGap = false;\n\t\t\tlet prevYPos  = pxRound(valToPosY(dataY[_dir == 1 ? idx0 : idx1], scaleY, yDim, yOff));\n\t\t\tlet firstXPos = pxRound(valToPosX(dataX[_dir == 1 ? idx0 : idx1], scaleX, xDim, xOff));\n\t\t\tlet prevXPos = firstXPos;\n\n\t\t\tlineTo(stroke, firstXPos, prevYPos);\n\n\t\t\tfor (let i = _dir == 1 ? idx0 : idx1; i >= idx0 && i <= idx1; i += _dir) {\n\t\t\t\tlet yVal1 = dataY[i];\n\n\t\t\t\tlet x1 = pxRound(valToPosX(dataX[i], scaleX, xDim, xOff));\n\n\t\t\t\tif (yVal1 == null) {\n\t\t\t\t\tif (yVal1 === null) {\n\t\t\t\t\t\taddGap(gaps, prevXPos, x1);\n\t\t\t\t\t\tinGap = true;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlet y1 = pxRound(valToPosY(yVal1, scaleY, yDim, yOff));\n\n\t\t\t\tif (inGap) {\n\t\t\t\t\taddGap(gaps, prevXPos, x1);\n\n\t\t\t\t\t// don't clip vertical extenders\n\t\t\t\t\tif (prevYPos != y1) {\n\t\t\t\t\t\tlet halfStroke = (series.width * pxRatio) / 2;\n\n\t\t\t\t\t\tlet lastGap = gaps[gaps.length - 1];\n\n\t\t\t\t\t\tlastGap[0] += (ascDesc || align ==  1) ? halfStroke : -halfStroke;\n\t\t\t\t\t\tlastGap[1] -= (ascDesc || align == -1) ? halfStroke : -halfStroke;\n\t\t\t\t\t}\n\n\t\t\t\t\tinGap = false;\n\t\t\t\t}\n\n\t\t\t\tif (align == 1)\n\t\t\t\t\tlineTo(stroke, x1, prevYPos);\n\t\t\t\telse\n\t\t\t\t\tlineTo(stroke, prevXPos, y1);\n\n\t\t\t\tlineTo(stroke, x1, y1);\n\n\t\t\t\tprevYPos = y1;\n\t\t\t\tprevXPos = x1;\n\t\t\t}\n\n\t\t\tif (series.fill != null) {\n\t\t\t\tlet fill = _paths.fill = new Path2D(stroke);\n\n\t\t\t\tlet fillTo = series.fillTo(u, seriesIdx, series.min, series.max);\n\t\t\t\tlet minY = pxRound(valToPosY(fillTo, scaleY, yDim, yOff));\n\n\t\t\t\tlineTo(fill, prevXPos, minY);\n\t\t\t\tlineTo(fill, firstXPos, minY);\n\t\t\t}\n\n\t\t\tif (!series.spanGaps)\n\t\t\t\t_paths.clip = clipGaps(gaps, scaleX.ori, xOff, yOff, xDim, yDim);\n\n\t\t\tif (u.bands.length > 0) {\n\t\t\t\t// ADDL OPT: only create band clips for series that are band lower edges\n\t\t\t\t// if (b.series[1] == i && _paths.band == null)\n\t\t\t\t_paths.band = clipBandLine(u, seriesIdx, idx0, idx1, stroke);\n\t\t\t}\n\n\t\t\treturn _paths;\n\t\t});\n\t};\n}\n\nfunction bars(opts) {\n\topts = opts || EMPTY_OBJ;\n\tconst size = ifNull(opts.size, [0.6, inf]);\n\tconst align = opts.align || 0;\n\tconst extraGap = (opts.gap || 0) * pxRatio;\n\n\tconst gapFactor = 1 - size[0];\n\tconst maxWidth  = ifNull(size[1], inf) * pxRatio;\n\n\treturn (u, seriesIdx, idx0, idx1) => {\n\t\treturn orient(u, seriesIdx, (series, dataX, dataY, scaleX, scaleY, valToPosX, valToPosY, xOff, yOff, xDim, yDim) => {\n\t\t\tlet pxRound = series.pxRound;\n\n\t\t\tconst _dir = scaleX.dir * (scaleX.ori == 0 ? 1 : -1);\n\n\t\t\tlet rect = scaleX.ori == 0 ? rectH : rectV;\n\n\t\t\tlet colWid = xDim;\n\n\t\t\tif (dataX.length > 1) {\n\t\t\t\t// scan full dataset for smallest adjacent delta\n\t\t\t\t// will not work properly for non-linear x scales, since does not do expensive valToPosX calcs till end\n\t\t\t\tfor (let i = 1, minDelta = Infinity; i < dataX.length; i++) {\n\t\t\t\t\tlet delta = abs(dataX[i] - dataX[i-1]);\n\n\t\t\t\t\tif (delta < minDelta) {\n\t\t\t\t\t\tminDelta = delta;\n\t\t\t\t\t\tcolWid = abs(valToPosX(dataX[i], scaleX, xDim, xOff) - valToPosX(dataX[i-1], scaleX, xDim, xOff));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet gapWid = colWid * gapFactor;\n\n\t\t\tlet fillToY = series.fillTo(u, seriesIdx, series.min, series.max);\n\n\t\t\tlet y0Pos = valToPosY(fillToY, scaleY, yDim, yOff);\n\n\t\t\tlet strokeWidth = pxRound(series.width * pxRatio);\n\n\t\t\tlet barWid = pxRound(min(maxWidth, colWid - gapWid) - strokeWidth - extraGap);\n\n\t\t\tconst xShift = (align == 0 ? barWid / 2 : align == _dir ? 0 : barWid) - align * _dir * extraGap / 2;\n\n\t\t\tconst _paths = {stroke: new Path2D(), fill: null, clip: null, band: null, flags: BAND_CLIP_FILL | BAND_CLIP_STROKE};\n\n\t\t\tconst hasBands = u.bands.length > 0;\n\t\t\tlet yLimit;\n\n\t\t\tif (hasBands) {\n\t\t\t\t// ADDL OPT: only create band clips for series that are band lower edges\n\t\t\t\t// if (b.series[1] == i && _paths.band == null)\n\t\t\t\t_paths.band = new Path2D();\n\t\t\t\tyLimit = incrRound(valToPosY(scaleY.max, scaleY, yDim, yOff), 0.5);\n\t\t\t}\n\n\t\t\tconst stroke = _paths.stroke;\n\t\t\tconst band = _paths.band;\n\n\t\t\tfor (let i = _dir == 1 ? idx0 : idx1; i >= idx0 && i <= idx1; i += _dir) {\n\t\t\t\tlet yVal = dataY[i];\n\n\t\t\t\t// interpolate upwards band clips\n\t\t\t\tif (yVal == null) {\n\t\t\t\t\tif (hasBands) {\n\t\t\t\t\t\t// simple, but inefficient bi-directinal linear scans on each iteration\n\t\t\t\t\t\tlet prevNonNull = nonNullIdx(dataY, _dir == 1 ? idx0 : idx1, i, -_dir);\n\t\t\t\t\t\tlet nextNonNull = nonNullIdx(dataY, i, _dir == 1 ? idx1 : idx0,  _dir);\n\n\t\t\t\t\t\tlet prevVal = dataY[prevNonNull];\n\t\t\t\t\t\tlet nextVal = dataY[nextNonNull];\n\n\t\t\t\t\t\tyVal = prevVal + (i - prevNonNull) / (nextNonNull - prevNonNull) * (nextVal - prevVal);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlet xVal = scaleX.distr == 2 ? i : dataX[i];\n\n\t\t\t\t// TODO: all xPos can be pre-computed once for all series in aligned set\n\t\t\t\tlet xPos = valToPosX(xVal, scaleX, xDim, xOff);\n\t\t\t\tlet yPos = valToPosY(yVal, scaleY, yDim, yOff);\n\n\t\t\t\tlet lft = pxRound(xPos - xShift);\n\t\t\t\tlet btm = pxRound(max(yPos, y0Pos));\n\t\t\t\tlet top = pxRound(min(yPos, y0Pos));\n\t\t\t\tlet barHgt = btm - top;\n\n\t\t\t\tdataY[i] != null && rect(stroke, lft, top, barWid, barHgt);\n\n\t\t\t\tif (hasBands) {\n\t\t\t\t\tbtm = top;\n\t\t\t\t\ttop = yLimit;\n\t\t\t\t\tbarHgt = btm - top;\n\t\t\t\t\trect(band, lft, top, barWid, barHgt);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (series.fill != null)\n\t\t\t\t_paths.fill = new Path2D(stroke);\n\n\t\t\treturn _paths;\n\t\t});\n\t};\n}\n\nfunction splineInterp(interp, opts) {\n\treturn (u, seriesIdx, idx0, idx1) => {\n\t\treturn orient(u, seriesIdx, (series, dataX, dataY, scaleX, scaleY, valToPosX, valToPosY, xOff, yOff, xDim, yDim) => {\n\t\t\tlet pxRound = series.pxRound;\n\n\t\t\tlet moveTo, bezierCurveTo, lineTo;\n\n\t\t\tif (scaleX.ori == 0) {\n\t\t\t\tmoveTo = moveToH;\n\t\t\t\tlineTo = lineToH;\n\t\t\t\tbezierCurveTo = bezierCurveToH;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmoveTo = moveToV;\n\t\t\t\tlineTo = lineToV;\n\t\t\t\tbezierCurveTo = bezierCurveToV;\n\t\t\t}\n\n\t\t\tconst _dir = 1 * scaleX.dir * (scaleX.ori == 0 ? 1 : -1);\n\n\t\t\tidx0 = nonNullIdx(dataY, idx0, idx1,  1);\n\t\t\tidx1 = nonNullIdx(dataY, idx0, idx1, -1);\n\n\t\t\tlet gaps = [];\n\t\t\tlet inGap = false;\n\t\t\tlet firstXPos = pxRound(valToPosX(dataX[_dir == 1 ? idx0 : idx1], scaleX, xDim, xOff));\n\t\t\tlet prevXPos = firstXPos;\n\n\t\t\tlet xCoords = [];\n\t\t\tlet yCoords = [];\n\n\t\t\tfor (let i = _dir == 1 ? idx0 : idx1; i >= idx0 && i <= idx1; i += _dir) {\n\t\t\t\tlet yVal = dataY[i];\n\t\t\t\tlet xVal = dataX[i];\n\t\t\t\tlet xPos = valToPosX(xVal, scaleX, xDim, xOff);\n\n\t\t\t\tif (yVal == null) {\n\t\t\t\t\tif (yVal === null) {\n\t\t\t\t\t\taddGap(gaps, prevXPos, xPos);\n\t\t\t\t\t\tinGap = true;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (inGap) {\n\t\t\t\t\t\taddGap(gaps, prevXPos, xPos);\n\t\t\t\t\t\tinGap = false;\n\t\t\t\t\t}\n\n\t\t\t\t\txCoords.push((prevXPos = xPos));\n\t\t\t\t\tyCoords.push(valToPosY(dataY[i], scaleY, yDim, yOff));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst _paths = {stroke: interp(xCoords, yCoords, moveTo, lineTo, bezierCurveTo, pxRound), fill: null, clip: null, band: null, flags: BAND_CLIP_FILL};\n\t\t\tconst stroke = _paths.stroke;\n\n\t\t\tif (series.fill != null && stroke != null) {\n\t\t\t\tlet fill = _paths.fill = new Path2D(stroke);\n\n\t\t\t\tlet fillTo = series.fillTo(u, seriesIdx, series.min, series.max);\n\t\t\t\tlet minY = pxRound(valToPosY(fillTo, scaleY, yDim, yOff));\n\n\t\t\t\tlineTo(fill, prevXPos, minY);\n\t\t\t\tlineTo(fill, firstXPos, minY);\n\t\t\t}\n\n\t\t\tif (!series.spanGaps)\n\t\t\t\t_paths.clip = clipGaps(gaps, scaleX.ori, xOff, yOff, xDim, yDim);\n\n\t\t\tif (u.bands.length > 0) {\n\t\t\t\t// ADDL OPT: only create band clips for series that are band lower edges\n\t\t\t\t// if (b.series[1] == i && _paths.band == null)\n\t\t\t\t_paths.band = clipBandLine(u, seriesIdx, idx0, idx1, stroke);\n\t\t\t}\n\n\t\t\treturn _paths;\n\n\t\t\t//  if FEAT_PATHS: false in rollup.config.js\n\t\t\t//\tu.ctx.save();\n\t\t\t//\tu.ctx.beginPath();\n\t\t\t//\tu.ctx.rect(u.bbox.left, u.bbox.top, u.bbox.width, u.bbox.height);\n\t\t\t//\tu.ctx.clip();\n\t\t\t//\tu.ctx.strokeStyle = u.series[sidx].stroke;\n\t\t\t//\tu.ctx.stroke(stroke);\n\t\t\t//\tu.ctx.fillStyle = u.series[sidx].fill;\n\t\t\t//\tu.ctx.fill(fill);\n\t\t\t//\tu.ctx.restore();\n\t\t\t//\treturn null;\n\t\t});\n\t};\n}\n\nfunction monotoneCubic(opts) {\n\treturn splineInterp(_monotoneCubic);\n}\n\n// Monotone Cubic Spline interpolation, adapted from the Chartist.js implementation:\n// https://github.com/gionkunz/chartist-js/blob/e7e78201bffe9609915e5e53cfafa29a5d6c49f9/src/scripts/interpolation.js#L240-L369\nfunction _monotoneCubic(xs, ys, moveTo, lineTo, bezierCurveTo, pxRound) {\n\tconst n = xs.length;\n\n\tif (n < 2)\n\t\treturn null;\n\n\tconst path = new Path2D();\n\n\tmoveTo(path, xs[0], ys[0]);\n\n\tif (n == 2)\n\t\tlineTo(path, xs[1], ys[1]);\n\telse {\n\t\tlet ms  = Array(n),\n\t\t\tds  = Array(n - 1),\n\t\t\tdys = Array(n - 1),\n\t\t\tdxs = Array(n - 1);\n\n\t\t// calc deltas and derivative\n\t\tfor (let i = 0; i < n - 1; i++) {\n\t\t\tdys[i] = ys[i + 1] - ys[i];\n\t\t\tdxs[i] = xs[i + 1] - xs[i];\n\t\t\tds[i]  = dys[i] / dxs[i];\n\t\t}\n\n\t\t// determine desired slope (m) at each point using Fritsch-Carlson method\n\t\t// http://math.stackexchange.com/questions/45218/implementation-of-monotone-cubic-interpolation\n\t\tms[0] = ds[0];\n\n\t\tfor (let i = 1; i < n - 1; i++) {\n\t\t\tif (ds[i] === 0 || ds[i - 1] === 0 || (ds[i - 1] > 0) !== (ds[i] > 0))\n\t\t\t\tms[i] = 0;\n\t\t\telse {\n\t\t\t\tms[i] = 3 * (dxs[i - 1] + dxs[i]) / (\n\t\t\t\t\t(2 * dxs[i] + dxs[i - 1]) / ds[i - 1] +\n\t\t\t\t\t(dxs[i] + 2 * dxs[i - 1]) / ds[i]\n\t\t\t\t);\n\n\t\t\t\tif (!isFinite(ms[i]))\n\t\t\t\t\tms[i] = 0;\n\t\t\t}\n\t\t}\n\n\t\tms[n - 1] = ds[n - 2];\n\n\t\tfor (let i = 0; i < n - 1; i++) {\n\t\t\tbezierCurveTo(\n\t\t\t\tpath,\n\t\t\t\txs[i] + dxs[i] / 3,\n\t\t\t\tys[i] + ms[i] * dxs[i] / 3,\n\t\t\t\txs[i + 1] - dxs[i] / 3,\n\t\t\t\tys[i + 1] - ms[i + 1] * dxs[i] / 3,\n\t\t\t\txs[i + 1],\n\t\t\t\tys[i + 1],\n\t\t\t);\n\t\t}\n\t}\n\n\treturn path;\n}\n\nconst cursorPlots = new Set();\n\nfunction invalidateRects() {\n\tcursorPlots.forEach(u => {\n\t\tu.syncRect(true);\n\t});\n}\n\non(resize, win, invalidateRects);\non(scroll, win, invalidateRects, true);\n\nconst linearPath = linear() ;\n\nfunction setDefaults(d, xo, yo, initY) {\n\tlet d2 = initY ? [d[0], d[1]].concat(d.slice(2)) : [d[0]].concat(d.slice(1));\n\treturn d2.map((o, i) => setDefault(o, i, xo, yo));\n}\n\nfunction setDefault(o, i, xo, yo) {\n\treturn assign({}, (i == 0 ? xo : yo), o);\n}\n\nfunction snapNumX(self, dataMin, dataMax) {\n\treturn dataMin == null ? nullNullTuple : [dataMin, dataMax];\n}\n\nconst snapTimeX = snapNumX;\n\n// this ensures that non-temporal/numeric y-axes get multiple-snapped padding added above/below\n// TODO: also account for incrs when snapping to ensure top of axis gets a tick & value\nfunction snapNumY(self, dataMin, dataMax) {\n\treturn dataMin == null ? nullNullTuple : rangeNum(dataMin, dataMax, 0.1, true);\n}\n\nfunction snapLogY(self, dataMin, dataMax, scale) {\n\treturn dataMin == null ? nullNullTuple : rangeLog(dataMin, dataMax, self.scales[scale].log, false);\n}\n\nconst snapLogX = snapLogY;\n\nfunction snapAsinhY(self, dataMin, dataMax, scale) {\n\treturn dataMin == null ? nullNullTuple : rangeAsinh(dataMin, dataMax, self.scales[scale].log, false);\n}\n\nconst snapAsinhX = snapAsinhY;\n\n// dim is logical (getClientBoundingRect) pixels, not canvas pixels\nfunction findIncr(min, max, incrs, dim, minSpace) {\n\tlet pxPerUnit = dim / (max - min);\n\n\tlet minDec = (\"\"+floor(min)).length;\n\n\tfor (var i = 0; i < incrs.length; i++) {\n\t\tlet space = incrs[i] * pxPerUnit;\n\n\t\tlet incrDec = incrs[i] < 10 ? fixedDec.get(incrs[i]) : 0;\n\n\t\tif (space >= minSpace && minDec + incrDec < 17)\n\t\t\treturn [incrs[i], space];\n\t}\n\n\treturn [0, 0];\n}\n\nfunction pxRatioFont(font) {\n\tlet fontSize;\n\tfont = font.replace(/(\\d+)px/, (m, p1) => (fontSize = round(p1 * pxRatio)) + 'px');\n\treturn [font, fontSize];\n}\n\nfunction uPlot(opts, data, then) {\n\tconst self = {};\n\n\t// TODO: cache denoms & mins scale.cache = {r, min, }\n\tfunction getValPct(val, scale) {\n\t\tlet _val = (\n\t\t\tscale.distr == 3 ? log10(val > 0 ? val : scale.clamp(self, val, scale.min, scale.max, scale.key)) :\n\t\t\tscale.distr == 4 ? asinh(val, scale.asinh) :\n\t\t\tval\n\t\t);\n\n\t\treturn (_val - scale._min) / (scale._max - scale._min);\n\t}\n\n\tfunction getHPos(val, scale, dim, off) {\n\t\tlet pct = getValPct(val, scale);\n\t\treturn off + dim * (scale.dir == -1 ? (1 - pct) : pct);\n\t}\n\n\tfunction getVPos(val, scale, dim, off) {\n\t\tlet pct = getValPct(val, scale);\n\t\treturn off + dim * (scale.dir == -1 ? pct : (1 - pct));\n\t}\n\n\tfunction getPos(val, scale, dim, off) {\n\t\treturn scale.ori == 0 ? getHPos(val, scale, dim, off) : getVPos(val, scale, dim, off);\n\t}\n\n\tself.valToPosH = getHPos;\n\tself.valToPosV = getVPos;\n\n\tlet ready = false;\n\tself.status = 0;\n\n\tconst root = self.root = placeDiv(UPLOT);\n\n\tif (opts.id != null)\n\t\troot.id = opts.id;\n\n\taddClass(root, opts.class);\n\n\tif (opts.title) {\n\t\tlet title = placeDiv(TITLE, root);\n\t\ttitle.textContent = opts.title;\n\t}\n\n\tconst can = placeTag(\"canvas\");\n\tconst ctx = self.ctx = can.getContext(\"2d\");\n\n\tconst wrap = placeDiv(WRAP, root);\n\tconst under = self.under = placeDiv(UNDER, wrap);\n\twrap.appendChild(can);\n\tconst over = self.over = placeDiv(OVER, wrap);\n\n\topts = copy(opts);\n\n\tconst pxAlign = +ifNull(opts.pxAlign, 1);\n\n\tconst pxRound = pxRoundGen(pxAlign);\n\n\t(opts.plugins || []).forEach(p => {\n\t\tif (p.opts)\n\t\t\topts = p.opts(self, opts) || opts;\n\t});\n\n\tconst ms = opts.ms || 1e-3;\n\n\tconst series  = self.series = setDefaults(opts.series || [], xSeriesOpts, ySeriesOpts, false);\n\tconst axes    = self.axes   = setDefaults(opts.axes   || [], xAxisOpts,   yAxisOpts,    true);\n\tconst scales  = self.scales = {};\n\tconst bands   = self.bands  = opts.bands || [];\n\n\tbands.forEach(b => {\n\t\tb.fill = fnOrSelf(b.fill || null);\n\t});\n\n\tconst xScaleKey = series[0].scale;\n\n\tconst drawOrderMap = {\n\t\taxes: drawAxesGrid,\n\t\tseries: drawSeries,\n\t};\n\n\tconst drawOrder = (opts.drawOrder || [\"axes\", \"series\"]).map(key => drawOrderMap[key]);\n\n\tfunction initScale(scaleKey) {\n\t\tlet sc = scales[scaleKey];\n\n\t\tif (sc == null) {\n\t\t\tlet scaleOpts = (opts.scales || EMPTY_OBJ)[scaleKey] || EMPTY_OBJ;\n\n\t\t\tif (scaleOpts.from != null) {\n\t\t\t\t// ensure parent is initialized\n\t\t\t\tinitScale(scaleOpts.from);\n\t\t\t\t// dependent scales inherit\n\t\t\t\tscales[scaleKey] = assign({}, scales[scaleOpts.from], scaleOpts);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsc = scales[scaleKey] = assign({}, (scaleKey == xScaleKey ? xScaleOpts : yScaleOpts), scaleOpts);\n\n\t\t\t\tsc.key = scaleKey;\n\n\t\t\t\tlet isTime = sc.time;\n\n\t\t\t\tlet rn = sc.range;\n\n\t\t\t\tlet rangeIsArr = isArr(rn);\n\n\t\t\t\tif (scaleKey != xScaleKey && !rangeIsArr && isObj(rn)) {\n\t\t\t\t\tlet cfg = rn;\n\t\t\t\t\t// this is similar to snapNumY\n\t\t\t\t\trn = (self, dataMin, dataMax) => dataMin == null ? nullNullTuple : rangeNum(dataMin, dataMax, cfg);\n\t\t\t\t}\n\n\t\t\t\tsc.range = fnOrSelf(rn || (isTime ? snapTimeX : scaleKey == xScaleKey ?\n\t\t\t\t\t(sc.distr == 3 ? snapLogX : sc.distr == 4 ? snapAsinhX : snapNumX) :\n\t\t\t\t\t(sc.distr == 3 ? snapLogY : sc.distr == 4 ? snapAsinhY : snapNumY)\n\t\t\t\t));\n\n\t\t\t\tsc.auto = fnOrSelf(rangeIsArr ? false : sc.auto);\n\n\t\t\t\tsc.clamp = fnOrSelf(sc.clamp || clampScale);\n\n\t\t\t\t// caches for expensive ops like asinh() & log()\n\t\t\t\tsc._min = sc._max = null;\n\t\t\t}\n\t\t}\n\t}\n\n\tinitScale(\"x\");\n\tinitScale(\"y\");\n\n\tseries.forEach(s => {\n\t\tinitScale(s.scale);\n\t});\n\n\taxes.forEach(a => {\n\t\tinitScale(a.scale);\n\t});\n\n\tfor (let k in opts.scales)\n\t\tinitScale(k);\n\n\tconst scaleX = scales[xScaleKey];\n\n\tconst xScaleDistr = scaleX.distr;\n\n\tlet valToPosX, valToPosY, moveTo, arc;\n\n\tif (scaleX.ori == 0) {\n\t\taddClass(root, ORI_HZ);\n\t\tvalToPosX = getHPos;\n\t\tvalToPosY = getVPos;\n\t\tmoveTo    = moveToH;\n\t\tarc       = arcH;\n\t\t/*\n\t\tupdOriDims = () => {\n\t\t\txDimCan = plotWid;\n\t\t\txOffCan = plotLft;\n\t\t\tyDimCan = plotHgt;\n\t\t\tyOffCan = plotTop;\n\n\t\t\txDimCss = plotWidCss;\n\t\t\txOffCss = plotLftCss;\n\t\t\tyDimCss = plotHgtCss;\n\t\t\tyOffCss = plotTopCss;\n\t\t};\n\t\t*/\n\t}\n\telse {\n\t\taddClass(root, ORI_VT);\n\t\tvalToPosX = getVPos;\n\t\tvalToPosY = getHPos;\n\t\tmoveTo    = moveToV;\n\t\tarc       = arcV;\n\t\t/*\n\t\tupdOriDims = () => {\n\t\t\txDimCan = plotHgt;\n\t\t\txOffCan = plotTop;\n\t\t\tyDimCan = plotWid;\n\t\t\tyOffCan = plotLft;\n\n\t\t\txDimCss = plotHgtCss;\n\t\t\txOffCss = plotTopCss;\n\t\t\tyDimCss = plotWidCss;\n\t\t\tyOffCss = plotLftCss;\n\t\t};\n\t\t*/\n\t}\n\n\tconst pendScales = {};\n\n\t// explicitly-set initial scales\n\tfor (let k in scales) {\n\t\tlet sc = scales[k];\n\n\t\tif (sc.min != null || sc.max != null) {\n\t\t\tpendScales[k] = {min: sc.min, max: sc.max};\n\t\t\tsc.min = sc.max = null;\n\t\t}\n\t}\n\n//\tself.tz = opts.tz || Intl.DateTimeFormat().resolvedOptions().timeZone;\n\tconst _tzDate  = (opts.tzDate || (ts => new Date(round(ts / ms))));\n\tconst _fmtDate = (opts.fmtDate || fmtDate);\n\n\tconst _timeAxisSplits = (ms == 1 ? timeAxisSplitsMs(_tzDate) : timeAxisSplitsS(_tzDate));\n\tconst _timeAxisVals   = timeAxisVals(_tzDate, timeAxisStamps((ms == 1 ? _timeAxisStampsMs : _timeAxisStampsS), _fmtDate));\n\tconst _timeSeriesVal  = timeSeriesVal(_tzDate, timeSeriesStamp(_timeSeriesStamp, _fmtDate));\n\n\tconst legend     = (self.legend = assign({}, legendOpts, opts.legend));\n\tconst showLegend = legend.show;\n\tconst markers    = legend.markers;\n\n\t{\n\t\tmarkers.width  = fnOrSelf(markers.width);\n\t\tmarkers.dash   = fnOrSelf(markers.dash);\n\t\tmarkers.stroke = fnOrSelf(markers.stroke);\n\t\tmarkers.fill   = fnOrSelf(markers.fill);\n\t}\n\n\tlet legendEl;\n\tlet legendRows = [];\n\tlet legendCells = [];\n\tlet legendCols;\n\tlet multiValLegend = false;\n\tlet NULL_LEGEND_VALUES = {};\n\n\tif (legend.live) {\n\t\tconst getMultiVals = series[1] ? series[1].values : null;\n\t\tmultiValLegend = getMultiVals != null;\n\t\tlegendCols = multiValLegend ? getMultiVals(self, 1, 0) : {_: 0};\n\n\t\tfor (let k in legendCols)\n\t\t\tNULL_LEGEND_VALUES[k] = \"--\";\n\t}\n\n\tif (showLegend) {\n\t\tlegendEl = placeTag(\"table\", LEGEND, root);\n\n\t\tif (multiValLegend) {\n\t\t\tlet head = placeTag(\"tr\", LEGEND_THEAD, legendEl);\n\t\t\tplaceTag(\"th\", null, head);\n\n\t\t\tfor (var key in legendCols)\n\t\t\t\tplaceTag(\"th\", LEGEND_LABEL, head).textContent = key;\n\t\t}\n\t\telse {\n\t\t\taddClass(legendEl, LEGEND_INLINE);\n\t\t\tlegend.live && addClass(legendEl, LEGEND_LIVE);\n\t\t}\n\t}\n\n\tconst son  = {show: true};\n\tconst soff = {show: false};\n\n\tfunction initLegendRow(s, i) {\n\t\tif (i == 0 && (multiValLegend || !legend.live))\n\t\t\treturn nullNullTuple;\n\n\t\tlet cells = [];\n\n\t\tlet row = placeTag(\"tr\", LEGEND_SERIES, legendEl, legendEl.childNodes[i]);\n\n\t\taddClass(row, s.class);\n\n\t\tif (!s.show)\n\t\t\taddClass(row, OFF);\n\n\t\tlet label = placeTag(\"th\", null, row);\n\n\t\tif (markers.show) {\n\t\t\tlet indic = placeDiv(LEGEND_MARKER, label);\n\n\t\t\tif (i > 0) {\n\t\t\t\tlet width  = markers.width(self, i);\n\n\t\t\t\tif (width)\n\t\t\t\t\tindic.style.border = width + \"px \" + markers.dash(self, i) + \" \" + markers.stroke(self, i);\n\n\t\t\t\tindic.style.background = markers.fill(self, i);\n\t\t\t}\n\t\t}\n\n\t\tlet text = placeDiv(LEGEND_LABEL, label);\n\t\ttext.textContent = s.label;\n\n\t\tif (i > 0) {\n\t\t\tif (!markers.show)\n\t\t\t\ttext.style.color = s.width > 0 ? markers.stroke(self, i) : markers.fill(self, i);\n\n\t\t\tonMouse(\"click\", label, e => {\n\t\t\t\tif (cursor._lock)\n\t\t\t\t\treturn;\n\n\t\t\t\tlet seriesIdx = series.indexOf(s);\n\n\t\t\t\tif (e.ctrlKey != legend.isolate) {\n\t\t\t\t\t// if any other series is shown, isolate this one. else show all\n\t\t\t\t\tlet isolate = series.some((s, i) => i > 0 && i != seriesIdx && s.show);\n\n\t\t\t\t\tseries.forEach((s, i) => {\n\t\t\t\t\t\ti > 0 && setSeries(i, isolate ? (i == seriesIdx ? son : soff) : son, syncOpts.setSeries);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tsetSeries(seriesIdx, {show: !s.show}, syncOpts.setSeries);\n\t\t\t});\n\n\t\t\tif (cursorFocus) {\n\t\t\t\tonMouse(mouseenter, label, e => {\n\t\t\t\t\tif (cursor._lock)\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\tsetSeries(series.indexOf(s), FOCUS_TRUE, syncOpts.setSeries);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tfor (var key in legendCols) {\n\t\t\tlet v = placeTag(\"td\", LEGEND_VALUE, row);\n\t\t\tv.textContent = \"--\";\n\t\t\tcells.push(v);\n\t\t}\n\n\t\treturn [row, cells];\n\t}\n\n\tconst mouseListeners = new Map();\n\n\tfunction onMouse(ev, targ, fn) {\n\t\tconst targListeners = mouseListeners.get(targ) || {};\n\t\tconst listener = cursor.bind[ev](self, targ, fn);\n\n\t\tif (listener) {\n\t\t\ton(ev, targ, targListeners[ev] = listener);\n\t\t\tmouseListeners.set(targ, targListeners);\n\t\t}\n\t}\n\n\tfunction offMouse(ev, targ, fn) {\n\t\tconst targListeners = mouseListeners.get(targ) || {};\n\n\t\tfor (let k in targListeners) {\n\t\t\tif (ev == null || k == ev) {\n\t\t\t\toff(k, targ, targListeners[k]);\n\t\t\t\tdelete targListeners[k];\n\t\t\t}\n\t\t}\n\n\t\tif (ev == null)\n\t\t\tmouseListeners.delete(targ);\n\t}\n\n\tlet fullWidCss = 0;\n\tlet fullHgtCss = 0;\n\n\tlet plotWidCss = 0;\n\tlet plotHgtCss = 0;\n\n\t// plot margins to account for axes\n\tlet plotLftCss = 0;\n\tlet plotTopCss = 0;\n\n\tlet plotLft = 0;\n\tlet plotTop = 0;\n\tlet plotWid = 0;\n\tlet plotHgt = 0;\n\n\tself.bbox = {};\n\n\tlet shouldSetScales = false;\n\tlet shouldSetSize = false;\n\tlet shouldConvergeSize = false;\n\tlet shouldSetCursor = false;\n\tlet shouldSetLegend = false;\n\n\tfunction _setSize(width, height) {\n\t\tif (width != self.width || height != self.height)\n\t\t\tcalcSize(width, height);\n\n\t\tresetYSeries(false);\n\n\t\tshouldConvergeSize = true;\n\t\tshouldSetSize = true;\n\t\tshouldSetCursor = cursor.left >= 0;\n\t\tshouldSetLegend = true;\n\t\tcommit();\n\t}\n\n\tfunction calcSize(width, height) {\n\t//\tlog(\"calcSize()\", arguments);\n\n\t\tself.width  = fullWidCss = plotWidCss = width;\n\t\tself.height = fullHgtCss = plotHgtCss = height;\n\t\tplotLftCss  = plotTopCss = 0;\n\n\t\tcalcPlotRect();\n\t\tcalcAxesRects();\n\n\t\tlet bb = self.bbox;\n\n\t\tplotLft = bb.left   = incrRound(plotLftCss * pxRatio, 0.5);\n\t\tplotTop = bb.top    = incrRound(plotTopCss * pxRatio, 0.5);\n\t\tplotWid = bb.width  = incrRound(plotWidCss * pxRatio, 0.5);\n\t\tplotHgt = bb.height = incrRound(plotHgtCss * pxRatio, 0.5);\n\n\t//\tupdOriDims();\n\t}\n\n\t// ensures size calc convergence\n\tconst CYCLE_LIMIT = 3;\n\n\tfunction convergeSize() {\n\t\tlet converged = false;\n\n\t\tlet cycleNum = 0;\n\n\t\twhile (!converged) {\n\t\t\tcycleNum++;\n\n\t\t\tlet axesConverged = axesCalc(cycleNum);\n\t\t\tlet paddingConverged = paddingCalc(cycleNum);\n\n\t\t\tconverged = cycleNum == CYCLE_LIMIT || (axesConverged && paddingConverged);\n\n\t\t\tif (!converged) {\n\t\t\t\tcalcSize(self.width, self.height);\n\t\t\t\tshouldSetSize = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction setSize({width, height}) {\n\t\t_setSize(width, height);\n\t}\n\n\tself.setSize = setSize;\n\n\t// accumulate axis offsets, reduce canvas width\n\tfunction calcPlotRect() {\n\t\t// easements for edge labels\n\t\tlet hasTopAxis = false;\n\t\tlet hasBtmAxis = false;\n\t\tlet hasRgtAxis = false;\n\t\tlet hasLftAxis = false;\n\n\t\taxes.forEach((axis, i) => {\n\t\t\tif (axis.show && axis._show) {\n\t\t\t\tlet {side, _size} = axis;\n\t\t\t\tlet isVt = side % 2;\n\t\t\t\tlet labelSize = axis.labelSize = (axis.label != null ? (axis.labelSize || 30) : 0);\n\n\t\t\t\tlet fullSize = _size + labelSize;\n\n\t\t\t\tif (fullSize > 0) {\n\t\t\t\t\tif (isVt) {\n\t\t\t\t\t\tplotWidCss -= fullSize;\n\n\t\t\t\t\t\tif (side == 3) {\n\t\t\t\t\t\t\tplotLftCss += fullSize;\n\t\t\t\t\t\t\thasLftAxis = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\thasRgtAxis = true;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tplotHgtCss -= fullSize;\n\n\t\t\t\t\t\tif (side == 0) {\n\t\t\t\t\t\t\tplotTopCss += fullSize;\n\t\t\t\t\t\t\thasTopAxis = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\thasBtmAxis = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tsidesWithAxes[0] = hasTopAxis;\n\t\tsidesWithAxes[1] = hasRgtAxis;\n\t\tsidesWithAxes[2] = hasBtmAxis;\n\t\tsidesWithAxes[3] = hasLftAxis;\n\n\t\t// hz padding\n\t\tplotWidCss -= _padding[1] + _padding[3];\n\t\tplotLftCss += _padding[3];\n\n\t\t// vt padding\n\t\tplotHgtCss -= _padding[2] + _padding[0];\n\t\tplotTopCss += _padding[0];\n\t}\n\n\tfunction calcAxesRects() {\n\t\t// will accum +\n\t\tlet off1 = plotLftCss + plotWidCss;\n\t\tlet off2 = plotTopCss + plotHgtCss;\n\t\t// will accum -\n\t\tlet off3 = plotLftCss;\n\t\tlet off0 = plotTopCss;\n\n\t\tfunction incrOffset(side, size) {\n\t\t\tswitch (side) {\n\t\t\t\tcase 1: off1 += size; return off1 - size;\n\t\t\t\tcase 2: off2 += size; return off2 - size;\n\t\t\t\tcase 3: off3 -= size; return off3 + size;\n\t\t\t\tcase 0: off0 -= size; return off0 + size;\n\t\t\t}\n\t\t}\n\n\t\taxes.forEach((axis, i) => {\n\t\t\tif (axis.show && axis._show) {\n\t\t\t\tlet side = axis.side;\n\n\t\t\t\taxis._pos = incrOffset(side, axis._size);\n\n\t\t\t\tif (axis.label != null)\n\t\t\t\t\taxis._lpos = incrOffset(side, axis.labelSize);\n\t\t\t}\n\t\t});\n\t}\n\n\tconst cursor = (self.cursor = assign({}, cursorOpts, opts.cursor));\n\n\t{\n\t\tcursor._lock = false;\n\n\t\tlet points = cursor.points;\n\n\t\tpoints.show   = fnOrSelf(points.show);\n\t\tpoints.size   = fnOrSelf(points.size);\n\t\tpoints.stroke = fnOrSelf(points.stroke);\n\t\tpoints.width  = fnOrSelf(points.width);\n\t\tpoints.fill   = fnOrSelf(points.fill);\n\t}\n\n\tconst focus = self.focus = assign({}, opts.focus || {alpha: 0.3}, cursor.focus);\n\tconst cursorFocus = focus.prox >= 0;\n\n\t// series-intersection markers\n\tlet cursorPts = [null];\n\n\tfunction initCursorPt(s, si) {\n\t\tif (si > 0) {\n\t\t\tlet pt = cursor.points.show(self, si);\n\n\t\t\tif (pt) {\n\t\t\t\taddClass(pt, CURSOR_PT);\n\t\t\t\taddClass(pt, s.class);\n\t\t\t\ttrans(pt, -10, -10, plotWidCss, plotHgtCss);\n\t\t\t\tover.insertBefore(pt, cursorPts[si]);\n\n\t\t\t\treturn pt;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction initSeries(s, i) {\n\t\tlet isTime = scales[s.scale].time;\n\n\t\tlet sv = s.value;\n\t\ts.value = isTime ? (isStr(sv) ? timeSeriesVal(_tzDate, timeSeriesStamp(sv, _fmtDate)) : sv || _timeSeriesVal) : sv || numSeriesVal;\n\t\ts.label = s.label || (isTime ? timeSeriesLabel : numSeriesLabel);\n\n\t\tif (i > 0) {\n\t\t\ts.width  = s.width == null ? 1 : s.width;\n\t\t\ts.paths  = s.paths || linearPath || retNull;\n\t\t\ts.fillTo = fnOrSelf(s.fillTo || seriesFillTo);\n\t\t\ts.pxAlign = +ifNull(s.pxAlign, pxAlign);\n\t\t\ts.pxRound = pxRoundGen(s.pxAlign);\n\n\t\t\ts.stroke = fnOrSelf(s.stroke || null);\n\t\t\ts.fill   = fnOrSelf(s.fill || null);\n\t\t\ts._stroke = s._fill = s._paths = s._focus = null;\n\n\t\t\tlet _ptDia = ptDia(s.width, 1);\n\t\t\tlet points = s.points = assign({}, {\n\t\t\t\tsize: _ptDia,\n\t\t\t\twidth: max(1, _ptDia * .2),\n\t\t\t\tstroke: s.stroke,\n\t\t\t\tspace: _ptDia * 2,\n\t\t\t\t_stroke: null,\n\t\t\t\t_fill: null,\n\t\t\t}, s.points);\n\t\t\tpoints.show   = fnOrSelf(points.show);\n\t\t\tpoints.fill   = fnOrSelf(points.fill);\n\t\t\tpoints.stroke = fnOrSelf(points.stroke);\n\t\t}\n\n\t\tif (showLegend) {\n\t\t\tlet rowCells = initLegendRow(s, i);\n\t\t\tlegendRows.splice(i, 0, rowCells[0]);\n\t\t\tlegendCells.splice(i, 0, rowCells[1]);\n\t\t\tlegend.values.push(null);\t// NULL_LEGEND_VALS not yet avil here :(\n\t\t}\n\n\t\tif (cursor.show) {\n\t\t\tlet pt = initCursorPt(s, i);\n\t\t\tpt && cursorPts.splice(i, 0, pt);\n\t\t}\n\t}\n\n\tfunction addSeries(opts, si) {\n\t\tsi = si == null ? series.length : si;\n\n\t\topts = setDefault(opts, si, xSeriesOpts, ySeriesOpts);\n\t\tseries.splice(si, 0, opts);\n\t\tinitSeries(series[si], si);\n\t}\n\n\tself.addSeries = addSeries;\n\n\tfunction delSeries(i) {\n\t\tseries.splice(i, 1);\n\n\t\tif (showLegend) {\n\t\t\tlegend.values.splice(i, 1);\n\n\t\t\tlegendCells.splice(i, 1);\n\t\t\tlet tr = legendRows.splice(i, 1)[0];\n\t\t\toffMouse(null, tr.firstChild);\n\t\t\ttr.remove();\n\t\t}\n\n\t\tcursorPts.length > 1 && cursorPts.splice(i, 1)[0].remove();\n\n\t\t// TODO: de-init no-longer-needed scales?\n\t}\n\n\tself.delSeries = delSeries;\n\n\tconst sidesWithAxes = [false, false, false, false];\n\n\tfunction initAxis(axis, i) {\n\t\taxis._show = axis.show;\n\n\t\tif (axis.show) {\n\t\t\tlet isVt = axis.side % 2;\n\n\t\t\tlet sc = scales[axis.scale];\n\n\t\t\t// this can occur if all series specify non-default scales\n\t\t\tif (sc == null) {\n\t\t\t\taxis.scale = isVt ? series[1].scale : xScaleKey;\n\t\t\t\tsc = scales[axis.scale];\n\t\t\t}\n\n\t\t\t// also set defaults for incrs & values based on axis distr\n\t\t\tlet isTime = sc.time;\n\n\t\t\taxis.size   = fnOrSelf(axis.size);\n\t\t\taxis.space  = fnOrSelf(axis.space);\n\t\t\taxis.rotate = fnOrSelf(axis.rotate);\n\t\t\taxis.incrs  = fnOrSelf(axis.incrs  || (          sc.distr == 2 ? wholeIncrs : (isTime ? (ms == 1 ? timeIncrsMs : timeIncrsS) : numIncrs)));\n\t\t\taxis.splits = fnOrSelf(axis.splits || (isTime && sc.distr == 1 ? _timeAxisSplits : sc.distr == 3 ? logAxisSplits : sc.distr == 4 ? asinhAxisSplits : numAxisSplits));\n\n\t\t\taxis.stroke       = fnOrSelf(axis.stroke);\n\t\t\taxis.grid.stroke  = fnOrSelf(axis.grid.stroke);\n\t\t\taxis.ticks.stroke = fnOrSelf(axis.ticks.stroke);\n\n\t\t\tlet av = axis.values;\n\n\t\t\taxis.values = (\n\t\t\t\t// static array of tick values\n\t\t\t\tisArr(av) && !isArr(av[0]) ? fnOrSelf(av) :\n\t\t\t\t// temporal\n\t\t\t\tisTime ? (\n\t\t\t\t\t// config array of fmtDate string tpls\n\t\t\t\t\tisArr(av) ?\n\t\t\t\t\t\ttimeAxisVals(_tzDate, timeAxisStamps(av, _fmtDate)) :\n\t\t\t\t\t// fmtDate string tpl\n\t\t\t\t\tisStr(av) ?\n\t\t\t\t\t\ttimeAxisVal(_tzDate, av) :\n\t\t\t\t\tav || _timeAxisVals\n\t\t\t\t) : av || numAxisVals\n\t\t\t);\n\n\t\t\taxis.filter = fnOrSelf(axis.filter || (          sc.distr >= 3 ? logAxisValsFilt : retArg1));\n\n\t\t\taxis.font      = pxRatioFont(axis.font);\n\t\t\taxis.labelFont = pxRatioFont(axis.labelFont);\n\n\t\t\taxis._size   = axis.size(self, null, i, 0);\n\n\t\t\taxis._space  =\n\t\t\taxis._rotate =\n\t\t\taxis._incrs  =\n\t\t\taxis._found  =\t// foundIncrSpace\n\t\t\taxis._splits =\n\t\t\taxis._values = null;\n\n\t\t\tif (axis._size > 0)\n\t\t\t\tsidesWithAxes[i] = true;\n\t\t}\n\t}\n\n\tfunction autoPadSide(self, side, sidesWithAxes, cycleNum) {\n\t\tlet [hasTopAxis, hasRgtAxis, hasBtmAxis, hasLftAxis] = sidesWithAxes;\n\n\t\tlet ori = side % 2;\n\t\tlet size = 0;\n\n\t\tif (ori == 0 && (hasLftAxis || hasRgtAxis))\n\t\t\tsize = (side == 0 && !hasTopAxis || side == 2 && !hasBtmAxis ? round(xAxisOpts.size / 3) : 0);\n\t\tif (ori == 1 && (hasTopAxis || hasBtmAxis))\n\t\t\tsize = (side == 1 && !hasRgtAxis || side == 3 && !hasLftAxis ? round(yAxisOpts.size / 2) : 0);\n\n\t\treturn size;\n\t}\n\n\tconst padding = self.padding = (opts.padding || [autoPadSide,autoPadSide,autoPadSide,autoPadSide]).map(p => fnOrSelf(ifNull(p, autoPadSide)));\n\tconst _padding = self._padding = padding.map((p, i) => p(self, i, sidesWithAxes, 0));\n\n\tlet dataLen;\n\n\t// rendered data window\n\tlet i0 = null;\n\tlet i1 = null;\n\tconst idxs = series[0].idxs;\n\n\tlet data0 = null;\n\n\tlet viaAutoScaleX = false;\n\n\tfunction setData(_data, _resetScales) {\n\t\tdata = (_data || []).slice();\n\t\tdata[0] = data[0] || [];\n\n\t\tself.data = data.slice();\n\t\tdata0 = data[0];\n\t\tdataLen = data0.length;\n\n\t\tif (xScaleDistr == 2)\n\t\t\tdata[0] = data0.map((v, i) => i);\n\n\t\tself._data = data;\n\n\t\tresetYSeries(true);\n\n\t\tfire(\"setData\");\n\n\t\tif (_resetScales !== false) {\n\t\t\tlet xsc = scaleX;\n\n\t\t\tif (xsc.auto(self, viaAutoScaleX))\n\t\t\t\tautoScaleX();\n\t\t\telse\n\t\t\t\t_setScale(xScaleKey, xsc.min, xsc.max);\n\n\t\t\tshouldSetCursor = cursor.left >= 0;\n\t\t\tshouldSetLegend = true;\n\t\t\tcommit();\n\t\t}\n\t}\n\n\tself.setData = setData;\n\n\tfunction autoScaleX() {\n\t\tviaAutoScaleX = true;\n\n\t\tlet _min, _max;\n\n\t\tif (dataLen > 0) {\n\t\t\ti0 = idxs[0] = 0;\n\t\t\ti1 = idxs[1] = dataLen - 1;\n\n\t\t\t_min = data[0][i0];\n\t\t\t_max = data[0][i1];\n\n\t\t\tif (xScaleDistr == 2) {\n\t\t\t\t_min = i0;\n\t\t\t\t_max = i1;\n\t\t\t}\n\t\t\telse if (dataLen == 1) {\n\t\t\t\tif (xScaleDistr == 3)\n\t\t\t\t\t[_min, _max] = rangeLog(_min, _min, scaleX.log, false);\n\t\t\t\telse if (xScaleDistr == 4)\n\t\t\t\t\t[_min, _max] = rangeAsinh(_min, _min, scaleX.log, false);\n\t\t\t\telse if (scaleX.time)\n\t\t\t\t\t_max = _min + round(86400 / ms);\n\t\t\t\telse\n\t\t\t\t\t[_min, _max] = rangeNum(_min, _max, 0.1, true);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\ti0 = idxs[0] = _min = null;\n\t\t\ti1 = idxs[1] = _max = null;\n\t\t}\n\n\t\t_setScale(xScaleKey, _min, _max);\n\t}\n\n\tfunction setCtxStyle(stroke, width, dash, cap, fill) {\n\t\tctx.strokeStyle = stroke || transparent;\n\t\tctx.lineWidth = width;\n\t\tctx.lineJoin = \"round\";\n\t\tctx.lineCap = cap || \"butt\"; // (â¿|â¿)\n\t\tctx.setLineDash(dash || []);\n\t\tctx.fillStyle = fill || transparent;\n\t}\n\n\tfunction setScales() {\n\t//\tlog(\"setScales()\", arguments);\n\n\t\t// wip scales\n\t\tlet wipScales = copy(scales, fastIsObj);\n\n\t\tfor (let k in wipScales) {\n\t\t\tlet wsc = wipScales[k];\n\t\t\tlet psc = pendScales[k];\n\n\t\t\tif (psc != null && psc.min != null) {\n\t\t\t\tassign(wsc, psc);\n\n\t\t\t\t// explicitly setting the x-scale invalidates everything (acts as redraw)\n\t\t\t\tif (k == xScaleKey)\n\t\t\t\t\tresetYSeries(true);\n\t\t\t}\n\t\t\telse if (k != xScaleKey) {\n\t\t\t\tif (dataLen == 0 && wsc.from == null) {\n\t\t\t\t\tlet minMax = wsc.range(self, null, null, k);\n\t\t\t\t\twsc.min = minMax[0];\n\t\t\t\t\twsc.max = minMax[1];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twsc.min = inf;\n\t\t\t\t\twsc.max = -inf;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (dataLen > 0) {\n\t\t\t// pre-range y-scales from y series' data values\n\t\t\tseries.forEach((s, i) => {\n\t\t\t\tlet k = s.scale;\n\t\t\t\tlet wsc = wipScales[k];\n\t\t\t\tlet psc = pendScales[k];\n\n\t\t\t\tif (i == 0) {\n\t\t\t\t\tlet minMax = wsc.range(self, wsc.min, wsc.max, k);\n\n\t\t\t\t\twsc.min = minMax[0];\n\t\t\t\t\twsc.max = minMax[1];\n\n\t\t\t\t\ti0 = closestIdx(wsc.min, data[0]);\n\t\t\t\t\ti1 = closestIdx(wsc.max, data[0]);\n\n\t\t\t\t\t// closest indices can be outside of view\n\t\t\t\t\tif (data[0][i0] < wsc.min)\n\t\t\t\t\t\ti0++;\n\t\t\t\t\tif (data[0][i1] > wsc.max)\n\t\t\t\t\t\ti1--;\n\n\t\t\t\t\ts.min = data0[i0];\n\t\t\t\t\ts.max = data0[i1];\n\t\t\t\t}\n\t\t\t\telse if (s.show && s.auto && wsc.auto(self, viaAutoScaleX) && (psc == null || psc.min == null)) {\n\t\t\t\t\t// only run getMinMax() for invalidated series data, else reuse\n\t\t\t\t\tlet minMax = s.min == null ? (wsc.distr == 3 ? getMinMaxLog(data[i], i0, i1) : getMinMax(data[i], i0, i1, s.sorted)) : [s.min, s.max];\n\n\t\t\t\t\t// initial min/max\n\t\t\t\t\twsc.min = min(wsc.min, s.min = minMax[0]);\n\t\t\t\t\twsc.max = max(wsc.max, s.max = minMax[1]);\n\t\t\t\t}\n\n\t\t\t\ts.idxs[0] = i0;\n\t\t\t\ts.idxs[1] = i1;\n\t\t\t});\n\n\t\t\t// range independent scales\n\t\t\tfor (let k in wipScales) {\n\t\t\t\tlet wsc = wipScales[k];\n\t\t\t\tlet psc = pendScales[k];\n\n\t\t\t\tif (wsc.from == null && (psc == null || psc.min == null)) {\n\t\t\t\t\tlet minMax = wsc.range(\n\t\t\t\t\t\tself,\n\t\t\t\t\t\twsc.min ==  inf ? null : wsc.min,\n\t\t\t\t\t\twsc.max == -inf ? null : wsc.max,\n\t\t\t\t\t\tk\n\t\t\t\t\t);\n\t\t\t\t\twsc.min = minMax[0];\n\t\t\t\t\twsc.max = minMax[1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// range dependent scales\n\t\tfor (let k in wipScales) {\n\t\t\tlet wsc = wipScales[k];\n\n\t\t\tif (wsc.from != null) {\n\t\t\t\tlet base = wipScales[wsc.from];\n\t\t\t\tlet minMax = wsc.range(self, base.min, base.max, k);\n\t\t\t\twsc.min = minMax[0];\n\t\t\t\twsc.max = minMax[1];\n\t\t\t}\n\t\t}\n\n\t\tlet changed = {};\n\t\tlet anyChanged = false;\n\n\t\tfor (let k in wipScales) {\n\t\t\tlet wsc = wipScales[k];\n\t\t\tlet sc = scales[k];\n\n\t\t\tif (sc.min != wsc.min || sc.max != wsc.max) {\n\t\t\t\tsc.min = wsc.min;\n\t\t\t\tsc.max = wsc.max;\n\n\t\t\t\tlet distr = sc.distr;\n\n\t\t\t\tsc._min = distr == 3 ? log10(sc.min) : distr == 4 ? asinh(sc.min, sc.asinh) : sc.min;\n\t\t\t\tsc._max = distr == 3 ? log10(sc.max) : distr == 4 ? asinh(sc.max, sc.asinh) : sc.max;\n\n\t\t\t\tchanged[k] = anyChanged = true;\n\t\t\t}\n\t\t}\n\n\t\tif (anyChanged) {\n\t\t\t// invalidate paths of all series on changed scales\n\t\t\tseries.forEach(s => {\n\t\t\t\tif (changed[s.scale])\n\t\t\t\t\ts._paths = null;\n\t\t\t});\n\n\t\t\tfor (let k in changed) {\n\t\t\t\tshouldConvergeSize = true;\n\t\t\t\tfire(\"setScale\", k);\n\t\t\t}\n\n\t\t\tif (cursor.show)\n\t\t\t\tshouldSetCursor = cursor.left >= 0;\n\t\t}\n\n\t\tfor (let k in pendScales)\n\t\t\tpendScales[k] = null;\n\t}\n\n\t// TODO: drawWrap(si, drawPoints) (save, restore, translate, clip)\n\tfunction drawPoints(si) {\n\t//\tlog(\"drawPoints()\", arguments);\n\n\t\tlet s = series[si];\n\t\tlet p = s.points;\n\t\tlet _pxRound = s.pxRound;\n\n\t\tconst width = roundDec(p.width * pxRatio, 3);\n\t\tconst offset = (width % 2) / 2;\n\t\tconst isStroked = p.width > 0;\n\n\t\tlet rad = (p.size - p.width) / 2 * pxRatio;\n\t\tlet dia = roundDec(rad * 2, 3);\n\n\t\tconst _pxAlign = s.pxAlign == 1;\n\n\t\t_pxAlign && ctx.translate(offset, offset);\n\n\t\tctx.save();\n\n\t\tctx.beginPath();\n\t\tctx.rect(\n\t\t\tplotLft - dia,\n\t\t\tplotTop - dia,\n\t\t\tplotWid + dia * 2,\n\t\t\tplotHgt + dia * 2,\n\t\t);\n\t\tctx.clip();\n\n\t\tctx.globalAlpha = s.alpha;\n\n\t\tconst path = new Path2D();\n\n\t\tconst scaleY = scales[s.scale];\n\n\t\tlet xDim, xOff, yDim, yOff;\n\n\t\tif (scaleX.ori == 0) {\n\t\t\txDim = plotWid;\n\t\t\txOff = plotLft;\n\t\t\tyDim = plotHgt;\n\t\t\tyOff = plotTop;\n\t\t}\n\t\telse {\n\t\t\txDim = plotHgt;\n\t\t\txOff = plotTop;\n\t\t\tyDim = plotWid;\n\t\t\tyOff = plotLft;\n\t\t}\n\n\t\tfor (let pi = i0; pi <= i1; pi++) {\n\t\t\tif (data[si][pi] != null) {\n\t\t\t\tlet x = _pxRound(valToPosX(data[0][pi],  scaleX, xDim, xOff));\n\t\t\t\tlet y = _pxRound(valToPosY(data[si][pi], scaleY, yDim, yOff));\n\n\t\t\t\tmoveTo(path, x + rad, y);\n\t\t\t\tarc(path, x, y, rad, 0, PI * 2);\n\t\t\t}\n\t\t}\n\n\t\tconst _stroke = p._stroke = p.stroke(self, si);\n\t\tconst _fill   = p._fill   = p.fill(self, si);\n\n\t\tsetCtxStyle(\n\t\t\t_stroke,\n\t\t\twidth,\n\t\t\tp.dash,\n\t\t\tp.cap,\n\t\t\t_fill || (isStroked ? \"#fff\" : s._stroke),\n\t\t);\n\n\t\tctx.fill(path);\n\t\tisStroked && ctx.stroke(path);\n\n\t\tctx.globalAlpha = 1;\n\n\t\tctx.restore();\n\n\t\t_pxAlign && ctx.translate(-offset, -offset);\n\t}\n\n\t// grabs the nearest indices with y data outside of x-scale limits\n\tfunction getOuterIdxs(ydata) {\n\t\tlet _i0 = clamp(i0 - 1, 0, dataLen - 1);\n\t\tlet _i1 = clamp(i1 + 1, 0, dataLen - 1);\n\n\t\twhile (ydata[_i0] == null && _i0 > 0)\n\t\t\t_i0--;\n\n\t\twhile (ydata[_i1] == null && _i1 < dataLen - 1)\n\t\t\t_i1++;\n\n\t\treturn [_i0, _i1];\n\t}\n\n\tfunction drawSeries() {\n\t\tif (dataLen > 0) {\n\t\t\tseries.forEach((s, i) => {\n\t\t\t\tif (i > 0 && s.show && s._paths == null) {\n\t\t\t\t\tlet _idxs = getOuterIdxs(data[i]);\n\t\t\t\t\ts._paths = s.paths(self, i, _idxs[0], _idxs[1]);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tseries.forEach((s, i) => {\n\t\t\t\tif (i > 0 && s.show) {\n\t\t\t\t\tif (s._paths)\n\t\t\t\t\t\tdrawPath(i);\n\n\t\t\t\t\tif (s.points.show(self, i, i0, i1))\n\t\t\t\t\t\tdrawPoints(i);\n\n\t\t\t\t\tfire(\"drawSeries\", i);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tfunction drawPath(si) {\n\t\tconst s = series[si];\n\n\t\tconst { stroke, fill, clip, flags } = s._paths;\n\t\tconst width = roundDec(s.width * pxRatio, 3);\n\t\tconst offset = (width % 2) / 2;\n\n\t\tconst strokeStyle = s._stroke = s.stroke(self, si);\n\t\tconst fillStyle   = s._fill   = s.fill(self, si);\n\n\t\tctx.globalAlpha = s.alpha;\n\n\t\tconst _pxAlign = s.pxAlign == 1;\n\n\t\t_pxAlign && ctx.translate(offset, offset);\n\n\t\tctx.save();\n\n\t\tlet lft = plotLft,\n\t\t\ttop = plotTop,\n\t\t\twid = plotWid,\n\t\t\thgt = plotHgt;\n\n\t\tlet halfWid = width * pxRatio / 2;\n\n\t\tif (s.min == 0)\n\t\t\thgt += halfWid;\n\n\t\tif (s.max == 0) {\n\t\t\ttop -= halfWid;\n\t\t\thgt += halfWid;\n\t\t}\n\n\t\tctx.beginPath();\n\t\tctx.rect(lft, top, wid, hgt);\n\t\tctx.clip();\n\n\t\tclip && ctx.clip(clip);\n\n\t\tfillStroke(si, strokeStyle, width, s.dash, s.cap, fillStyle, stroke, fill, flags);\n\n\t\tctx.restore();\n\n\t\t_pxAlign && ctx.translate(-offset, -offset);\n\n\t\tctx.globalAlpha = 1;\n\t}\n\n\tfunction fillStroke(si, strokeStyle, lineWidth, lineDash, lineCap, fillStyle, strokePath, fillPath, flags) {\n\t\tlet didStrokeFill = false;\n\n\t\t// for all bands where this series is the top edge, create upwards clips using the bottom edges\n\t\t// and apply clips + fill with band fill or dfltFill\n\t\tbands.forEach((b, bi) => {\n\t\t\t// isUpperEdge?\n\t\t\tif (b.series[0] == si) {\n\t\t\t\tlet lowerEdge = series[b.series[1]];\n\n\t\t\t\tlet clip = (lowerEdge._paths || EMPTY_OBJ).band;\n\n\t\t\t\tctx.save();\n\n\t\t\t\tlet _fillStyle = null;\n\n\t\t\t\t// hasLowerEdge?\n\t\t\t\tif (lowerEdge.show && clip)\n\t\t\t\t\t_fillStyle = b.fill(self, bi) || fillStyle;\n\t\t\t\telse\n\t\t\t\t\tclip = null;\n\n\t\t\t\tstrokeFill(strokeStyle, lineWidth, lineDash, lineCap, _fillStyle, strokePath, fillPath, clip, flags);\n\n\t\t\t\tctx.restore();\n\n\t\t\t\tdidStrokeFill = true;\n\t\t\t}\n\t\t});\n\n\t\tif (!didStrokeFill)\n\t\t\tstrokeFill(strokeStyle, lineWidth, lineDash, lineCap, fillStyle, strokePath, fillPath, null, flags);\n\t}\n\n\tconst CLIP_FILL_STROKE = BAND_CLIP_FILL | BAND_CLIP_STROKE;\n\n\tfunction strokeFill(strokeStyle, lineWidth, lineDash, lineCap, fillStyle, strokePath, fillPath, clip, flags) {\n\t\tsetCtxStyle(strokeStyle, lineWidth, lineDash, lineCap, fillStyle);\n\n\t\tif (clip) {\n\t\t\tif ((flags & CLIP_FILL_STROKE) == CLIP_FILL_STROKE) {\n\t\t\t\tctx.clip(clip);\n\t\t\t\tdoFill(fillStyle, fillPath);\n\t\t\t\tdoStroke(strokeStyle, strokePath, lineWidth);\n\t\t\t}\n\t\t\telse if (flags & BAND_CLIP_STROKE) {\n\t\t\t\tdoFill(fillStyle, fillPath);\n\t\t\t\tctx.clip(clip);\n\t\t\t\tdoStroke(strokeStyle, strokePath, lineWidth);\n\t\t\t}\n\t\t\telse if (flags & BAND_CLIP_FILL) {\n\t\t\t\tctx.save();\n\t\t\t\tctx.clip(clip);\n\t\t\t\tdoFill(fillStyle, fillPath);\n\t\t\t\tctx.restore();\n\t\t\t\tdoStroke(strokeStyle, strokePath, lineWidth);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tdoFill(fillStyle, fillPath);\n\t\t\tdoStroke(strokeStyle, strokePath, lineWidth);\n\t\t}\n\t}\n\n\tfunction doStroke(strokeStyle, strokePath, lineWidth) {\n\t\tstrokeStyle && strokePath && lineWidth && ctx.stroke(strokePath);\n\t}\n\n\tfunction doFill(fillStyle, fillPath) {\n\t\tfillStyle   && fillPath && ctx.fill(fillPath);\n\t}\n\n\tfunction getIncrSpace(axisIdx, min, max, fullDim) {\n\t\tlet axis = axes[axisIdx];\n\n\t\tlet incrSpace;\n\n\t\tif (fullDim <= 0)\n\t\t\tincrSpace = [0, 0];\n\t\telse {\n\t\t\tlet minSpace = axis._space = axis.space(self, axisIdx, min, max, fullDim);\n\t\t\tlet incrs    = axis._incrs = axis.incrs(self, axisIdx, min, max, fullDim, minSpace);\n\t\t\tincrSpace    = axis._found = findIncr(min, max, incrs, fullDim, minSpace);\n\t\t}\n\n\t\treturn incrSpace;\n\t}\n\n\tfunction drawOrthoLines(offs, filts, ori, side, pos0, len, width, stroke, dash, cap) {\n\t\tlet offset = (width % 2) / 2;\n\n\t\tpxAlign == 1 && ctx.translate(offset, offset);\n\n\t\tsetCtxStyle(stroke, width, dash, cap);\n\n\t\tctx.beginPath();\n\n\t\tlet x0, y0, x1, y1, pos1 = pos0 + (side == 0 || side == 3 ? -len : len);\n\n\t\tif (ori == 0) {\n\t\t\ty0 = pos0;\n\t\t\ty1 = pos1;\n\t\t}\n\t\telse {\n\t\t\tx0 = pos0;\n\t\t\tx1 = pos1;\n\t\t}\n\n\t\toffs.forEach((off, i) => {\n\t\t\tif (filts[i] == null)\n\t\t\t\treturn;\n\n\t\t\tif (ori == 0)\n\t\t\t\tx0 = x1 = off;\n\t\t\telse\n\t\t\t\ty0 = y1 = off;\n\n\t\t\tctx.moveTo(x0, y0);\n\t\t\tctx.lineTo(x1, y1);\n\t\t});\n\n\t\tctx.stroke();\n\n\t\tpxAlign == 1 && ctx.translate(-offset, -offset);\n\t}\n\n\tfunction axesCalc(cycleNum) {\n\t//\tlog(\"axesCalc()\", arguments);\n\n\t\tlet converged = true;\n\n\t\taxes.forEach((axis, i) => {\n\t\t\tif (!axis.show)\n\t\t\t\treturn;\n\n\t\t\tlet scale = scales[axis.scale];\n\n\t\t\tif (scale.min == null) {\n\t\t\t\tif (axis._show) {\n\t\t\t\t\tconverged = false;\n\t\t\t\t\taxis._show = false;\n\t\t\t\t\tresetYSeries(false);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!axis._show) {\n\t\t\t\t\tconverged = false;\n\t\t\t\t\taxis._show = true;\n\t\t\t\t\tresetYSeries(false);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet side = axis.side;\n\t\t\tlet ori = side % 2;\n\n\t\t\tlet {min, max} = scale;\t\t// \t\t// should this toggle them ._show = false\n\n\t\t\tlet [_incr, _space] = getIncrSpace(i, min, max, ori == 0 ? plotWidCss : plotHgtCss);\n\n\t\t\tif (_space == 0)\n\t\t\t\treturn;\n\n\t\t\t// if we're using index positions, force first tick to match passed index\n\t\t\tlet forceMin = scale.distr == 2;\n\n\t\t\tlet _splits = axis._splits = axis.splits(self, i, min, max, _incr, _space, forceMin);\n\n\t\t\t// tick labels\n\t\t\t// BOO this assumes a specific data/series\n\t\t\tlet splits = scale.distr == 2 ? _splits.map(i => data0[i]) : _splits;\n\t\t\tlet incr   = scale.distr == 2 ? data0[_splits[1]] - data0[_splits[0]] : _incr;\n\n\t\t\tlet values = axis._values = axis.values(self, axis.filter(self, splits, i, _space, incr), i, _space, incr);\n\n\t\t\t// rotating of labels only supported on bottom x axis\n\t\t\taxis._rotate = side == 2 ? axis.rotate(self, values, i, _space) : 0;\n\n\t\t\tlet oldSize = axis._size;\n\n\t\t\taxis._size = ceil(axis.size(self, values, i, cycleNum));\n\n\t\t\tif (oldSize != null && axis._size != oldSize)\t\t\t// ready && ?\n\t\t\t\tconverged = false;\n\t\t});\n\n\t\treturn converged;\n\t}\n\n\tfunction paddingCalc(cycleNum) {\n\t\tlet converged = true;\n\n\t\tpadding.forEach((p, i) => {\n\t\t\tlet _p = p(self, i, sidesWithAxes, cycleNum);\n\n\t\t\tif (_p != _padding[i])\n\t\t\t\tconverged = false;\n\n\t\t\t_padding[i] = _p;\n\t\t});\n\n\t\treturn converged;\n\t}\n\n\tfunction drawAxesGrid() {\n\t\taxes.forEach((axis, i) => {\n\t\t\tif (!axis.show || !axis._show)\n\t\t\t\treturn;\n\n\t\t\tlet scale = scales[axis.scale];\n\t\t\tlet side = axis.side;\n\t\t\tlet ori = side % 2;\n\n\t\t\tlet plotDim = ori == 0 ? plotWid : plotHgt;\n\t\t\tlet plotOff = ori == 0 ? plotLft : plotTop;\n\n\t\t\tlet axisGap = round(axis.gap * pxRatio);\n\n\t\t\tlet [_incr, _space] = axis._found;\n\n\t\t\tlet x, y;\n\n\t\t\tlet fillStyle = axis.stroke(self, i);\n\n\t\t\t// axis label\n\t\t\tif (axis.label) {\n\t\t\t\tctx.save();\n\n\t\t\t\tlet baseLpos = round(axis._lpos * pxRatio);\n\n\t\t\t\tif (ori == 1) {\n\t\t\t\t\tx = y = 0;\n\n\t\t\t\t\tctx.translate(\n\t\t\t\t\t\tbaseLpos,\n\t\t\t\t\t\tround(plotTop + plotHgt / 2),\n\t\t\t\t\t);\n\t\t\t\t\tctx.rotate((side == 3 ? -PI : PI) / 2);\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tx = round(plotLft + plotWid / 2);\n\t\t\t\t\ty = baseLpos;\n\t\t\t\t}\n\n\t\t\t\tctx.font         = axis.labelFont[0];\n\t\t\t\tctx.fillStyle    = fillStyle;\n\t\t\t\tctx.textAlign    = \"center\";\n\t\t\t\tctx.textBaseline = side == 2 ? TOP : BOTTOM;\n\n\t\t\t\tctx.fillText(axis.label, x, y);\n\n\t\t\t\tctx.restore();\n\t\t\t}\n\n\t\t\tif (_space == 0)\n\t\t\t\treturn;\n\n\t\t\tlet _splits = axis._splits;\n\n\t\t\t// tick labels\n\t\t\t// BOO this assumes a specific data/series\n\t\t\tlet splits = scale.distr == 2 ? _splits.map(i => data0[i]) : _splits;\n\t\t\tlet incr   = scale.distr == 2 ? data0[_splits[1]] - data0[_splits[0]] : _incr;\n\n\t\t\tlet ticks = axis.ticks;\n\t\t\tlet tickSize = ticks.show ? round(ticks.size * pxRatio) : 0;\n\n\t\t\t// rotating of labels only supported on bottom x axis\n\t\t\tlet angle = axis._rotate * -PI/180;\n\n\t\t\tlet basePos  = pxRound(axis._pos * pxRatio);\n\t\t\tlet shiftAmt = tickSize + axisGap;\n\t\t\tlet shiftDir = ori == 0 && side == 0 || ori == 1 && side == 3 ? -1 : 1;\n\t\t\tlet finalPos = basePos + shiftAmt * shiftDir;\n\t\t\t    y        = ori == 0 ? finalPos : 0;\n\t\t\t    x        = ori == 1 ? finalPos : 0;\n\n\t\t\tctx.font         = axis.font[0];\n\t\t\tctx.fillStyle    = fillStyle;\n\t\t\tctx.textAlign    = axis.align == 1 ? LEFT :\n\t\t\t                   axis.align == 2 ? RIGHT :\n\t\t\t                   angle > 0 ? LEFT :\n\t\t\t                   angle < 0 ? RIGHT :\n\t\t\t                   ori == 0 ? \"center\" : side == 3 ? RIGHT : LEFT;\n\t\t\tctx.textBaseline = angle ||\n\t\t\t                   ori == 1 ? \"middle\" : side == 2 ? TOP   : BOTTOM;\n\n\t\t\tlet lineHeight = axis.font[1] * lineMult;\n\n\t\t\tlet canOffs = _splits.map(val => pxRound(getPos(val, scale, plotDim, plotOff)));\n\n\t\t\taxis._values.forEach((val, i) => {\n\t\t\t\tif (val == null)\n\t\t\t\t\treturn;\n\n\t\t\t\tif (ori == 0)\n\t\t\t\t\tx = canOffs[i];\n\t\t\t\telse\n\t\t\t\t\ty = canOffs[i];\n\n\t\t\t\t(\"\"+val).split(/\\n/gm).forEach((text, j) => {\n\t\t\t\t\tif (angle) {\n\t\t\t\t\t\tctx.save();\n\t\t\t\t\t\tctx.translate(x, y + j * lineHeight);\n\t\t\t\t\t\tctx.rotate(angle);\n\t\t\t\t\t\tctx.fillText(text, 0, 0);\n\t\t\t\t\t\tctx.restore();\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tctx.fillText(text, x, y + j * lineHeight);\n\t\t\t\t});\n\t\t\t});\n\n\t\t\t// ticks\n\t\t\tif (ticks.show) {\n\t\t\t\tdrawOrthoLines(\n\t\t\t\t\tcanOffs,\n\t\t\t\t\tticks.filter(self, splits, i, _space, incr),\n\t\t\t\t\tori,\n\t\t\t\t\tside,\n\t\t\t\t\tbasePos,\n\t\t\t\t\ttickSize,\n\t\t\t\t\troundDec(ticks.width * pxRatio, 3),\n\t\t\t\t\tticks.stroke(self, i),\n\t\t\t\t\tticks.dash,\n\t\t\t\t\tticks.cap,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// grid\n\t\t\tlet grid = axis.grid;\n\n\t\t\tif (grid.show) {\n\t\t\t\tdrawOrthoLines(\n\t\t\t\t\tcanOffs,\n\t\t\t\t\tgrid.filter(self, splits, i, _space, incr),\n\t\t\t\t\tori,\n\t\t\t\t\tori == 0 ? 2 : 1,\n\t\t\t\t\tori == 0 ? plotTop : plotLft,\n\t\t\t\t\tori == 0 ? plotHgt : plotWid,\n\t\t\t\t\troundDec(grid.width * pxRatio, 3),\n\t\t\t\t\tgrid.stroke(self, i),\n\t\t\t\t\tgrid.dash,\n\t\t\t\t\tgrid.cap,\n\t\t\t\t);\n\t\t\t}\n\t\t});\n\n\t\tfire(\"drawAxes\");\n\t}\n\n\tfunction resetYSeries(minMax) {\n\t//\tlog(\"resetYSeries()\", arguments);\n\n\t\tseries.forEach((s, i) => {\n\t\t\tif (i > 0) {\n\t\t\t\ts._paths = null;\n\n\t\t\t\tif (minMax) {\n\t\t\t\t\ts.min = null;\n\t\t\t\t\ts.max = null;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tlet queuedCommit = false;\n\n\tfunction commit() {\n\t\tif (!queuedCommit) {\n\t\t\tmicroTask(_commit);\n\t\t\tqueuedCommit = true;\n\t\t}\n\t}\n\n\tfunction _commit() {\n\t//\tlog(\"_commit()\", arguments);\n\n\t\tif (shouldSetScales) {\n\t\t\tsetScales();\n\t\t\tshouldSetScales = false;\n\t\t}\n\n\t\tif (shouldConvergeSize) {\n\t\t\tconvergeSize();\n\t\t\tshouldConvergeSize = false;\n\t\t}\n\n\t\tif (shouldSetSize) {\n\t\t\tsetStylePx(under, LEFT,   plotLftCss);\n\t\t\tsetStylePx(under, TOP,    plotTopCss);\n\t\t\tsetStylePx(under, WIDTH,  plotWidCss);\n\t\t\tsetStylePx(under, HEIGHT, plotHgtCss);\n\n\t\t\tsetStylePx(over, LEFT,    plotLftCss);\n\t\t\tsetStylePx(over, TOP,     plotTopCss);\n\t\t\tsetStylePx(over, WIDTH,   plotWidCss);\n\t\t\tsetStylePx(over, HEIGHT,  plotHgtCss);\n\n\t\t\tsetStylePx(wrap, WIDTH,   fullWidCss);\n\t\t\tsetStylePx(wrap, HEIGHT,  fullHgtCss);\n\n\t\t\tcan.width  = round(fullWidCss * pxRatio);\n\t\t\tcan.height = round(fullHgtCss * pxRatio);\n\n\t\t\tsyncRect(false);\n\n\t\t\tfire(\"setSize\");\n\n\t\t\tshouldSetSize = false;\n\t\t}\n\n\t\tif (fullWidCss > 0 && fullHgtCss > 0) {\n\t\t\tctx.clearRect(0, 0, can.width, can.height);\n\t\t\tfire(\"drawClear\");\n\t\t\tdrawOrder.forEach(fn => fn());\n\t\t\tfire(\"draw\");\n\t\t}\n\n\t//\tif (shouldSetSelect) {\n\t\t// TODO: update .u-select metrics (if visible)\n\t\t//\tsetStylePx(selectDiv, TOP, select.top = 0);\n\t\t//\tsetStylePx(selectDiv, LEFT, select.left = 0);\n\t\t//\tsetStylePx(selectDiv, WIDTH, select.width = 0);\n\t\t//\tsetStylePx(selectDiv, HEIGHT, select.height = 0);\n\t\t//\tshouldSetSelect = false;\n\t//\t}\n\n\t\tif (cursor.show && shouldSetCursor) {\n\t\t\tupdateCursor();\n\t\t\tshouldSetCursor = false;\n\t\t}\n\n\t//\tif (FEAT_LEGEND && legend.show && legend.live && shouldSetLegend) {}\n\n\t\tif (!ready) {\n\t\t\tready = true;\n\t\t\tself.status = 1;\n\n\t\t\tfire(\"ready\");\n\t\t}\n\n\t\tviaAutoScaleX = false;\n\n\t\tqueuedCommit = false;\n\t}\n\n\tself.redraw = (rebuildPaths, recalcAxes) => {\n\t\tshouldConvergeSize = recalcAxes || false;\n\n\t\tif (rebuildPaths !== false)\n\t\t\t_setScale(xScaleKey, scaleX.min, scaleX.max);\n\t\telse\n\t\t\tcommit();\n\t};\n\n\t// redraw() => setScale('x', scales.x.min, scales.x.max);\n\n\t// explicit, never re-ranged (is this actually true? for x and y)\n\tfunction setScale(key, opts) {\n\t\tlet sc = scales[key];\n\n\t\tif (sc.from == null) {\n\t\t\tif (dataLen == 0) {\n\t\t\t\tlet minMax = sc.range(self, opts.min, opts.max, key);\n\t\t\t\topts.min = minMax[0];\n\t\t\t\topts.max = minMax[1];\n\t\t\t}\n\n\t\t\tif (opts.min > opts.max) {\n\t\t\t\tlet _min = opts.min;\n\t\t\t\topts.min = opts.max;\n\t\t\t\topts.max = _min;\n\t\t\t}\n\n\t\t\tif (dataLen > 1 && opts.min != null && opts.max != null && opts.max - opts.min < 1e-16)\n\t\t\t\treturn;\n\n\t\t\tif (key == xScaleKey) {\n\t\t\t\tif (sc.distr == 2 && dataLen > 0) {\n\t\t\t\t\topts.min = closestIdx(opts.min, data[0]);\n\t\t\t\t\topts.max = closestIdx(opts.max, data[0]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t//\tlog(\"setScale()\", arguments);\n\n\t\t\tpendScales[key] = opts;\n\n\t\t\tshouldSetScales = true;\n\t\t\tcommit();\n\t\t}\n\t}\n\n\tself.setScale = setScale;\n\n//\tINTERACTION\n\n\tlet xCursor;\n\tlet yCursor;\n\tlet vCursor;\n\tlet hCursor;\n\n\t// starting position before cursor.move\n\tlet rawMouseLeft0;\n\tlet rawMouseTop0;\n\n\t// starting position\n\tlet mouseLeft0;\n\tlet mouseTop0;\n\n\t// current position before cursor.move\n\tlet rawMouseLeft1;\n\tlet rawMouseTop1;\n\n\t// current position\n\tlet mouseLeft1;\n\tlet mouseTop1;\n\n\tlet dragging = false;\n\n\tconst drag = cursor.drag;\n\n\tlet dragX = drag.x;\n\tlet dragY = drag.y;\n\n\tif (cursor.show) {\n\t\tif (cursor.x)\n\t\t\txCursor = placeDiv(CURSOR_X, over);\n\t\tif (cursor.y)\n\t\t\tyCursor = placeDiv(CURSOR_Y, over);\n\n\t\tif (scaleX.ori == 0) {\n\t\t\tvCursor = xCursor;\n\t\t\thCursor = yCursor;\n\t\t}\n\t\telse {\n\t\t\tvCursor = yCursor;\n\t\t\thCursor = xCursor;\n\t\t}\n\n\t\tmouseLeft1 = cursor.left;\n\t\tmouseTop1 = cursor.top;\n\t}\n\n\tconst select = self.select = assign({\n\t\tshow:   true,\n\t\tover:   true,\n\t\tleft:   0,\n\t\twidth:  0,\n\t\ttop:    0,\n\t\theight: 0,\n\t}, opts.select);\n\n\tconst selectDiv = select.show ? placeDiv(SELECT, select.over ? over : under) : null;\n\n\tfunction setSelect(opts, _fire) {\n\t\tif (select.show) {\n\t\t\tfor (let prop in opts)\n\t\t\t\tsetStylePx(selectDiv, prop, select[prop] = opts[prop]);\n\n\t\t\t_fire !== false && fire(\"setSelect\");\n\t\t}\n\t}\n\n\tself.setSelect = setSelect;\n\n\tfunction toggleDOM(i, onOff) {\n\t\tlet s = series[i];\n\t\tlet label = showLegend ? legendRows[i] : null;\n\n\t\tif (s.show)\n\t\t\tlabel && remClass(label, OFF);\n\t\telse {\n\t\t\tlabel && addClass(label, OFF);\n\t\t\tcursorPts.length > 1 && trans(cursorPts[i], -10, -10, plotWidCss, plotHgtCss);\n\t\t}\n\t}\n\n\tfunction _setScale(key, min, max) {\n\t\tsetScale(key, {min, max});\n\t}\n\n\tfunction setSeries(i, opts, pub) {\n\t//\tlog(\"setSeries()\", arguments);\n\n\t\tlet s = series[i];\n\n\t\tif (opts.focus != null)\n\t\t\tsetFocus(i);\n\n\t\tif (opts.show != null) {\n\t\t\ts.show = opts.show;\n\t\t\ttoggleDOM(i, opts.show);\n\n\t\t\t_setScale(s.scale, null, null);\n\t\t\tcommit();\n\t\t}\n\n\t\tfire(\"setSeries\", i, opts);\n\n\t\tpub && pubSync(\"setSeries\", self, i, opts);\n\t}\n\n\tself.setSeries = setSeries;\n\n\tfunction setBand(bi, opts) {\n\t\tassign(bands[bi], opts);\n\t}\n\n\tfunction addBand(opts, bi) {\n\t\topts.fill = fnOrSelf(opts.fill || null);\n\t\tbi = bi == null ? bands.length : bi;\n\t\tbands.splice(bi, 0, opts);\n\t}\n\n\tfunction delBand(bi) {\n\t\tif (bi == null)\n\t\t\tbands.length = 0;\n\t\telse\n\t\t\tbands.splice(bi, 1);\n\t}\n\n\tself.addBand = addBand;\n\tself.setBand = setBand;\n\tself.delBand = delBand;\n\n\tfunction setAlpha(i, value) {\n\t\tseries[i].alpha = value;\n\n\t\tif (cursor.show && cursorPts[i])\n\t\t\tcursorPts[i].style.opacity = value;\n\n\t\tif (showLegend && legendRows[i])\n\t\t\tlegendRows[i].style.opacity = value;\n\t}\n\n\t// y-distance\n\tlet closestDist;\n\tlet closestSeries;\n\tlet focusedSeries;\n\tconst FOCUS_TRUE  = {focus: true};\n\tconst FOCUS_FALSE = {focus: false};\n\n\tfunction setFocus(i) {\n\t\tif (i != focusedSeries) {\n\t\t//\tlog(\"setFocus()\", arguments);\n\n\t\t\tlet allFocused = i == null;\n\n\t\t\tlet _setAlpha = focus.alpha != 1;\n\n\t\t\tseries.forEach((s, i2) => {\n\t\t\t\tlet isFocused = allFocused || i2 == 0 || i2 == i;\n\t\t\t\ts._focus = allFocused ? null : isFocused;\n\t\t\t\t_setAlpha && setAlpha(i2, isFocused ? 1 : focus.alpha);\n\t\t\t});\n\n\t\t\tfocusedSeries = i;\n\t\t\t_setAlpha && commit();\n\t\t}\n\t}\n\n\tif (showLegend && cursorFocus) {\n\t\ton(mouseleave, legendEl, e => {\n\t\t\tif (cursor._lock)\n\t\t\t\treturn;\n\t\t\tsetSeries(null, FOCUS_FALSE, syncOpts.setSeries);\n\t\t\tupdateCursor();\n\t\t});\n\t}\n\n\tfunction posToVal(pos, scale) {\n\t\tlet sc = scales[scale];\n\n\t\tlet dim = plotWidCss;\n\n\t\tif (sc.ori == 1) {\n\t\t\tdim = plotHgtCss;\n\t\t\tpos = dim - pos;\n\t\t}\n\n\t\tif (sc.dir == -1)\n\t\t\tpos = dim - pos;\n\n\t\tlet _min = sc._min,\n\t\t\t_max = sc._max,\n\t\t\tpct = pos / dim;\n\n\t\tlet sv = _min + (_max - _min) * pct;\n\n\t\tlet distr = sc.distr;\n\n\t\treturn (\n\t\t\tdistr == 3 ? pow(10, sv) :\n\t\t\tdistr == 4 ? sinh(sv, sc.asinh) :\n\t\t\tsv\n\t\t);\n\t}\n\n\tfunction closestIdxFromXpos(pos) {\n\t\tlet v = posToVal(pos, xScaleKey);\n\t\treturn closestIdx(v, data[0], i0, i1);\n\t}\n\n\tself.valToIdx = val => closestIdx(val, data[0]);\n\tself.posToIdx = closestIdxFromXpos;\n\tself.posToVal = posToVal;\n\tself.valToPos = (val, scale, can) => (\n\t\tscales[scale].ori == 0 ?\n\t\tgetHPos(val, scales[scale],\n\t\t\tcan ? plotWid : plotWidCss,\n\t\t\tcan ? plotLft : 0,\n\t\t) :\n\t\tgetVPos(val, scales[scale],\n\t\t\tcan ? plotHgt : plotHgtCss,\n\t\t\tcan ? plotTop : 0,\n\t\t)\n\t);\n\n\t// defers calling expensive functions\n\tfunction batch(fn) {\n\t\tfn(self);\n\t\tcommit();\n\t}\n\n\tself.batch = batch;\n\n\t(self.setCursor = (opts, _fire) => {\n\t\tmouseLeft1 = opts.left;\n\t\tmouseTop1 = opts.top;\n\t//\tassign(cursor, opts);\n\t\tupdateCursor(null, null, _fire);\n\t});\n\n\tfunction setSelH(off, dim) {\n\t\tsetStylePx(selectDiv, LEFT,  select.left = off);\n\t\tsetStylePx(selectDiv, WIDTH, select.width = dim);\n\t}\n\n\tfunction setSelV(off, dim) {\n\t\tsetStylePx(selectDiv, TOP,    select.top = off);\n\t\tsetStylePx(selectDiv, HEIGHT, select.height = dim);\n\t}\n\n\tlet setSelX = scaleX.ori == 0 ? setSelH : setSelV;\n\tlet setSelY = scaleX.ori == 1 ? setSelH : setSelV;\n\n\tfunction syncLegend() {\n\t\tif (showLegend && legend.live) {\n\t\t\tfor (let i = 0; i < series.length; i++) {\n\t\t\t\tif (i == 0 && multiValLegend)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tlet vals = legend.values[i];\n\n\t\t\t\tlet j = 0;\n\n\t\t\t\tfor (let k in vals)\n\t\t\t\t\tlegendCells[i][j++].firstChild.nodeValue = vals[k];\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction setLegend(opts, _fire) {\n\t\tif (opts != null) {\n\t\t\tlet idx = opts.idx;\n\n\t\t\tlegend.idx = idx;\n\t\t\tseries.forEach((s, sidx) => {\n\t\t\t\t(sidx > 0 || !multiValLegend) && setLegendValues(sidx, idx);\n\t\t\t});\n\t\t}\n\n\t\tif (showLegend && legend.live)\n\t\t\tsyncLegend();\n\n\t\tshouldSetLegend = false;\n\n\t\t_fire !== false && fire(\"setLegend\");\n\t}\n\n\tself.setLegend = setLegend;\n\n\tfunction setLegendValues(sidx, idx) {\n\t\tlet val;\n\n\t\tif (idx == null)\n\t\t\tval = NULL_LEGEND_VALUES;\n\t\telse {\n\t\t\tlet s = series[sidx];\n\t\t\tlet src = sidx == 0 && xScaleDistr == 2 ? data0 : data[sidx];\n\t\t\tval = multiValLegend ? s.values(self, sidx, idx) : {_: s.value(self, src[idx], sidx, idx)};\n\t\t}\n\n\t\tlegend.values[sidx] = val;\n\t}\n\n\tfunction updateCursor(ts, src, _fire) {\n\t//\tts == null && log(\"updateCursor()\", arguments);\n\n\t\trawMouseLeft1 = mouseLeft1;\n\t\trawMouseTop1 = mouseTop1;\n\n\t\t[mouseLeft1, mouseTop1] = cursor.move(self, mouseLeft1, mouseTop1);\n\n\t\tif (cursor.show) {\n\t\t\tvCursor && trans(vCursor, round(mouseLeft1), 0, plotWidCss, plotHgtCss);\n\t\t\thCursor && trans(hCursor, 0, round(mouseTop1), plotWidCss, plotHgtCss);\n\t\t}\n\n\t\tlet idx;\n\t\tlet idxChanged = false;\n\n\t\t// when zooming to an x scale range between datapoints the binary search\n\t\t// for nearest min/max indices results in this condition. cheap hack :D\n\t\tlet noDataInRange = i0 > i1;\n\n\t\tclosestDist = inf;\n\n\t\t// TODO: extract\n\t\tlet xDim = scaleX.ori == 0 ? plotWidCss : plotHgtCss;\n\t\tlet yDim = scaleX.ori == 1 ? plotWidCss : plotHgtCss;\n\n\t\t// if cursor hidden, hide points & clear legend vals\n\t\tif (mouseLeft1 < 0 || dataLen == 0 || noDataInRange) {\n\t\t\tidx = null;\n\n\t\t\tfor (let i = 0; i < series.length; i++) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tcursorPts.length > 1 && trans(cursorPts[i], -10, -10, plotWidCss, plotHgtCss);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (cursorFocus)\n\t\t\t\tsetSeries(null, FOCUS_TRUE, syncOpts.setSeries);\n\n\t\t\tif (legend.live) {\n\t\t\t\tidxChanged = true;\n\n\t\t\t\tfor (let i = 0; i < series.length; i++)\n\t\t\t\t\tlegend.values[i] = NULL_LEGEND_VALUES;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t//\tlet pctY = 1 - (y / rect.height);\n\n\t\t\tlet mouseXPos = scaleX.ori == 0 ? mouseLeft1 : mouseTop1;\n\n\t\t\tlet valAtPosX = posToVal(mouseXPos, xScaleKey);\n\n\t\t\tidx = closestIdx(valAtPosX, data[0], i0, i1);\n\n\t\t\tlet xPos = incrRoundUp(valToPosX(data[0][idx], scaleX, xDim, 0), 0.5);\n\n\t\t\tfor (let i = 0; i < series.length; i++) {\n\t\t\t\tlet s = series[i];\n\n\t\t\t\tlet idx2  = cursor.dataIdx(self, i, idx, valAtPosX);\n\t\t\t\tlet xPos2 = idx2 == idx ? xPos : incrRoundUp(valToPosX(data[0][idx2], scaleX, xDim, 0), 0.5);\n\n\t\t\t\tif (i > 0 && s.show) {\n\t\t\t\t\tlet valAtIdx = data[i][idx2];\n\n\t\t\t\t\tlet yPos = valAtIdx == null ? -10 : incrRoundUp(valToPosY(valAtIdx, scales[s.scale], yDim, 0), 0.5);\n\n\t\t\t\t\tif (yPos > 0) {\n\t\t\t\t\t\tlet dist = abs(yPos - mouseTop1);\n\n\t\t\t\t\t\tif (dist <= closestDist) {\n\t\t\t\t\t\t\tclosestDist = dist;\n\t\t\t\t\t\t\tclosestSeries = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tlet hPos, vPos;\n\n\t\t\t\t\tif (scaleX.ori == 0) {\n\t\t\t\t\t\thPos = xPos2;\n\t\t\t\t\t\tvPos = yPos;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\thPos = yPos;\n\t\t\t\t\t\tvPos = xPos2;\n\t\t\t\t\t}\n\n\t\t\t\t\tcursorPts.length > 1 && trans(cursorPts[i], hPos, vPos, plotWidCss, plotHgtCss);\n\t\t\t\t}\n\n\t\t\t\tif (legend.live) {\n\t\t\t\t\tif ((idx2 == cursor.idx && !shouldSetLegend) || i == 0 && multiValLegend)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tidxChanged = true;\n\n\t\t\t\t\tsetLegendValues(i, idx2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (idxChanged) {\n\t\t\tlegend.idx = idx;\n\t\t\tsetLegend();\n\t\t}\n\n\t\t// nit: cursor.drag.setSelect is assumed always true\n\t\tif (select.show && dragging) {\n\t\t\tif (src != null) {\n\t\t\t\tlet [xKey, yKey] = syncOpts.scales;\n\t\t\t\tlet [matchXKeys, matchYKeys] = syncOpts.match;\n\t\t\t\tlet [xKeySrc, yKeySrc] = src.cursor.sync.scales;\n\n\t\t\t\t// match the dragX/dragY implicitness/explicitness of src\n\t\t\t\tlet sdrag = src.cursor.drag;\n\t\t\t\tdragX = sdrag._x;\n\t\t\t\tdragY = sdrag._y;\n\n\t\t\t\tlet { left, top, width, height } = src.select;\n\n\t\t\t\tlet sori = src.scales[xKey].ori;\n\t\t\t\tlet sPosToVal = src.posToVal;\n\n\t\t\t\tlet sOff, sDim, sc, a, b;\n\n\t\t\t\tlet matchingX = xKey != null && matchXKeys(xKey, xKeySrc);\n\t\t\t\tlet matchingY = yKey != null && matchYKeys(yKey, yKeySrc);\n\n\t\t\t\tif (matchingX) {\n\t\t\t\t\tif (sori == 0) {\n\t\t\t\t\t\tsOff = left;\n\t\t\t\t\t\tsDim = width;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tsOff = top;\n\t\t\t\t\t\tsDim = height;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (dragX) {\n\t\t\t\t\t\tsc = scales[xKey];\n\n\t\t\t\t\t\ta = valToPosX(sPosToVal(sOff, xKeySrc),        sc, xDim, 0);\n\t\t\t\t\t\tb = valToPosX(sPosToVal(sOff + sDim, xKeySrc), sc, xDim, 0);\n\n\t\t\t\t\t\tsetSelX(min(a,b), abs(b-a));\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tsetSelX(0, xDim);\n\n\t\t\t\t\tif (!matchingY)\n\t\t\t\t\t\tsetSelY(0, yDim);\n\t\t\t\t}\n\n\t\t\t\tif (matchingY) {\n\t\t\t\t\tif (sori == 1) {\n\t\t\t\t\t\tsOff = left;\n\t\t\t\t\t\tsDim = width;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tsOff = top;\n\t\t\t\t\t\tsDim = height;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (dragY) {\n\t\t\t\t\t\tsc = scales[yKey];\n\n\t\t\t\t\t\ta = valToPosY(sPosToVal(sOff, yKeySrc),        sc, yDim, 0);\n\t\t\t\t\t\tb = valToPosY(sPosToVal(sOff + sDim, yKeySrc), sc, yDim, 0);\n\n\t\t\t\t\t\tsetSelY(min(a,b), abs(b-a));\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tsetSelY(0, yDim);\n\n\t\t\t\t\tif (!matchingX)\n\t\t\t\t\t\tsetSelX(0, xDim);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlet rawDX = abs(rawMouseLeft1 - rawMouseLeft0);\n\t\t\t\tlet rawDY = abs(rawMouseTop1 - rawMouseTop0);\n\n\t\t\t\tif (scaleX.ori == 1) {\n\t\t\t\t\tlet _rawDX = rawDX;\n\t\t\t\t\trawDX = rawDY;\n\t\t\t\t\trawDY = _rawDX;\n\t\t\t\t}\n\n\t\t\t\tdragX = drag.x && rawDX >= drag.dist;\n\t\t\t\tdragY = drag.y && rawDY >= drag.dist;\n\n\t\t\t\tlet uni = drag.uni;\n\n\t\t\t\tif (uni != null) {\n\t\t\t\t\t// only calc drag status if they pass the dist thresh\n\t\t\t\t\tif (dragX && dragY) {\n\t\t\t\t\t\tdragX = rawDX >= uni;\n\t\t\t\t\t\tdragY = rawDY >= uni;\n\n\t\t\t\t\t\t// force unidirectionality when both are under uni limit\n\t\t\t\t\t\tif (!dragX && !dragY) {\n\t\t\t\t\t\t\tif (rawDY > rawDX)\n\t\t\t\t\t\t\t\tdragY = true;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tdragX = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (drag.x && drag.y && (dragX || dragY))\n\t\t\t\t\t// if omni with no uni then both dragX / dragY should be true if either is true\n\t\t\t\t\tdragX = dragY = true;\n\n\t\t\t\tlet p0, p1;\n\n\t\t\t\tif (dragX) {\n\t\t\t\t\tif (scaleX.ori == 0) {\n\t\t\t\t\t\tp0 = mouseLeft0;\n\t\t\t\t\t\tp1 = mouseLeft1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tp0 = mouseTop0;\n\t\t\t\t\t\tp1 = mouseTop1;\n\t\t\t\t\t}\n\n\t\t\t\t\tsetSelX(min(p0, p1), abs(p1 - p0));\n\n\t\t\t\t\tif (!dragY)\n\t\t\t\t\t\tsetSelY(0, yDim);\n\t\t\t\t}\n\n\t\t\t\tif (dragY) {\n\t\t\t\t\tif (scaleX.ori == 1) {\n\t\t\t\t\t\tp0 = mouseLeft0;\n\t\t\t\t\t\tp1 = mouseLeft1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tp0 = mouseTop0;\n\t\t\t\t\t\tp1 = mouseTop1;\n\t\t\t\t\t}\n\n\t\t\t\t\tsetSelY(min(p0, p1), abs(p1 - p0));\n\n\t\t\t\t\tif (!dragX)\n\t\t\t\t\t\tsetSelX(0, xDim);\n\t\t\t\t}\n\n\t\t\t\t// the drag didn't pass the dist requirement\n\t\t\t\tif (!dragX && !dragY) {\n\t\t\t\t\tsetSelX(0, 0);\n\t\t\t\t\tsetSelY(0, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcursor.idx = idx;\n\t\tcursor.left = mouseLeft1;\n\t\tcursor.top = mouseTop1;\n\t\tdrag._x = dragX;\n\t\tdrag._y = dragY;\n\n\t\t// if ts is present, means we're implicitly syncing own cursor\n\t\tif (ts != null) {\n\t\t\tif (syncKey != null) {\n\t\t\t\tlet [xSyncKey, ySyncKey] = syncOpts.scales;\n\n\t\t\t\tsyncOpts.values[0] = xSyncKey != null ? posToVal(scaleX.ori == 0 ? mouseLeft1 : mouseTop1, xSyncKey) : null;\n\t\t\t\tsyncOpts.values[1] = ySyncKey != null ? posToVal(scaleX.ori == 1 ? mouseLeft1 : mouseTop1, ySyncKey) : null;\n\t\t\t}\n\n\t\t\t// this is not technically a \"mousemove\" event, since it's debounced, rename to setCursor?\n\t\t\t// since this is internal, we can tweak it later\n\t\t\tpubSync(mousemove, self, mouseLeft1, mouseTop1, plotWidCss, plotHgtCss, idx);\n\n\t\t\tif (cursorFocus) {\n\t\t\t\tlet o = syncOpts.setSeries;\n\t\t\t\tlet p = focus.prox;\n\n\t\t\t\tif (focusedSeries == null) {\n\t\t\t\t\tif (closestDist <= p)\n\t\t\t\t\t\tsetSeries(closestSeries, FOCUS_TRUE, o);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (closestDist > p)\n\t\t\t\t\t\tsetSeries(null, FOCUS_TRUE, o);\n\t\t\t\t\telse if (closestSeries != focusedSeries)\n\t\t\t\t\t\tsetSeries(closestSeries, FOCUS_TRUE, o);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tready && _fire !== false && fire(\"setCursor\");\n\t}\n\n\tlet rect = null;\n\n\tfunction syncRect(defer) {\n\t\tif (defer === true)\n\t\t\trect = null;\n\t\telse {\n\t\t\trect = over.getBoundingClientRect();\n\t\t\tfire(\"syncRect\", rect);\n\t\t}\n\t}\n\n\tfunction mouseMove(e, src, _l, _t, _w, _h, _i) {\n\t\tif (cursor._lock)\n\t\t\treturn;\n\n\t\tcacheMouse(e, src, _l, _t, _w, _h, _i, false, e != null);\n\n\t\tif (e != null)\n\t\t\tupdateCursor(1);\n\t\telse\n\t\t\tupdateCursor(null, src);\n\t}\n\n\tfunction cacheMouse(e, src, _l, _t, _w, _h, _i, initial, snap) {\n\t\tif (rect == null)\n\t\t\tsyncRect(false);\n\n\t\tif (e != null) {\n\t\t\t_l = e.clientX - rect.left;\n\t\t\t_t = e.clientY - rect.top;\n\t\t}\n\t\telse {\n\t\t\tif (_l < 0 || _t < 0) {\n\t\t\t\tmouseLeft1 = -10;\n\t\t\t\tmouseTop1 = -10;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet [xKey, yKey] = syncOpts.scales;\n\n\t\t\tlet syncOptsSrc = src.cursor.sync;\n\t\t\tlet [xValSrc, yValSrc] = syncOptsSrc.values;\n\t\t\tlet [xKeySrc, yKeySrc] = syncOptsSrc.scales;\n\t\t\tlet [matchXKeys, matchYKeys] = syncOpts.match;\n\n\t\t\tlet rotSrc = src.scales[xKeySrc].ori == 1;\n\n\t\t\tlet xDim = scaleX.ori == 0 ? plotWidCss : plotHgtCss,\n\t\t\t\tyDim = scaleX.ori == 1 ? plotWidCss : plotHgtCss,\n\t\t\t\t_xDim = rotSrc ? _h : _w,\n\t\t\t\t_yDim = rotSrc ? _w : _h,\n\t\t\t\t_xPos = rotSrc ? _t : _l,\n\t\t\t\t_yPos = rotSrc ? _l : _t;\n\n\t\t\tif (xKeySrc != null)\n\t\t\t\t_l = matchXKeys(xKey, xKeySrc) ? getPos(xValSrc, scales[xKey], xDim, 0) : -10;\n\t\t\telse\n\t\t\t\t_l = xDim * (_xPos/_xDim);\n\n\t\t\tif (yKeySrc != null)\n\t\t\t\t_t = matchYKeys(yKey, yKeySrc) ? getPos(yValSrc, scales[yKey], yDim, 0) : -10;\n\t\t\telse\n\t\t\t\t_t = yDim * (_yPos/_yDim);\n\n\t\t\tif (scaleX.ori == 1) {\n\t\t\t\tlet __l = _l;\n\t\t\t\t_l = _t;\n\t\t\t\t_t = __l;\n\t\t\t}\n\t\t}\n\n\t\tif (snap) {\n\t\t\tif (_l <= 1 || _l >= plotWidCss - 1)\n\t\t\t\t_l = incrRound(_l, plotWidCss);\n\n\t\t\tif (_t <= 1 || _t >= plotHgtCss - 1)\n\t\t\t\t_t = incrRound(_t, plotHgtCss);\n\t\t}\n\n\t\tif (initial) {\n\t\t\trawMouseLeft0 = _l;\n\t\t\trawMouseTop0 = _t;\n\n\t\t\t[mouseLeft0, mouseTop0] = cursor.move(self, _l, _t);\n\t\t}\n\t\telse {\n\t\t\tmouseLeft1 = _l;\n\t\t\tmouseTop1 = _t;\n\t\t}\n\t}\n\n\tfunction hideSelect() {\n\t\tsetSelect({\n\t\t\twidth: 0,\n\t\t\theight: 0,\n\t\t}, false);\n\t}\n\n\tfunction mouseDown(e, src, _l, _t, _w, _h, _i) {\n\t\tdragging = true;\n\t\tdragX = dragY = drag._x = drag._y = false;\n\n\t\tcacheMouse(e, src, _l, _t, _w, _h, _i, true, false);\n\n\t\tif (e != null) {\n\t\t\tonMouse(mouseup, doc, mouseUp);\n\t\t\tpubSync(mousedown, self, mouseLeft0, mouseTop0, plotWidCss, plotHgtCss, null);\n\t\t}\n\t}\n\n\tfunction mouseUp(e, src, _l, _t, _w, _h, _i) {\n\t\tdragging = drag._x = drag._y = false;\n\n\t\tcacheMouse(e, src, _l, _t, _w, _h, _i, false, true);\n\n\t\tlet { left, top, width, height } = select;\n\n\t\tlet hasSelect = width > 0 || height > 0;\n\n\t\thasSelect && setSelect(select);\n\n\t\tif (drag.setScale && hasSelect) {\n\t\t//\tif (syncKey != null) {\n\t\t//\t\tdragX = drag.x;\n\t\t//\t\tdragY = drag.y;\n\t\t//\t}\n\n\t\t\tlet xOff = left,\n\t\t\t\txDim = width,\n\t\t\t\tyOff = top,\n\t\t\t\tyDim = height;\n\n\t\t\tif (scaleX.ori == 1) {\n\t\t\t\txOff = top,\n\t\t\t\txDim = height,\n\t\t\t\tyOff = left,\n\t\t\t\tyDim = width;\n\t\t\t}\n\n\t\t\tif (dragX) {\n\t\t\t\t_setScale(xScaleKey,\n\t\t\t\t\tposToVal(xOff, xScaleKey),\n\t\t\t\t\tposToVal(xOff + xDim, xScaleKey)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (dragY) {\n\t\t\t\tfor (let k in scales) {\n\t\t\t\t\tlet sc = scales[k];\n\n\t\t\t\t\tif (k != xScaleKey && sc.from == null && sc.min != inf) {\n\t\t\t\t\t\t_setScale(k,\n\t\t\t\t\t\t\tposToVal(yOff + yDim, k),\n\t\t\t\t\t\t\tposToVal(yOff, k)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\thideSelect();\n\t\t}\n\t\telse if (cursor.lock) {\n\t\t\tcursor._lock = !cursor._lock;\n\n\t\t\tif (!cursor._lock)\n\t\t\t\tupdateCursor();\n\t\t}\n\n\t\tif (e != null) {\n\t\t\toffMouse(mouseup, doc);\n\t\t\tpubSync(mouseup, self, mouseLeft1, mouseTop1, plotWidCss, plotHgtCss, null);\n\t\t}\n\t}\n\n\tfunction mouseLeave(e, src, _l, _t, _w, _h, _i) {\n\t\tif (!cursor._lock) {\n\t\t\tlet _dragging = dragging;\n\n\t\t\tif (dragging) {\n\t\t\t\t// handle case when mousemove aren't fired all the way to edges by browser\n\t\t\t\tlet snapH = true;\n\t\t\t\tlet snapV = true;\n\t\t\t\tlet snapProx = 10;\n\n\t\t\t\tlet dragH, dragV;\n\n\t\t\t\tif (scaleX.ori == 0) {\n\t\t\t\t\tdragH = dragX;\n\t\t\t\t\tdragV = dragY;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdragH = dragY;\n\t\t\t\t\tdragV = dragX;\n\t\t\t\t}\n\n\t\t\t\tif (dragH && dragV) {\n\t\t\t\t\t// maybe omni corner snap\n\t\t\t\t\tsnapH = mouseLeft1 <= snapProx || mouseLeft1 >= plotWidCss - snapProx;\n\t\t\t\t\tsnapV = mouseTop1  <= snapProx || mouseTop1  >= plotHgtCss - snapProx;\n\t\t\t\t}\n\n\t\t\t\tif (dragH && snapH)\n\t\t\t\t\tmouseLeft1 = mouseLeft1 < mouseLeft0 ? 0 : plotWidCss;\n\n\t\t\t\tif (dragV && snapV)\n\t\t\t\t\tmouseTop1 = mouseTop1 < mouseTop0 ? 0 : plotHgtCss;\n\n\t\t\t\tupdateCursor(1);\n\n\t\t\t\tdragging = false;\n\t\t\t}\n\n\t\t\tmouseLeft1 = -10;\n\t\t\tmouseTop1 = -10;\n\n\t\t\t// passing a non-null timestamp to force sync/mousemove event\n\t\t\tupdateCursor(1);\n\n\t\t\tif (_dragging)\n\t\t\t\tdragging = _dragging;\n\t\t}\n\t}\n\n\tfunction dblClick(e, src, _l, _t, _w, _h, _i) {\n\t\tautoScaleX();\n\n\t\thideSelect();\n\n\t\tif (e != null)\n\t\t\tpubSync(dblclick, self, mouseLeft1, mouseTop1, plotWidCss, plotHgtCss, null);\n\t}\n\n\t// internal pub/sub\n\tconst events = {};\n\n\tevents.mousedown = mouseDown;\n\tevents.mousemove = mouseMove;\n\tevents.mouseup = mouseUp;\n\tevents.dblclick = dblClick;\n\tevents[\"setSeries\"] = (e, src, idx, opts) => {\n\t\tsetSeries(idx, opts);\n\t};\n\n\tif (cursor.show) {\n\t\tonMouse(mousedown,  over, mouseDown);\n\t\tonMouse(mousemove,  over, mouseMove);\n\t\tonMouse(mouseenter, over, syncRect);\n\t\tonMouse(mouseleave, over, mouseLeave);\n\n\t\tonMouse(dblclick, over, dblClick);\n\n\t\tcursorPlots.add(self);\n\n\t\tself.syncRect = syncRect;\n\t}\n\n\t// external on/off\n\tconst hooks = self.hooks = opts.hooks || {};\n\n\tfunction fire(evName, a1, a2) {\n\t\tif (evName in hooks) {\n\t\t\thooks[evName].forEach(fn => {\n\t\t\t\tfn.call(null, self, a1, a2);\n\t\t\t});\n\t\t}\n\t}\n\n\t(opts.plugins || []).forEach(p => {\n\t\tfor (let evName in p.hooks)\n\t\t\thooks[evName] = (hooks[evName] || []).concat(p.hooks[evName]);\n\t});\n\n\tconst syncOpts = assign({\n\t\tkey: null,\n\t\tsetSeries: false,\n\t\tfilters: {\n\t\t\tpub: retTrue,\n\t\t\tsub: retTrue,\n\t\t},\n\t\tscales: [xScaleKey, series[1] ? series[1].scale : null],\n\t\tmatch: [retEq, retEq],\n\t\tvalues: [null, null],\n\t}, cursor.sync);\n\n\t(cursor.sync = syncOpts);\n\n\tconst syncKey = syncOpts.key;\n\n\tconst sync = _sync(syncKey);\n\n\tfunction pubSync(type, src, x, y, w, h, i) {\n\t\tif (syncOpts.filters.pub(type, src, x, y, w, h, i))\n\t\t\tsync.pub(type, src, x, y, w, h, i);\n\t}\n\n\tsync.sub(self);\n\n\tfunction pub(type, src, x, y, w, h, i) {\n\t\tif (syncOpts.filters.sub(type, src, x, y, w, h, i))\n\t\t\tevents[type](null, src, x, y, w, h, i);\n\t}\n\n\t(self.pub = pub);\n\n\tfunction destroy() {\n\t\tsync.unsub(self);\n\t\tcursorPlots.delete(self);\n\t\tmouseListeners.clear();\n\t\troot.remove();\n\t\tfire(\"destroy\");\n\t}\n\n\tself.destroy = destroy;\n\n\tfunction _init() {\n\t\tfire(\"init\", opts, data);\n\n\t\tsetData(data || opts.data, false);\n\n\t\tif (pendScales[xScaleKey])\n\t\t\tsetScale(xScaleKey, pendScales[xScaleKey]);\n\t\telse\n\t\t\tautoScaleX();\n\n\t\t_setSize(opts.width, opts.height);\n\n\t\tupdateCursor();\n\n\t\tsetSelect(select, false);\n\t}\n\n\tseries.forEach(initSeries);\n\n\taxes.forEach(initAxis);\n\n\tif (then) {\n\t\tif (then instanceof HTMLElement) {\n\t\t\tthen.appendChild(root);\n\t\t\t_init();\n\t\t}\n\t\telse\n\t\t\tthen(self, _init);\n\t}\n\telse\n\t\t_init();\n\n\treturn self;\n}\n\nuPlot.assign = assign;\nuPlot.fmtNum = fmtNum;\nuPlot.rangeNum = rangeNum;\nuPlot.rangeLog = rangeLog;\nuPlot.rangeAsinh = rangeAsinh;\nuPlot.orient   = orient;\n\n{\n\tuPlot.join = join;\n}\n\n{\n\tuPlot.fmtDate = fmtDate;\n\tuPlot.tzDate  = tzDate;\n}\n\n{\n\tuPlot.sync = _sync;\n}\n\n{\n\tuPlot.addGap = addGap;\n\tuPlot.clipGaps = clipGaps;\n\n\tlet paths = uPlot.paths = {};\n\n\t(paths.linear  = linear);\n\t(paths.stepped = stepped);\n\t(paths.bars    = bars);\n\t(paths.spline  = monotoneCubic);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (uPlot);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjg4OTAuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0Msc0JBQXNCO0FBQzFEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSx3QkFBd0IsY0FBYztBQUN0QztBQUNBOztBQUVBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLGlCQUFpQjtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCO0FBQ3hCLHdCQUF3QjtBQUN4Qix3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQSx1Q0FBdUMscUJBQXFCO0FBQzVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGlCQUFpQixnQkFBZ0I7QUFDakM7O0FBRUEsa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBOztBQUVBLG1CQUFtQixlQUFlO0FBQ2xDOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQixlQUFlO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEIsd0JBQXdCLGNBQWM7O0FBRXRDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzQkFBc0IsMENBQTBDO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFlBQVksVUFBVSxJQUFJOztBQUUxQjtBQUNBLDBCQUEwQjs7QUFFMUI7QUFDQTs7QUFFQSxrQkFBa0Isa0JBQWtCO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGFBQWE7QUFDOUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGtCQUFrQixLQUFLO0FBQ3ZCO0FBQ0Esa0JBQWtCLEVBQUUsRUFBRSxFQUFFO0FBQ3hCO0FBQ0EsMEJBQTBCLEdBQUc7O0FBRTdCLGtCQUFrQixHQUFHO0FBQ3JCLGtCQUFrQixFQUFFLEVBQUUsR0FBRztBQUN6QjtBQUNBO0FBQ0EsbUJBQW1CLEdBQUc7O0FBRXRCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLElBQUk7QUFDdEI7QUFDQSxrQkFBa0IsRUFBRTtBQUNwQjtBQUNBO0FBQ0Esd0JBQXdCLElBQUk7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLEtBQUssRUFBRSxHQUFHLEVBQUUsS0FBSyxFQUFFLEVBQUUsSUFBSSxHQUFHOztBQUV2RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsU0FBUyxTQUFTOztBQUV6QztBQUNBO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsMEJBQTBCLGlCQUFpQjtBQUMzQyw4Q0FBOEM7O0FBRTlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU8sY0FBYztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGtCQUFrQixpQkFBaUI7QUFDbkM7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEI7QUFDNUIsNEJBQTRCO0FBQzVCLDRCQUE0QjtBQUM1Qiw0QkFBNEI7QUFDNUIsZ0NBQWdDO0FBQ2hDLGdDQUFnQztBQUNoQyxrREFBa0Q7QUFDbEQsa0RBQWtEO0FBQ2xELCtEQUErRCxvREFBb0QsK0RBQStEOztBQUVsTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQW1CO0FBQ25COztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3Q0FBd0Msd0JBQXdCO0FBQ2hFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLG1CQUFtQjtBQUNuQjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEseUNBQXlDLHdCQUF3QjtBQUNqRTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxrQkFBa0I7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQjs7QUFFbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5Q0FBeUMsd0JBQXdCO0FBQ2pFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUNBQXlDLHdCQUF3QjtBQUNqRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsV0FBVztBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFdBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLFdBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlCQUFpQixrQkFBa0I7QUFDbkM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EscUNBQXFDOztBQUVyQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7O0FBRTVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWU7QUFDZixlQUFlOztBQUVmO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLDJCQUEyQixjQUFjO0FBQ3pDLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLGFBQWE7QUFDdEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLHdDQUF3Qzs7QUFFeEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDLGlCQUFpQixXQUFXO0FBQ2pFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxVQUFVLDRCQUE0QjtBQUN0QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsUUFBUSxVQUFVLFVBQVU7O0FBRTVCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsbUJBQW1CO0FBQ3RDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSwyQkFBMkI7O0FBRXJDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsUUFBUSwyQkFBMkI7O0FBRW5DOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLEtBQUssRUFBQyIsInNvdXJjZXMiOlsiZmlsZTovLy9Vc2Vycy93YXRlcm1lbG9uL1Byb2plY3RzL0F4aW9tL2NvZGUvYXhpb21ocS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL3VwbG90L2Rpc3QvdVBsb3QuZXNtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuKiBDb3B5cmlnaHQgKGMpIDIwMjEsIExlb24gU29yb2tpblxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLiAoTUlUIExpY2Vuc2VkKVxuKlxuKiB1UGxvdC5qcyAozrxQbG90KVxuKiBBIHNtYWxsLCBmYXN0IGNoYXJ0IGZvciB0aW1lIHNlcmllcywgbGluZXMsIGFyZWFzLCBvaGxjICYgYmFyc1xuKiBodHRwczovL2dpdGh1Yi5jb20vbGVlb25peWEvdVBsb3QgKHYxLjYuMTIpXG4qL1xuXG5jb25zdCBGRUFUX1RJTUUgICAgICAgICAgPSB0cnVlO1xuXG4vLyBiaW5hcnkgc2VhcmNoIGZvciBpbmRleCBvZiBjbG9zZXN0IHZhbHVlXG5mdW5jdGlvbiBjbG9zZXN0SWR4KG51bSwgYXJyLCBsbywgaGkpIHtcblx0bGV0IG1pZDtcblx0bG8gPSBsbyB8fCAwO1xuXHRoaSA9IGhpIHx8IGFyci5sZW5ndGggLSAxO1xuXHRsZXQgYml0d2lzZSA9IGhpIDw9IDIxNDc0ODM2NDc7XG5cblx0d2hpbGUgKGhpIC0gbG8gPiAxKSB7XG5cdFx0bWlkID0gYml0d2lzZSA/IChsbyArIGhpKSA+PiAxIDogZmxvb3IoKGxvICsgaGkpIC8gMik7XG5cblx0XHRpZiAoYXJyW21pZF0gPCBudW0pXG5cdFx0XHRsbyA9IG1pZDtcblx0XHRlbHNlXG5cdFx0XHRoaSA9IG1pZDtcblx0fVxuXG5cdGlmIChudW0gLSBhcnJbbG9dIDw9IGFycltoaV0gLSBudW0pXG5cdFx0cmV0dXJuIGxvO1xuXG5cdHJldHVybiBoaTtcbn1cblxuZnVuY3Rpb24gbm9uTnVsbElkeChkYXRhLCBfaTAsIF9pMSwgZGlyKSB7XG5cdGZvciAobGV0IGkgPSBkaXIgPT0gMSA/IF9pMCA6IF9pMTsgaSA+PSBfaTAgJiYgaSA8PSBfaTE7IGkgKz0gZGlyKSB7XG5cdFx0aWYgKGRhdGFbaV0gIT0gbnVsbClcblx0XHRcdHJldHVybiBpO1xuXHR9XG5cblx0cmV0dXJuIC0xO1xufVxuXG5mdW5jdGlvbiBnZXRNaW5NYXgoZGF0YSwgX2kwLCBfaTEsIHNvcnRlZCkge1xuLy9cdGNvbnNvbGUubG9nKFwiZ2V0TWluTWF4KClcIik7XG5cblx0bGV0IF9taW4gPSBpbmY7XG5cdGxldCBfbWF4ID0gLWluZjtcblxuXHRpZiAoc29ydGVkID09IDEpIHtcblx0XHRfbWluID0gZGF0YVtfaTBdO1xuXHRcdF9tYXggPSBkYXRhW19pMV07XG5cdH1cblx0ZWxzZSBpZiAoc29ydGVkID09IC0xKSB7XG5cdFx0X21pbiA9IGRhdGFbX2kxXTtcblx0XHRfbWF4ID0gZGF0YVtfaTBdO1xuXHR9XG5cdGVsc2Uge1xuXHRcdGZvciAobGV0IGkgPSBfaTA7IGkgPD0gX2kxOyBpKyspIHtcblx0XHRcdGlmIChkYXRhW2ldICE9IG51bGwpIHtcblx0XHRcdFx0X21pbiA9IG1pbihfbWluLCBkYXRhW2ldKTtcblx0XHRcdFx0X21heCA9IG1heChfbWF4LCBkYXRhW2ldKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gW19taW4sIF9tYXhdO1xufVxuXG5mdW5jdGlvbiBnZXRNaW5NYXhMb2coZGF0YSwgX2kwLCBfaTEpIHtcbi8vXHRjb25zb2xlLmxvZyhcImdldE1pbk1heCgpXCIpO1xuXG5cdGxldCBfbWluID0gaW5mO1xuXHRsZXQgX21heCA9IC1pbmY7XG5cblx0Zm9yIChsZXQgaSA9IF9pMDsgaSA8PSBfaTE7IGkrKykge1xuXHRcdGlmIChkYXRhW2ldID4gMCkge1xuXHRcdFx0X21pbiA9IG1pbihfbWluLCBkYXRhW2ldKTtcblx0XHRcdF9tYXggPSBtYXgoX21heCwgZGF0YVtpXSk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIFtcblx0XHRfbWluID09ICBpbmYgPyAgMSA6IF9taW4sXG5cdFx0X21heCA9PSAtaW5mID8gMTAgOiBfbWF4LFxuXHRdO1xufVxuXG5jb25zdCBfZml4ZWRUdXBsZSA9IFswLCAwXTtcblxuZnVuY3Rpb24gZml4SW5jcihtaW5JbmNyLCBtYXhJbmNyLCBtaW5FeHAsIG1heEV4cCkge1xuXHRfZml4ZWRUdXBsZVswXSA9IG1pbkV4cCA8IDAgPyByb3VuZERlYyhtaW5JbmNyLCAtbWluRXhwKSA6IG1pbkluY3I7XG5cdF9maXhlZFR1cGxlWzFdID0gbWF4RXhwIDwgMCA/IHJvdW5kRGVjKG1heEluY3IsIC1tYXhFeHApIDogbWF4SW5jcjtcblx0cmV0dXJuIF9maXhlZFR1cGxlO1xufVxuXG5mdW5jdGlvbiByYW5nZUxvZyhtaW4sIG1heCwgYmFzZSwgZnVsbE1hZ3MpIHtcblxuXHRsZXQgbG9nRm4gPSBiYXNlID09IDEwID8gbG9nMTAgOiBsb2cyO1xuXG5cdGlmIChtaW4gPT0gbWF4KSB7XG5cdFx0bWluIC89IGJhc2U7XG5cdFx0bWF4ICo9IGJhc2U7XG5cdH1cblxuXHRsZXQgbWluRXhwLCBtYXhFeHAsIG1pbk1heEluY3JzO1xuXG5cdGlmIChmdWxsTWFncykge1xuXHRcdG1pbkV4cCA9IGZsb29yKGxvZ0ZuKG1pbikpO1xuXHRcdG1heEV4cCA9ICBjZWlsKGxvZ0ZuKG1heCkpO1xuXG5cdFx0bWluTWF4SW5jcnMgPSBmaXhJbmNyKHBvdyhiYXNlLCBtaW5FeHApLCBwb3coYmFzZSwgbWF4RXhwKSwgbWluRXhwLCBtYXhFeHApO1xuXG5cdFx0bWluID0gbWluTWF4SW5jcnNbMF07XG5cdFx0bWF4ID0gbWluTWF4SW5jcnNbMV07XG5cdH1cblx0ZWxzZSB7XG5cdFx0bWluRXhwID0gZmxvb3IobG9nRm4oYWJzKG1pbikpKTtcblx0XHRtYXhFeHAgPSBmbG9vcihsb2dGbihhYnMobWF4KSkpO1xuXG5cdFx0bWluTWF4SW5jcnMgPSBmaXhJbmNyKHBvdyhiYXNlLCBtaW5FeHApLCBwb3coYmFzZSwgbWF4RXhwKSwgbWluRXhwLCBtYXhFeHApO1xuXG5cdFx0bWluID0gaW5jclJvdW5kRG4obWluLCBtaW5NYXhJbmNyc1swXSk7XG5cdFx0bWF4ID0gaW5jclJvdW5kVXAobWF4LCBtaW5NYXhJbmNyc1sxXSk7XG5cdH1cblxuXHRyZXR1cm4gW21pbiwgbWF4XTtcbn1cblxuZnVuY3Rpb24gcmFuZ2VBc2luaChtaW4sIG1heCwgYmFzZSwgZnVsbE1hZ3MpIHtcblx0bGV0IG1pbk1heCA9IHJhbmdlTG9nKG1pbiwgbWF4LCBiYXNlLCBmdWxsTWFncyk7XG5cblx0aWYgKG1pbiA9PSAwKVxuXHRcdG1pbk1heFswXSA9IDA7XG5cblx0aWYgKG1heCA9PSAwKVxuXHRcdG1pbk1heFsxXSA9IDA7XG5cblx0cmV0dXJuIG1pbk1heDtcbn1cblxuY29uc3QgX2VxUmFuZ2VQYXJ0ID0ge1xuXHRwYWQ6ICAwLFxuXHRzb2Z0OiBudWxsLFxuXHRtb2RlOiAwLFxufTtcblxuY29uc3QgX2VxUmFuZ2UgPSB7XG5cdG1pbjogX2VxUmFuZ2VQYXJ0LFxuXHRtYXg6IF9lcVJhbmdlUGFydCxcbn07XG5cbi8vIHRoaXMgZW5zdXJlcyB0aGF0IG5vbi10ZW1wb3JhbC9udW1lcmljIHktYXhlcyBnZXQgbXVsdGlwbGUtc25hcHBlZCBwYWRkaW5nIGFkZGVkIGFib3ZlL2JlbG93XG4vLyBUT0RPOiBhbHNvIGFjY291bnQgZm9yIGluY3JzIHdoZW4gc25hcHBpbmcgdG8gZW5zdXJlIHRvcCBvZiBheGlzIGdldHMgYSB0aWNrICYgdmFsdWVcbmZ1bmN0aW9uIHJhbmdlTnVtKF9taW4sIF9tYXgsIG11bHQsIGV4dHJhKSB7XG5cdGlmIChpc09iaihtdWx0KSlcblx0XHRyZXR1cm4gX3JhbmdlTnVtKF9taW4sIF9tYXgsIG11bHQpO1xuXG5cdF9lcVJhbmdlUGFydC5wYWQgID0gbXVsdDtcblx0X2VxUmFuZ2VQYXJ0LnNvZnQgPSBleHRyYSA/IDAgOiBudWxsO1xuXHRfZXFSYW5nZVBhcnQubW9kZSA9IGV4dHJhID8gMyA6IDA7XG5cblx0cmV0dXJuIF9yYW5nZU51bShfbWluLCBfbWF4LCBfZXFSYW5nZSk7XG59XG5cbi8vIG51bGxpc2ggY29hbGVzY2VcbmZ1bmN0aW9uIGlmTnVsbChsaCwgcmgpIHtcblx0cmV0dXJuIGxoID09IG51bGwgPyByaCA6IGxoO1xufVxuXG5mdW5jdGlvbiBfcmFuZ2VOdW0oX21pbiwgX21heCwgY2ZnKSB7XG5cdGxldCBjbWluID0gY2ZnLm1pbjtcblx0bGV0IGNtYXggPSBjZmcubWF4O1xuXG5cdGxldCBwYWRNaW4gPSBpZk51bGwoY21pbi5wYWQsIDApO1xuXHRsZXQgcGFkTWF4ID0gaWZOdWxsKGNtYXgucGFkLCAwKTtcblxuXHRsZXQgaGFyZE1pbiA9IGlmTnVsbChjbWluLmhhcmQsIC1pbmYpO1xuXHRsZXQgaGFyZE1heCA9IGlmTnVsbChjbWF4LmhhcmQsICBpbmYpO1xuXG5cdGxldCBzb2Z0TWluID0gaWZOdWxsKGNtaW4uc29mdCwgIGluZik7XG5cdGxldCBzb2Z0TWF4ID0gaWZOdWxsKGNtYXguc29mdCwgLWluZik7XG5cblx0bGV0IHNvZnRNaW5Nb2RlID0gaWZOdWxsKGNtaW4ubW9kZSwgMCk7XG5cdGxldCBzb2Z0TWF4TW9kZSA9IGlmTnVsbChjbWF4Lm1vZGUsIDApO1xuXG5cdGxldCBkZWx0YSAgICAgICAgPSBfbWF4IC0gX21pbjtcblxuXHQvLyB0aGlzIGhhbmRsZXMgc2l0dWF0aW9ucyBsaWtlIDg5LjcsIDg5LjY5OTk5OTk5OTk5OTk5XG5cdC8vIGJ5IGFzc3VtaW5nIDAuMDAxeCBkZWx0YXMgYXJlIHByZWNpc2lvbiBlcnJvcnNcbi8vXHRpZiAoZGVsdGEgPiAwICYmIGRlbHRhIDwgYWJzKF9tYXgpIC8gMWUzKVxuLy9cdFx0ZGVsdGEgPSAwO1xuXG5cdC8vIHRyZWF0IGRhdGEgYXMgZmxhdCBpZiBkZWx0YSBpcyBsZXNzIHRoYW4gMSBiaWxsaW9udGhcblx0aWYgKGRlbHRhIDwgMWUtOSlcblx0XHRkZWx0YSA9IDA7XG5cblx0bGV0IG5vblplcm9EZWx0YSA9IGRlbHRhIHx8IGFicyhfbWF4KSB8fCAxZTM7XG5cdGxldCBtYWcgICAgICAgICAgPSBsb2cxMChub25aZXJvRGVsdGEpO1xuXHRsZXQgYmFzZSAgICAgICAgID0gcG93KDEwLCBmbG9vcihtYWcpKTtcblxuXHRsZXQgX3BhZE1pbiAgPSBub25aZXJvRGVsdGEgKiAoZGVsdGEgPT0gMCA/IChfbWluID09IDAgPyAuMSA6IDEpIDogcGFkTWluKTtcblx0bGV0IF9uZXdNaW4gID0gcm91bmREZWMoaW5jclJvdW5kRG4oX21pbiAtIF9wYWRNaW4sIGJhc2UvMTApLCA5KTtcblx0bGV0IF9zb2Z0TWluID0gX21pbiA+PSBzb2Z0TWluICYmIChzb2Z0TWluTW9kZSA9PSAxIHx8IHNvZnRNaW5Nb2RlID09IDMgJiYgX25ld01pbiA8PSBzb2Z0TWluIHx8IHNvZnRNaW5Nb2RlID09IDIgJiYgX25ld01pbiA+PSBzb2Z0TWluKSA/IHNvZnRNaW4gOiBpbmY7XG5cdGxldCBtaW5MaW0gICA9IG1heChoYXJkTWluLCBfbmV3TWluIDwgX3NvZnRNaW4gJiYgX21pbiA+PSBfc29mdE1pbiA/IF9zb2Z0TWluIDogbWluKF9zb2Z0TWluLCBfbmV3TWluKSk7XG5cblx0bGV0IF9wYWRNYXggID0gbm9uWmVyb0RlbHRhICogKGRlbHRhID09IDAgPyAoX21heCA9PSAwID8gLjEgOiAxKSA6IHBhZE1heCk7XG5cdGxldCBfbmV3TWF4ICA9IHJvdW5kRGVjKGluY3JSb3VuZFVwKF9tYXggKyBfcGFkTWF4LCBiYXNlLzEwKSwgOSk7XG5cdGxldCBfc29mdE1heCA9IF9tYXggPD0gc29mdE1heCAmJiAoc29mdE1heE1vZGUgPT0gMSB8fCBzb2Z0TWF4TW9kZSA9PSAzICYmIF9uZXdNYXggPj0gc29mdE1heCB8fCBzb2Z0TWF4TW9kZSA9PSAyICYmIF9uZXdNYXggPD0gc29mdE1heCkgPyBzb2Z0TWF4IDogLWluZjtcblx0bGV0IG1heExpbSAgID0gbWluKGhhcmRNYXgsIF9uZXdNYXggPiBfc29mdE1heCAmJiBfbWF4IDw9IF9zb2Z0TWF4ID8gX3NvZnRNYXggOiBtYXgoX3NvZnRNYXgsIF9uZXdNYXgpKTtcblxuXHRpZiAobWluTGltID09IG1heExpbSAmJiBtaW5MaW0gPT0gMClcblx0XHRtYXhMaW0gPSAxMDA7XG5cblx0cmV0dXJuIFttaW5MaW0sIG1heExpbV07XG59XG5cbi8vIGFsdGVybmF0aXZlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI1NDg5NlxuY29uc3QgZm10TnVtID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KG5hdmlnYXRvci5sYW5ndWFnZSkuZm9ybWF0O1xuXG5jb25zdCBNID0gTWF0aDtcblxuY29uc3QgUEkgPSBNLlBJO1xuY29uc3QgYWJzID0gTS5hYnM7XG5jb25zdCBmbG9vciA9IE0uZmxvb3I7XG5jb25zdCByb3VuZCA9IE0ucm91bmQ7XG5jb25zdCBjZWlsID0gTS5jZWlsO1xuY29uc3QgbWluID0gTS5taW47XG5jb25zdCBtYXggPSBNLm1heDtcbmNvbnN0IHBvdyA9IE0ucG93O1xuY29uc3QgbG9nMTAgPSBNLmxvZzEwO1xuY29uc3QgbG9nMiA9IE0ubG9nMjtcbmNvbnN0IHNpbmggPSAgKHYsIGxpbnRocmVzaCA9IDEpID0+IE0uc2luaCh2IC8gbGludGhyZXNoKTtcbmNvbnN0IGFzaW5oID0gKHYsIGxpbnRocmVzaCA9IDEpID0+IE0uYXNpbmgodiAvIGxpbnRocmVzaCk7XG5cbmNvbnN0IGluZiA9IEluZmluaXR5O1xuXG5mdW5jdGlvbiBpbmNyUm91bmQobnVtLCBpbmNyKSB7XG5cdHJldHVybiByb3VuZChudW0vaW5jcikqaW5jcjtcbn1cblxuZnVuY3Rpb24gY2xhbXAobnVtLCBfbWluLCBfbWF4KSB7XG5cdHJldHVybiBtaW4obWF4KG51bSwgX21pbiksIF9tYXgpO1xufVxuXG5mdW5jdGlvbiBmbk9yU2VsZih2KSB7XG5cdHJldHVybiB0eXBlb2YgdiA9PSBcImZ1bmN0aW9uXCIgPyB2IDogKCkgPT4gdjtcbn1cblxuY29uc3QgcmV0QXJnMCA9IF8wID0+IF8wO1xuXG5jb25zdCByZXRBcmcxID0gKF8wLCBfMSkgPT4gXzE7XG5cbmNvbnN0IHJldE51bGwgPSBfID0+IG51bGw7XG5cbmNvbnN0IHJldFRydWUgPSBfID0+IHRydWU7XG5cbmNvbnN0IHJldEVxID0gKGEsIGIpID0+IGEgPT0gYjtcblxuZnVuY3Rpb24gaW5jclJvdW5kVXAobnVtLCBpbmNyKSB7XG5cdHJldHVybiBjZWlsKG51bS9pbmNyKSppbmNyO1xufVxuXG5mdW5jdGlvbiBpbmNyUm91bmREbihudW0sIGluY3IpIHtcblx0cmV0dXJuIGZsb29yKG51bS9pbmNyKSppbmNyO1xufVxuXG5mdW5jdGlvbiByb3VuZERlYyh2YWwsIGRlYykge1xuXHRyZXR1cm4gcm91bmQodmFsICogKGRlYyA9IDEwKipkZWMpKSAvIGRlYztcbn1cblxuY29uc3QgZml4ZWREZWMgPSBuZXcgTWFwKCk7XG5cbmZ1bmN0aW9uIGd1ZXNzRGVjKG51bSkge1xuXHRyZXR1cm4gKChcIlwiK251bSkuc3BsaXQoXCIuXCIpWzFdIHx8IFwiXCIpLmxlbmd0aDtcbn1cblxuZnVuY3Rpb24gZ2VuSW5jcnMoYmFzZSwgbWluRXhwLCBtYXhFeHAsIG11bHRzKSB7XG5cdGxldCBpbmNycyA9IFtdO1xuXG5cdGxldCBtdWx0RGVjID0gbXVsdHMubWFwKGd1ZXNzRGVjKTtcblxuXHRmb3IgKGxldCBleHAgPSBtaW5FeHA7IGV4cCA8IG1heEV4cDsgZXhwKyspIHtcblx0XHRsZXQgZXhwYSA9IGFicyhleHApO1xuXHRcdGxldCBtYWcgPSByb3VuZERlYyhwb3coYmFzZSwgZXhwKSwgZXhwYSk7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG11bHRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRsZXQgX2luY3IgPSBtdWx0c1tpXSAqIG1hZztcblx0XHRcdGxldCBkZWMgPSAoX2luY3IgPj0gMCAmJiBleHAgPj0gMCA/IDAgOiBleHBhKSArIChleHAgPj0gbXVsdERlY1tpXSA/IDAgOiBtdWx0RGVjW2ldKTtcblx0XHRcdGxldCBpbmNyID0gcm91bmREZWMoX2luY3IsIGRlYyk7XG5cdFx0XHRpbmNycy5wdXNoKGluY3IpO1xuXHRcdFx0Zml4ZWREZWMuc2V0KGluY3IsIGRlYyk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGluY3JzO1xufVxuXG4vL2V4cG9ydCBjb25zdCBhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuXG5jb25zdCBFTVBUWV9PQkogPSB7fTtcblxuY29uc3QgbnVsbE51bGxUdXBsZSA9IFtudWxsLCBudWxsXTtcblxuY29uc3QgaXNBcnIgPSBBcnJheS5pc0FycmF5O1xuXG5mdW5jdGlvbiBpc1N0cih2KSB7XG5cdHJldHVybiB0eXBlb2YgdiA9PSAnc3RyaW5nJztcbn1cblxuZnVuY3Rpb24gaXNPYmoodikge1xuXHRsZXQgaXMgPSBmYWxzZTtcblxuXHRpZiAodiAhPSBudWxsKSB7XG5cdFx0bGV0IGMgPSB2LmNvbnN0cnVjdG9yO1xuXHRcdGlzID0gYyA9PSBudWxsIHx8IGMgPT0gT2JqZWN0O1xuXHR9XG5cblx0cmV0dXJuIGlzO1xufVxuXG5mdW5jdGlvbiBmYXN0SXNPYmoodikge1xuXHRyZXR1cm4gdiAhPSBudWxsICYmIHR5cGVvZiB2ID09ICdvYmplY3QnO1xufVxuXG5mdW5jdGlvbiBjb3B5KG8sIF9pc09iaikge1xuXHRfaXNPYmogPSBfaXNPYmogfHwgaXNPYmo7XG5cblx0bGV0IG91dDtcblxuXHRpZiAoaXNBcnIobykpXG5cdFx0b3V0ID0gby5tYXAodiA9PiBjb3B5KHYsIF9pc09iaikpO1xuXHRlbHNlIGlmIChfaXNPYmoobykpIHtcblx0XHRvdXQgPSB7fTtcblx0XHRmb3IgKHZhciBrIGluIG8pXG5cdFx0XHRvdXRba10gPSBjb3B5KG9ba10sIF9pc09iaik7XG5cdH1cblx0ZWxzZVxuXHRcdG91dCA9IG87XG5cblx0cmV0dXJuIG91dDtcbn1cblxuZnVuY3Rpb24gYXNzaWduKHRhcmcpIHtcblx0bGV0IGFyZ3MgPSBhcmd1bWVudHM7XG5cblx0Zm9yIChsZXQgaSA9IDE7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG5cdFx0bGV0IHNyYyA9IGFyZ3NbaV07XG5cblx0XHRmb3IgKGxldCBrZXkgaW4gc3JjKSB7XG5cdFx0XHRpZiAoaXNPYmoodGFyZ1trZXldKSlcblx0XHRcdFx0YXNzaWduKHRhcmdba2V5XSwgY29weShzcmNba2V5XSkpO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHR0YXJnW2tleV0gPSBjb3B5KHNyY1trZXldKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdGFyZztcbn1cblxuLy8gbnVsbE1vZGVzXG5jb25zdCBOVUxMX1JFTU9WRSA9IDA7ICAvLyBudWxscyBhcmUgY29udmVydGVkIHRvIHVuZGVmaW5lZCAoZS5nLiBmb3Igc3BhbkdhcHM6IHRydWUpXG5jb25zdCBOVUxMX1JFVEFJTiA9IDE7ICAvLyBudWxscyBhcmUgcmV0YWluZWQsIHdpdGggYWxpZ25tZW50IGFydGlmYWN0cyBzZXQgdG8gdW5kZWZpbmVkIChkZWZhdWx0KVxuY29uc3QgTlVMTF9FWFBBTkQgPSAyOyAgLy8gbnVsbHMgYXJlIGV4cGFuZGVkIHRvIGluY2x1ZGUgYW55IGFkamFjZW50IGFsaWdubWVudCBhcnRpZmFjdHNcblxuLy8gc2V0cyB1bmRlZmluZWQgdmFsdWVzIHRvIG51bGxzIHdoZW4gYWRqYWNlbnQgdG8gZXhpc3RpbmcgbnVsbHMgKG1pbmVzd2VlcGVyKVxuZnVuY3Rpb24gbnVsbEV4cGFuZCh5VmFscywgbnVsbElkeHMsIGFsaWduZWRMZW4pIHtcblx0Zm9yIChsZXQgaSA9IDAsIHhpLCBsYXN0TnVsbElkeCA9IC0xOyBpIDwgbnVsbElkeHMubGVuZ3RoOyBpKyspIHtcblx0XHRsZXQgbnVsbElkeCA9IG51bGxJZHhzW2ldO1xuXG5cdFx0aWYgKG51bGxJZHggPiBsYXN0TnVsbElkeCkge1xuXHRcdFx0eGkgPSBudWxsSWR4IC0gMTtcblx0XHRcdHdoaWxlICh4aSA+PSAwICYmIHlWYWxzW3hpXSA9PSBudWxsKVxuXHRcdFx0XHR5VmFsc1t4aS0tXSA9IG51bGw7XG5cblx0XHRcdHhpID0gbnVsbElkeCArIDE7XG5cdFx0XHR3aGlsZSAoeGkgPCBhbGlnbmVkTGVuICYmIHlWYWxzW3hpXSA9PSBudWxsKVxuXHRcdFx0XHR5VmFsc1tsYXN0TnVsbElkeCA9IHhpKytdID0gbnVsbDtcblx0XHR9XG5cdH1cbn1cblxuLy8gbnVsbE1vZGVzIGlzIGEgdGFibGVzLW1hdGNoZWQgYXJyYXkgaW5kaWNhdGluZyBob3cgdG8gdHJlYXQgbnVsbHMgaW4gZWFjaCBzZXJpZXNcbi8vIG91dHB1dCBpcyBzb3J0ZWQgQVNDIG9uIHRoZSBqb2luZWQgZmllbGQgKHRhYmxlWzBdKSBhbmQgZHVwbGljYXRlIGpvaW4gdmFsdWVzIGFyZSBjb2xsYXBzZWRcbmZ1bmN0aW9uIGpvaW4odGFibGVzLCBudWxsTW9kZXMpIHtcblx0bGV0IHhWYWxzID0gbmV3IFNldCgpO1xuXG5cdGZvciAobGV0IHRpID0gMDsgdGkgPCB0YWJsZXMubGVuZ3RoOyB0aSsrKSB7XG5cdFx0bGV0IHQgPSB0YWJsZXNbdGldO1xuXHRcdGxldCB4cyA9IHRbMF07XG5cdFx0bGV0IGxlbiA9IHhzLmxlbmd0aDtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspXG5cdFx0XHR4VmFscy5hZGQoeHNbaV0pO1xuXHR9XG5cblx0bGV0IGRhdGEgPSBbQXJyYXkuZnJvbSh4VmFscykuc29ydCgoYSwgYikgPT4gYSAtIGIpXTtcblxuXHRsZXQgYWxpZ25lZExlbiA9IGRhdGFbMF0ubGVuZ3RoO1xuXG5cdGxldCB4SWR4cyA9IG5ldyBNYXAoKTtcblxuXHRmb3IgKGxldCBpID0gMDsgaSA8IGFsaWduZWRMZW47IGkrKylcblx0XHR4SWR4cy5zZXQoZGF0YVswXVtpXSwgaSk7XG5cblx0Zm9yIChsZXQgdGkgPSAwOyB0aSA8IHRhYmxlcy5sZW5ndGg7IHRpKyspIHtcblx0XHRsZXQgdCA9IHRhYmxlc1t0aV07XG5cdFx0bGV0IHhzID0gdFswXTtcblxuXHRcdGZvciAobGV0IHNpID0gMTsgc2kgPCB0Lmxlbmd0aDsgc2krKykge1xuXHRcdFx0bGV0IHlzID0gdFtzaV07XG5cblx0XHRcdGxldCB5VmFscyA9IEFycmF5KGFsaWduZWRMZW4pLmZpbGwodW5kZWZpbmVkKTtcblxuXHRcdFx0bGV0IG51bGxNb2RlID0gbnVsbE1vZGVzID8gbnVsbE1vZGVzW3RpXVtzaV0gOiBOVUxMX1JFVEFJTjtcblxuXHRcdFx0bGV0IG51bGxJZHhzID0gW107XG5cblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgeXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0bGV0IHlWYWwgPSB5c1tpXTtcblx0XHRcdFx0bGV0IGFsaWduZWRJZHggPSB4SWR4cy5nZXQoeHNbaV0pO1xuXG5cdFx0XHRcdGlmICh5VmFsID09PSBudWxsKSB7XG5cdFx0XHRcdFx0aWYgKG51bGxNb2RlICE9IE5VTExfUkVNT1ZFKSB7XG5cdFx0XHRcdFx0XHR5VmFsc1thbGlnbmVkSWR4XSA9IHlWYWw7XG5cblx0XHRcdFx0XHRcdGlmIChudWxsTW9kZSA9PSBOVUxMX0VYUEFORClcblx0XHRcdFx0XHRcdFx0bnVsbElkeHMucHVzaChhbGlnbmVkSWR4KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdHlWYWxzW2FsaWduZWRJZHhdID0geVZhbDtcblx0XHRcdH1cblxuXHRcdFx0bnVsbEV4cGFuZCh5VmFscywgbnVsbElkeHMsIGFsaWduZWRMZW4pO1xuXG5cdFx0XHRkYXRhLnB1c2goeVZhbHMpO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBkYXRhO1xufVxuXG5jb25zdCBtaWNyb1Rhc2sgPSB0eXBlb2YgcXVldWVNaWNyb3Rhc2sgPT0gXCJ1bmRlZmluZWRcIiA/IGZuID0+IFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZm4pIDogcXVldWVNaWNyb3Rhc2s7XG5cbmNvbnN0IFdJRFRIICAgICAgID0gXCJ3aWR0aFwiO1xuY29uc3QgSEVJR0hUICAgICAgPSBcImhlaWdodFwiO1xuY29uc3QgVE9QICAgICAgICAgPSBcInRvcFwiO1xuY29uc3QgQk9UVE9NICAgICAgPSBcImJvdHRvbVwiO1xuY29uc3QgTEVGVCAgICAgICAgPSBcImxlZnRcIjtcbmNvbnN0IFJJR0hUICAgICAgID0gXCJyaWdodFwiO1xuY29uc3QgaGV4QmxhY2sgICAgPSBcIiMwMDBcIjtcbmNvbnN0IHRyYW5zcGFyZW50ID0gaGV4QmxhY2sgKyBcIjBcIjtcblxuY29uc3QgbW91c2Vtb3ZlICAgPSBcIm1vdXNlbW92ZVwiO1xuY29uc3QgbW91c2Vkb3duICAgPSBcIm1vdXNlZG93blwiO1xuY29uc3QgbW91c2V1cCAgICAgPSBcIm1vdXNldXBcIjtcbmNvbnN0IG1vdXNlZW50ZXIgID0gXCJtb3VzZWVudGVyXCI7XG5jb25zdCBtb3VzZWxlYXZlICA9IFwibW91c2VsZWF2ZVwiO1xuY29uc3QgZGJsY2xpY2sgICAgPSBcImRibGNsaWNrXCI7XG5jb25zdCByZXNpemUgICAgICA9IFwicmVzaXplXCI7XG5jb25zdCBzY3JvbGwgICAgICA9IFwic2Nyb2xsXCI7XG5cbmNvbnN0IHByZSA9IFwidS1cIjtcblxuY29uc3QgVVBMT1QgICAgICAgICAgPSAgICAgICBcInVwbG90XCI7XG5jb25zdCBPUklfSFogICAgICAgICA9IHByZSArIFwiaHpcIjtcbmNvbnN0IE9SSV9WVCAgICAgICAgID0gcHJlICsgXCJ2dFwiO1xuY29uc3QgVElUTEUgICAgICAgICAgPSBwcmUgKyBcInRpdGxlXCI7XG5jb25zdCBXUkFQICAgICAgICAgICA9IHByZSArIFwid3JhcFwiO1xuY29uc3QgVU5ERVIgICAgICAgICAgPSBwcmUgKyBcInVuZGVyXCI7XG5jb25zdCBPVkVSICAgICAgICAgICA9IHByZSArIFwib3ZlclwiO1xuY29uc3QgT0ZGICAgICAgICAgICAgPSBwcmUgKyBcIm9mZlwiO1xuY29uc3QgU0VMRUNUICAgICAgICAgPSBwcmUgKyBcInNlbGVjdFwiO1xuY29uc3QgQ1VSU09SX1ggICAgICAgPSBwcmUgKyBcImN1cnNvci14XCI7XG5jb25zdCBDVVJTT1JfWSAgICAgICA9IHByZSArIFwiY3Vyc29yLXlcIjtcbmNvbnN0IENVUlNPUl9QVCAgICAgID0gcHJlICsgXCJjdXJzb3ItcHRcIjtcbmNvbnN0IExFR0VORCAgICAgICAgID0gcHJlICsgXCJsZWdlbmRcIjtcbmNvbnN0IExFR0VORF9MSVZFICAgID0gcHJlICsgXCJsaXZlXCI7XG5jb25zdCBMRUdFTkRfSU5MSU5FICA9IHByZSArIFwiaW5saW5lXCI7XG5jb25zdCBMRUdFTkRfVEhFQUQgICA9IHByZSArIFwidGhlYWRcIjtcbmNvbnN0IExFR0VORF9TRVJJRVMgID0gcHJlICsgXCJzZXJpZXNcIjtcbmNvbnN0IExFR0VORF9NQVJLRVIgID0gcHJlICsgXCJtYXJrZXJcIjtcbmNvbnN0IExFR0VORF9MQUJFTCAgID0gcHJlICsgXCJsYWJlbFwiO1xuY29uc3QgTEVHRU5EX1ZBTFVFICAgPSBwcmUgKyBcInZhbHVlXCI7XG5cbmNvbnN0IGRvYyA9IGRvY3VtZW50O1xuY29uc3Qgd2luID0gd2luZG93O1xuY29uc3QgcHhSYXRpbyA9IGRldmljZVBpeGVsUmF0aW87XG5cbmZ1bmN0aW9uIGFkZENsYXNzKGVsLCBjKSB7XG5cdGlmIChjICE9IG51bGwpIHtcblx0XHRsZXQgY2wgPSBlbC5jbGFzc0xpc3Q7XG5cdFx0IWNsLmNvbnRhaW5zKGMpICYmIGNsLmFkZChjKTtcblx0fVxufVxuXG5mdW5jdGlvbiByZW1DbGFzcyhlbCwgYykge1xuXHRsZXQgY2wgPSBlbC5jbGFzc0xpc3Q7XG5cdGNsLmNvbnRhaW5zKGMpICYmIGNsLnJlbW92ZShjKTtcbn1cblxuZnVuY3Rpb24gc2V0U3R5bGVQeChlbCwgbmFtZSwgdmFsdWUpIHtcblx0ZWwuc3R5bGVbbmFtZV0gPSB2YWx1ZSArIFwicHhcIjtcbn1cblxuZnVuY3Rpb24gcGxhY2VUYWcodGFnLCBjbHMsIHRhcmcsIHJlZkVsKSB7XG5cdGxldCBlbCA9IGRvYy5jcmVhdGVFbGVtZW50KHRhZyk7XG5cblx0aWYgKGNscyAhPSBudWxsKVxuXHRcdGFkZENsYXNzKGVsLCBjbHMpO1xuXG5cdGlmICh0YXJnICE9IG51bGwpXG5cdFx0dGFyZy5pbnNlcnRCZWZvcmUoZWwsIHJlZkVsKTtcblxuXHRyZXR1cm4gZWw7XG59XG5cbmZ1bmN0aW9uIHBsYWNlRGl2KGNscywgdGFyZykge1xuXHRyZXR1cm4gcGxhY2VUYWcoXCJkaXZcIiwgY2xzLCB0YXJnKTtcbn1cblxuZnVuY3Rpb24gdHJhbnMoZWwsIHhQb3MsIHlQb3MsIHhNYXgsIHlNYXgpIHtcblx0ZWwuc3R5bGUudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIgKyB4UG9zICsgXCJweCxcIiArIHlQb3MgKyBcInB4KVwiO1xuXG5cdGlmICh4UG9zIDwgMCB8fCB5UG9zIDwgMCB8fCB4UG9zID4geE1heCB8fCB5UG9zID4geU1heClcblx0XHRhZGRDbGFzcyhlbCwgT0ZGKTtcblx0ZWxzZVxuXHRcdHJlbUNsYXNzKGVsLCBPRkYpO1xufVxuXG5jb25zdCBldk9wdHMgPSB7cGFzc2l2ZTogdHJ1ZX07XG5jb25zdCBldk9wdHMyID0gYXNzaWduKHtjYXB0dXJlOiB0cnVlfSwgZXZPcHRzKTtcblxuZnVuY3Rpb24gb24oZXYsIGVsLCBjYiwgY2FwdCkge1xuXHRlbC5hZGRFdmVudExpc3RlbmVyKGV2LCBjYiwgY2FwdCA/IGV2T3B0czIgOiBldk9wdHMpO1xufVxuXG5mdW5jdGlvbiBvZmYoZXYsIGVsLCBjYiwgY2FwdCkge1xuXHRlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2LCBjYiwgY2FwdCA/IGV2T3B0czIgOiBldk9wdHMpO1xufVxuXG5jb25zdCBtb250aHMgPSBbXG5cdFwiSmFudWFyeVwiLFxuXHRcIkZlYnJ1YXJ5XCIsXG5cdFwiTWFyY2hcIixcblx0XCJBcHJpbFwiLFxuXHRcIk1heVwiLFxuXHRcIkp1bmVcIixcblx0XCJKdWx5XCIsXG5cdFwiQXVndXN0XCIsXG5cdFwiU2VwdGVtYmVyXCIsXG5cdFwiT2N0b2JlclwiLFxuXHRcIk5vdmVtYmVyXCIsXG5cdFwiRGVjZW1iZXJcIixcbl07XG5cbmNvbnN0IGRheXMgPSBbXG5cdFwiU3VuZGF5XCIsXG5cdFwiTW9uZGF5XCIsXG5cdFwiVHVlc2RheVwiLFxuXHRcIldlZG5lc2RheVwiLFxuXHRcIlRodXJzZGF5XCIsXG5cdFwiRnJpZGF5XCIsXG5cdFwiU2F0dXJkYXlcIixcbl07XG5cbmZ1bmN0aW9uIHNsaWNlMyhzdHIpIHtcblx0cmV0dXJuIHN0ci5zbGljZSgwLCAzKTtcbn1cblxuY29uc3QgZGF5czMgPSBkYXlzLm1hcChzbGljZTMpO1xuXG5jb25zdCBtb250aHMzID0gbW9udGhzLm1hcChzbGljZTMpO1xuXG5jb25zdCBlbmdOYW1lcyA9IHtcblx0TU1NTTogbW9udGhzLFxuXHRNTU06ICBtb250aHMzLFxuXHRXV1dXOiBkYXlzLFxuXHRXV1c6ICBkYXlzMyxcbn07XG5cbmZ1bmN0aW9uIHplcm9QYWQyKGludCkge1xuXHRyZXR1cm4gKGludCA8IDEwID8gJzAnIDogJycpICsgaW50O1xufVxuXG5mdW5jdGlvbiB6ZXJvUGFkMyhpbnQpIHtcblx0cmV0dXJuIChpbnQgPCAxMCA/ICcwMCcgOiBpbnQgPCAxMDAgPyAnMCcgOiAnJykgKyBpbnQ7XG59XG5cbi8qXG5mdW5jdGlvbiBzdWZmaXgoaW50KSB7XG5cdGxldCBtb2QxMCA9IGludCAlIDEwO1xuXG5cdHJldHVybiBpbnQgKyAoXG5cdFx0bW9kMTAgPT0gMSAmJiBpbnQgIT0gMTEgPyBcInN0XCIgOlxuXHRcdG1vZDEwID09IDIgJiYgaW50ICE9IDEyID8gXCJuZFwiIDpcblx0XHRtb2QxMCA9PSAzICYmIGludCAhPSAxMyA/IFwicmRcIiA6IFwidGhcIlxuXHQpO1xufVxuKi9cblxuY29uc3Qgc3VicyA9IHtcblx0Ly8gMjAxOVxuXHRZWVlZOlx0ZCA9PiBkLmdldEZ1bGxZZWFyKCksXG5cdC8vIDE5XG5cdFlZOlx0XHRkID0+IChkLmdldEZ1bGxZZWFyKCkrJycpLnNsaWNlKDIpLFxuXHQvLyBKdWx5XG5cdE1NTU06XHQoZCwgbmFtZXMpID0+IG5hbWVzLk1NTU1bZC5nZXRNb250aCgpXSxcblx0Ly8gSnVsXG5cdE1NTTpcdChkLCBuYW1lcykgPT4gbmFtZXMuTU1NW2QuZ2V0TW9udGgoKV0sXG5cdC8vIDA3XG5cdE1NOlx0XHRkID0+IHplcm9QYWQyKGQuZ2V0TW9udGgoKSsxKSxcblx0Ly8gN1xuXHRNOlx0XHRkID0+IGQuZ2V0TW9udGgoKSsxLFxuXHQvLyAwOVxuXHRERDpcdFx0ZCA9PiB6ZXJvUGFkMihkLmdldERhdGUoKSksXG5cdC8vIDlcblx0RDpcdFx0ZCA9PiBkLmdldERhdGUoKSxcblx0Ly8gTW9uZGF5XG5cdFdXV1c6XHQoZCwgbmFtZXMpID0+IG5hbWVzLldXV1dbZC5nZXREYXkoKV0sXG5cdC8vIE1vblxuXHRXV1c6XHQoZCwgbmFtZXMpID0+IG5hbWVzLldXV1tkLmdldERheSgpXSxcblx0Ly8gMDNcblx0SEg6XHRcdGQgPT4gemVyb1BhZDIoZC5nZXRIb3VycygpKSxcblx0Ly8gM1xuXHRIOlx0XHRkID0+IGQuZ2V0SG91cnMoKSxcblx0Ly8gOSAoMTJociwgdW5wYWRkZWQpXG5cdGg6XHRcdGQgPT4ge2xldCBoID0gZC5nZXRIb3VycygpOyByZXR1cm4gaCA9PSAwID8gMTIgOiBoID4gMTIgPyBoIC0gMTIgOiBoO30sXG5cdC8vIEFNXG5cdEFBOlx0XHRkID0+IGQuZ2V0SG91cnMoKSA+PSAxMiA/ICdQTScgOiAnQU0nLFxuXHQvLyBhbVxuXHRhYTpcdFx0ZCA9PiBkLmdldEhvdXJzKCkgPj0gMTIgPyAncG0nIDogJ2FtJyxcblx0Ly8gYVxuXHRhOlx0XHRkID0+IGQuZ2V0SG91cnMoKSA+PSAxMiA/ICdwJyA6ICdhJyxcblx0Ly8gMDlcblx0bW06XHRcdGQgPT4gemVyb1BhZDIoZC5nZXRNaW51dGVzKCkpLFxuXHQvLyA5XG5cdG06XHRcdGQgPT4gZC5nZXRNaW51dGVzKCksXG5cdC8vIDA5XG5cdHNzOlx0XHRkID0+IHplcm9QYWQyKGQuZ2V0U2Vjb25kcygpKSxcblx0Ly8gOVxuXHRzOlx0XHRkID0+IGQuZ2V0U2Vjb25kcygpLFxuXHQvLyAzNzRcblx0ZmZmOlx0ZCA9PiB6ZXJvUGFkMyhkLmdldE1pbGxpc2Vjb25kcygpKSxcbn07XG5cbmZ1bmN0aW9uIGZtdERhdGUodHBsLCBuYW1lcykge1xuXHRuYW1lcyA9IG5hbWVzIHx8IGVuZ05hbWVzO1xuXHRsZXQgcGFydHMgPSBbXTtcblxuXHRsZXQgUiA9IC9cXHsoW2Etel0rKVxcfXxbXntdKy9naSwgbTtcblxuXHR3aGlsZSAobSA9IFIuZXhlYyh0cGwpKVxuXHRcdHBhcnRzLnB1c2gobVswXVswXSA9PSAneycgPyBzdWJzW21bMV1dIDogbVswXSk7XG5cblx0cmV0dXJuIGQgPT4ge1xuXHRcdGxldCBvdXQgPSAnJztcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspXG5cdFx0XHRvdXQgKz0gdHlwZW9mIHBhcnRzW2ldID09IFwic3RyaW5nXCIgPyBwYXJ0c1tpXSA6IHBhcnRzW2ldKGQsIG5hbWVzKTtcblxuXHRcdHJldHVybiBvdXQ7XG5cdH1cbn1cblxuY29uc3QgbG9jYWxUeiA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KCkucmVzb2x2ZWRPcHRpb25zKCkudGltZVpvbmU7XG5cbi8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE1MTQxNzYyL2hvdy10by1pbml0aWFsaXplLWEtamF2YXNjcmlwdC1kYXRlLXRvLWEtcGFydGljdWxhci10aW1lLXpvbmUvNTM2NTIxMzEjNTM2NTIxMzFcbmZ1bmN0aW9uIHR6RGF0ZShkYXRlLCB0eikge1xuXHRsZXQgZGF0ZTI7XG5cblx0Ly8gcGVyZiBvcHRpbWl6YXRpb25cblx0aWYgKHR6ID09ICdVVEMnIHx8IHR6ID09ICdFdGMvVVRDJylcblx0XHRkYXRlMiA9IG5ldyBEYXRlKCtkYXRlICsgZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpICogNmU0KTtcblx0ZWxzZSBpZiAodHogPT0gbG9jYWxUeilcblx0XHRkYXRlMiA9IGRhdGU7XG5cdGVsc2Uge1xuXHRcdGRhdGUyID0gbmV3IERhdGUoZGF0ZS50b0xvY2FsZVN0cmluZygnZW4tVVMnLCB7dGltZVpvbmU6IHR6fSkpO1xuXHRcdGRhdGUyLnNldE1pbGxpc2Vjb25kcyhkYXRlLmdldE1pbGxpc2Vjb25kcygpKTtcblx0fVxuXG5cdHJldHVybiBkYXRlMjtcbn1cblxuLy9leHBvcnQgY29uc3Qgc2VyaWVzID0gW107XG5cbi8vIGRlZmF1bHQgZm9ybWF0dGVyczpcblxuY29uc3Qgb25seVdob2xlID0gdiA9PiB2ICUgMSA9PSAwO1xuXG5jb25zdCBhbGxNdWx0cyA9IFsxLDIsMi41LDVdO1xuXG4vLyAuLi4wLjAxLCAwLjAyLCAwLjAyNSwgMC4wNSwgMC4xLCAwLjIsIDAuMjUsIDAuNVxuY29uc3QgZGVjSW5jcnMgPSBnZW5JbmNycygxMCwgLTE2LCAwLCBhbGxNdWx0cyk7XG5cbi8vIDEsIDIsIDIuNSwgNSwgMTAsIDIwLCAyNSwgNTAuLi5cbmNvbnN0IG9uZUluY3JzID0gZ2VuSW5jcnMoMTAsIDAsIDE2LCBhbGxNdWx0cyk7XG5cbi8vIDEsIDIsICAgICAgNSwgMTAsIDIwLCAyNSwgNTAuLi5cbmNvbnN0IHdob2xlSW5jcnMgPSBvbmVJbmNycy5maWx0ZXIob25seVdob2xlKTtcblxuY29uc3QgbnVtSW5jcnMgPSBkZWNJbmNycy5jb25jYXQob25lSW5jcnMpO1xuXG5jb25zdCBOTCA9IFwiXFxuXCI7XG5cbmNvbnN0IHl5eXkgICAgPSBcIntZWVlZfVwiO1xuY29uc3QgTkx5eXl5ICA9IE5MICsgeXl5eTtcbmNvbnN0IG1kICAgICAgPSBcIntNfS97RH1cIjtcbmNvbnN0IE5MbWQgICAgPSBOTCArIG1kO1xuY29uc3QgTkxtZHl5ICA9IE5MbWQgKyBcIi97WVl9XCI7XG5cbmNvbnN0IGFhICAgICAgPSBcInthYX1cIjtcbmNvbnN0IGhtbSAgICAgPSBcIntofTp7bW19XCI7XG5jb25zdCBobW1hYSAgID0gaG1tICsgYWE7XG5jb25zdCBOTGhtbWFhID0gTkwgKyBobW1hYTtcbmNvbnN0IHNzICAgICAgPSBcIjp7c3N9XCI7XG5cbmNvbnN0IF8gPSBudWxsO1xuXG5mdW5jdGlvbiBnZW5UaW1lU3R1ZmZzKG1zKSB7XG5cdGxldFx0cyAgPSBtcyAqIDFlMyxcblx0XHRtICA9IHMgICogNjAsXG5cdFx0aCAgPSBtICAqIDYwLFxuXHRcdGQgID0gaCAgKiAyNCxcblx0XHRtbyA9IGQgICogMzAsXG5cdFx0eSAgPSBkICAqIDM2NTtcblxuXHQvLyBtaW4gb2YgMWUtMyBwcmV2ZW50cyBzZXR0aW5nIGEgdGVtcG9yYWwgeCB0aWNrcyB0b28gc21hbGwgc2luY2UgRGF0ZSBvYmplY3RzIGNhbm5vdCBhZHZhbmNlIHRpY2tzIHNtYWxsZXIgdGhhbiAxbXNcblx0bGV0IHN1YlNlY0luY3JzID0gbXMgPT0gMSA/IGdlbkluY3JzKDEwLCAwLCAzLCBhbGxNdWx0cykuZmlsdGVyKG9ubHlXaG9sZSkgOiBnZW5JbmNycygxMCwgLTMsIDAsIGFsbE11bHRzKTtcblxuXHRsZXQgdGltZUluY3JzID0gc3ViU2VjSW5jcnMuY29uY2F0KFtcblx0XHQvLyBtaW51dGUgZGl2aXNvcnMgKCMgb2Ygc2Vjcylcblx0XHRzLFxuXHRcdHMgKiA1LFxuXHRcdHMgKiAxMCxcblx0XHRzICogMTUsXG5cdFx0cyAqIDMwLFxuXHRcdC8vIGhvdXIgZGl2aXNvcnMgKCMgb2YgbWlucylcblx0XHRtLFxuXHRcdG0gKiA1LFxuXHRcdG0gKiAxMCxcblx0XHRtICogMTUsXG5cdFx0bSAqIDMwLFxuXHRcdC8vIGRheSBkaXZpc29ycyAoIyBvZiBocnMpXG5cdFx0aCxcblx0XHRoICogMixcblx0XHRoICogMyxcblx0XHRoICogNCxcblx0XHRoICogNixcblx0XHRoICogOCxcblx0XHRoICogMTIsXG5cdFx0Ly8gbW9udGggZGl2aXNvcnMgVE9ETzogbmVlZCBtb3JlP1xuXHRcdGQsXG5cdFx0ZCAqIDIsXG5cdFx0ZCAqIDMsXG5cdFx0ZCAqIDQsXG5cdFx0ZCAqIDUsXG5cdFx0ZCAqIDYsXG5cdFx0ZCAqIDcsXG5cdFx0ZCAqIDgsXG5cdFx0ZCAqIDksXG5cdFx0ZCAqIDEwLFxuXHRcdGQgKiAxNSxcblx0XHQvLyB5ZWFyIGRpdmlzb3JzICgjIG1vbnRocywgYXBwcm94KVxuXHRcdG1vLFxuXHRcdG1vICogMixcblx0XHRtbyAqIDMsXG5cdFx0bW8gKiA0LFxuXHRcdG1vICogNixcblx0XHQvLyBjZW50dXJ5IGRpdmlzb3JzXG5cdFx0eSxcblx0XHR5ICogMixcblx0XHR5ICogNSxcblx0XHR5ICogMTAsXG5cdFx0eSAqIDI1LFxuXHRcdHkgKiA1MCxcblx0XHR5ICogMTAwLFxuXHRdKTtcblxuXHQvLyBbMF06ICAgbWluaW11bSBudW0gc2VjcyBpbiB0aGUgdGljayBpbmNyXG5cdC8vIFsxXTogICBkZWZhdWx0IHRpY2sgZm9ybWF0XG5cdC8vIFsyLTddOiByb2xsb3ZlciB0aWNrIGZvcm1hdHNcblx0Ly8gWzhdOiAgIG1vZGU6IDA6IHJlcGxhY2UgWzFdIC0+IFsyLTddLCAxOiBjb25jYXQgWzFdICsgWzItN11cblx0Y29uc3QgX3RpbWVBeGlzU3RhbXBzID0gW1xuXHQvLyAgIHRpY2sgaW5jciAgICBkZWZhdWx0ICAgICAgICAgIHllYXIgICAgICAgICAgICAgICAgICAgIG1vbnRoICAgZGF5ICAgICAgICAgICAgICAgICAgIGhvdXIgICAgbWluICAgICAgIHNlYyAgIG1vZGVcblx0XHRbeSwgICAgICAgICAgIHl5eXksICAgICAgICAgICAgXywgICAgICAgICAgICAgICAgICAgICAgXywgICAgICBfLCAgICAgICAgICAgICAgICAgICAgXywgICAgICBfLCAgICAgICAgXywgICAgICAgMV0sXG5cdFx0W2QgKiAyOCwgICAgICBcIntNTU19XCIsICAgICAgICAgTkx5eXl5LCAgICAgICAgICAgICAgICAgXywgICAgICBfLCAgICAgICAgICAgICAgICAgICAgXywgICAgICBfLCAgICAgICAgXywgICAgICAgMV0sXG5cdFx0W2QsICAgICAgICAgICBtZCwgICAgICAgICAgICAgIE5MeXl5eSwgICAgICAgICAgICAgICAgIF8sICAgICAgXywgICAgICAgICAgICAgICAgICAgIF8sICAgICAgXywgICAgICAgIF8sICAgICAgIDFdLFxuXHRcdFtoLCAgICAgICAgICAgXCJ7aH1cIiArIGFhLCAgICAgIE5MbWR5eSwgICAgICAgICAgICAgICAgIF8sICAgICAgTkxtZCwgICAgICAgICAgICAgICAgIF8sICAgICAgXywgICAgICAgIF8sICAgICAgIDFdLFxuXHRcdFttLCAgICAgICAgICAgaG1tYWEsICAgICAgICAgICBOTG1keXksICAgICAgICAgICAgICAgICBfLCAgICAgIE5MbWQsICAgICAgICAgICAgICAgICBfLCAgICAgIF8sICAgICAgICBfLCAgICAgICAxXSxcblx0XHRbcywgICAgICAgICAgIHNzLCAgICAgICAgICAgICAgTkxtZHl5ICsgXCIgXCIgKyBobW1hYSwgICBfLCAgICAgIE5MbWQgKyBcIiBcIiArIGhtbWFhLCAgIF8sICAgICAgTkxobW1hYSwgIF8sICAgICAgIDFdLFxuXHRcdFttcywgICAgICAgICAgc3MgKyBcIi57ZmZmfVwiLCAgIE5MbWR5eSArIFwiIFwiICsgaG1tYWEsICAgXywgICAgICBOTG1kICsgXCIgXCIgKyBobW1hYSwgICBfLCAgICAgIE5MaG1tYWEsICBfLCAgICAgICAxXSxcblx0XTtcblxuXHQvLyB0aGUgZW5zdXJlcyB0aGF0IGF4aXMgdGlja3MsIHZhbHVlcyAmIGdyaWQgYXJlIGFsaWduZWQgdG8gbG9naWNhbCB0ZW1wb3JhbCBicmVha3BvaW50cyBhbmQgbm90IGFuIGFyYml0cmFyeSB0aW1lc3RhbXBcblx0Ly8gaHR0cHM6Ly93d3cudGltZWFuZGRhdGUuY29tL3RpbWUvZHN0L1xuXHQvLyBodHRwczovL3d3dy50aW1lYW5kZGF0ZS5jb20vdGltZS9kc3QvMjAxOS5odG1sXG5cdC8vIGh0dHBzOi8vd3d3LmVwb2NoY29udmVydGVyLmNvbS90aW1lem9uZXNcblx0ZnVuY3Rpb24gdGltZUF4aXNTcGxpdHModHpEYXRlKSB7XG5cdFx0cmV0dXJuIChzZWxmLCBheGlzSWR4LCBzY2FsZU1pbiwgc2NhbGVNYXgsIGZvdW5kSW5jciwgZm91bmRTcGFjZSkgPT4ge1xuXHRcdFx0bGV0IHNwbGl0cyA9IFtdO1xuXHRcdFx0bGV0IGlzWXIgPSBmb3VuZEluY3IgPj0geTtcblx0XHRcdGxldCBpc01vID0gZm91bmRJbmNyID49IG1vICYmIGZvdW5kSW5jciA8IHk7XG5cblx0XHRcdC8vIGdldCB0aGUgdGltZXpvbmUtYWRqdXN0ZWQgZGF0ZVxuXHRcdFx0bGV0IG1pbkRhdGUgPSB0ekRhdGUoc2NhbGVNaW4pO1xuXHRcdFx0bGV0IG1pbkRhdGVUcyA9IHJvdW5kRGVjKG1pbkRhdGUgKiBtcywgMyk7XG5cblx0XHRcdC8vIGdldCB0cyBvZiAxMmFtICh0aGlzIGxhbmRzIHVzIGF0IG9yIGJlZm9yZSB0aGUgb3JpZ2luYWwgc2NhbGVNaW4pXG5cdFx0XHRsZXQgbWluTWluID0gbWtEYXRlKG1pbkRhdGUuZ2V0RnVsbFllYXIoKSwgaXNZciA/IDAgOiBtaW5EYXRlLmdldE1vbnRoKCksIGlzTW8gfHwgaXNZciA/IDEgOiBtaW5EYXRlLmdldERhdGUoKSk7XG5cdFx0XHRsZXQgbWluTWluVHMgPSByb3VuZERlYyhtaW5NaW4gKiBtcywgMyk7XG5cblx0XHRcdGlmIChpc01vIHx8IGlzWXIpIHtcblx0XHRcdFx0bGV0IG1vSW5jciA9IGlzTW8gPyBmb3VuZEluY3IgLyBtbyA6IDA7XG5cdFx0XHRcdGxldCB5ckluY3IgPSBpc1lyID8gZm91bmRJbmNyIC8geSAgOiAwO1xuXHRcdFx0Ly9cdGxldCB0ek9mZnNldCA9IHNjYWxlTWluIC0gbWluRGF0ZVRzO1x0XHQvLyBuZWVkZWQ/XG5cdFx0XHRcdGxldCBzcGxpdCA9IG1pbkRhdGVUcyA9PSBtaW5NaW5UcyA/IG1pbkRhdGVUcyA6IHJvdW5kRGVjKG1rRGF0ZShtaW5NaW4uZ2V0RnVsbFllYXIoKSArIHlySW5jciwgbWluTWluLmdldE1vbnRoKCkgKyBtb0luY3IsIDEpICogbXMsIDMpO1xuXHRcdFx0XHRsZXQgc3BsaXREYXRlID0gbmV3IERhdGUocm91bmQoc3BsaXQgLyBtcykpO1xuXHRcdFx0XHRsZXQgYmFzZVllYXIgPSBzcGxpdERhdGUuZ2V0RnVsbFllYXIoKTtcblx0XHRcdFx0bGV0IGJhc2VNb250aCA9IHNwbGl0RGF0ZS5nZXRNb250aCgpO1xuXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBzcGxpdCA8PSBzY2FsZU1heDsgaSsrKSB7XG5cdFx0XHRcdFx0bGV0IG5leHQgPSBta0RhdGUoYmFzZVllYXIgKyB5ckluY3IgKiBpLCBiYXNlTW9udGggKyBtb0luY3IgKiBpLCAxKTtcblx0XHRcdFx0XHRsZXQgb2ZmcyA9IG5leHQgLSB0ekRhdGUocm91bmREZWMobmV4dCAqIG1zLCAzKSk7XG5cblx0XHRcdFx0XHRzcGxpdCA9IHJvdW5kRGVjKCgrbmV4dCArIG9mZnMpICogbXMsIDMpO1xuXG5cdFx0XHRcdFx0aWYgKHNwbGl0IDw9IHNjYWxlTWF4KVxuXHRcdFx0XHRcdFx0c3BsaXRzLnB1c2goc3BsaXQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0bGV0IGluY3IwID0gZm91bmRJbmNyID49IGQgPyBkIDogZm91bmRJbmNyO1xuXHRcdFx0XHRsZXQgdHpPZmZzZXQgPSBmbG9vcihzY2FsZU1pbikgLSBmbG9vcihtaW5EYXRlVHMpO1xuXHRcdFx0XHRsZXQgc3BsaXQgPSBtaW5NaW5UcyArIHR6T2Zmc2V0ICsgaW5jclJvdW5kVXAobWluRGF0ZVRzIC0gbWluTWluVHMsIGluY3IwKTtcblx0XHRcdFx0c3BsaXRzLnB1c2goc3BsaXQpO1xuXG5cdFx0XHRcdGxldCBkYXRlMCA9IHR6RGF0ZShzcGxpdCk7XG5cblx0XHRcdFx0bGV0IHByZXZIb3VyID0gZGF0ZTAuZ2V0SG91cnMoKSArIChkYXRlMC5nZXRNaW51dGVzKCkgLyBtKSArIChkYXRlMC5nZXRTZWNvbmRzKCkgLyBoKTtcblx0XHRcdFx0bGV0IGluY3JIb3VycyA9IGZvdW5kSW5jciAvIGg7XG5cblx0XHRcdFx0bGV0IG1pblNwYWNlID0gc2VsZi5heGVzW2F4aXNJZHhdLl9zcGFjZTtcblx0XHRcdFx0bGV0IHBjdFNwYWNlID0gZm91bmRTcGFjZSAvIG1pblNwYWNlO1xuXG5cdFx0XHRcdHdoaWxlICgxKSB7XG5cdFx0XHRcdFx0c3BsaXQgPSByb3VuZERlYyhzcGxpdCArIGZvdW5kSW5jciwgbXMgPT0gMSA/IDAgOiAzKTtcblxuXHRcdFx0XHRcdGlmIChzcGxpdCA+IHNjYWxlTWF4KVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRpZiAoaW5jckhvdXJzID4gMSkge1xuXHRcdFx0XHRcdFx0bGV0IGV4cGVjdGVkSG91ciA9IGZsb29yKHJvdW5kRGVjKHByZXZIb3VyICsgaW5jckhvdXJzLCA2KSkgJSAyNDtcblx0XHRcdFx0XHRcdGxldCBzcGxpdERhdGUgPSB0ekRhdGUoc3BsaXQpO1xuXHRcdFx0XHRcdFx0bGV0IGFjdHVhbEhvdXIgPSBzcGxpdERhdGUuZ2V0SG91cnMoKTtcblxuXHRcdFx0XHRcdFx0bGV0IGRzdFNoaWZ0ID0gYWN0dWFsSG91ciAtIGV4cGVjdGVkSG91cjtcblxuXHRcdFx0XHRcdFx0aWYgKGRzdFNoaWZ0ID4gMSlcblx0XHRcdFx0XHRcdFx0ZHN0U2hpZnQgPSAtMTtcblxuXHRcdFx0XHRcdFx0c3BsaXQgLT0gZHN0U2hpZnQgKiBoO1xuXG5cdFx0XHRcdFx0XHRwcmV2SG91ciA9IChwcmV2SG91ciArIGluY3JIb3VycykgJSAyNDtcblxuXHRcdFx0XHRcdFx0Ly8gYWRkIGEgdGljayBvbmx5IGlmIGl0J3MgZnVydGhlciB0aGFuIDcwJSBvZiB0aGUgbWluIGFsbG93ZWQgbGFiZWwgc3BhY2luZ1xuXHRcdFx0XHRcdFx0bGV0IHByZXZTcGxpdCA9IHNwbGl0c1tzcGxpdHMubGVuZ3RoIC0gMV07XG5cdFx0XHRcdFx0XHRsZXQgcGN0SW5jciA9IHJvdW5kRGVjKChzcGxpdCAtIHByZXZTcGxpdCkgLyBmb3VuZEluY3IsIDMpO1xuXG5cdFx0XHRcdFx0XHRpZiAocGN0SW5jciAqIHBjdFNwYWNlID49IC43KVxuXHRcdFx0XHRcdFx0XHRzcGxpdHMucHVzaChzcGxpdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdHNwbGl0cy5wdXNoKHNwbGl0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc3BsaXRzO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBbXG5cdFx0dGltZUluY3JzLFxuXHRcdF90aW1lQXhpc1N0YW1wcyxcblx0XHR0aW1lQXhpc1NwbGl0cyxcblx0XTtcbn1cblxuY29uc3QgWyB0aW1lSW5jcnNNcywgX3RpbWVBeGlzU3RhbXBzTXMsIHRpbWVBeGlzU3BsaXRzTXMgXSA9IGdlblRpbWVTdHVmZnMoMSk7XG5jb25zdCBbIHRpbWVJbmNyc1MsICBfdGltZUF4aXNTdGFtcHNTLCAgdGltZUF4aXNTcGxpdHNTICBdID0gZ2VuVGltZVN0dWZmcygxZS0zKTtcblxuLy8gYmFzZSAyXG5nZW5JbmNycygyLCAtNTMsIDUzLCBbMV0pO1xuXG4vKlxuY29uc29sZS5sb2coe1xuXHRkZWNJbmNycyxcblx0b25lSW5jcnMsXG5cdHdob2xlSW5jcnMsXG5cdG51bUluY3JzLFxuXHR0aW1lSW5jcnMsXG5cdGZpeGVkRGVjLFxufSk7XG4qL1xuXG5mdW5jdGlvbiB0aW1lQXhpc1N0YW1wcyhzdGFtcENmZywgZm10RGF0ZSkge1xuXHRyZXR1cm4gc3RhbXBDZmcubWFwKHMgPT4gcy5tYXAoKHYsIGkpID0+XG5cdFx0aSA9PSAwIHx8IGkgPT0gOCB8fCB2ID09IG51bGwgPyB2IDogZm10RGF0ZShpID09IDEgfHwgc1s4XSA9PSAwID8gdiA6IHNbMV0gKyB2KVxuXHQpKTtcbn1cblxuLy8gVE9ETzogd2lsbCBuZWVkIHRvIGFjY2VwdCBzcGFjZXNbXSBhbmQgcHVsbCBpbmNyIGludG8gdGhlIGxvb3Agd2hlbiBncmlkIHdpbGwgYmUgbm9uLXVuaWZvcm0sIGVnIGZvciBsb2cgc2NhbGVzLlxuLy8gY3VycmVudGx5IHdlIGlnbm9yZSB0aGlzIGZvciBtb250aHMgc2luY2UgdGhleSdyZSAqbmVhcmx5KiB1bmlmb3JtIGFuZCB0aGUgYWRkZWQgY29tcGxleGl0eSBpcyBub3Qgd29ydGggaXRcbmZ1bmN0aW9uIHRpbWVBeGlzVmFscyh0ekRhdGUsIHN0YW1wcykge1xuXHRyZXR1cm4gKHNlbGYsIHNwbGl0cywgYXhpc0lkeCwgZm91bmRTcGFjZSwgZm91bmRJbmNyKSA9PiB7XG5cdFx0bGV0IHMgPSBzdGFtcHMuZmluZChzID0+IGZvdW5kSW5jciA+PSBzWzBdKSB8fCBzdGFtcHNbc3RhbXBzLmxlbmd0aCAtIDFdO1xuXG5cdFx0Ly8gdGhlc2UgdHJhY2sgYm91bmRhcmllcyB3aGVuIGEgZnVsbCBsYWJlbCBpcyBuZWVkZWQgYWdhaW5cblx0XHRsZXQgcHJldlllYXI7XG5cdFx0bGV0IHByZXZNbnRoO1xuXHRcdGxldCBwcmV2RGF0ZTtcblx0XHRsZXQgcHJldkhvdXI7XG5cdFx0bGV0IHByZXZNaW5zO1xuXHRcdGxldCBwcmV2U2VjcztcblxuXHRcdHJldHVybiBzcGxpdHMubWFwKHNwbGl0ID0+IHtcblx0XHRcdGxldCBkYXRlID0gdHpEYXRlKHNwbGl0KTtcblxuXHRcdFx0bGV0IG5ld1llYXIgPSBkYXRlLmdldEZ1bGxZZWFyKCk7XG5cdFx0XHRsZXQgbmV3TW50aCA9IGRhdGUuZ2V0TW9udGgoKTtcblx0XHRcdGxldCBuZXdEYXRlID0gZGF0ZS5nZXREYXRlKCk7XG5cdFx0XHRsZXQgbmV3SG91ciA9IGRhdGUuZ2V0SG91cnMoKTtcblx0XHRcdGxldCBuZXdNaW5zID0gZGF0ZS5nZXRNaW51dGVzKCk7XG5cdFx0XHRsZXQgbmV3U2VjcyA9IGRhdGUuZ2V0U2Vjb25kcygpO1xuXG5cdFx0XHRsZXQgc3RhbXAgPSAoXG5cdFx0XHRcdG5ld1llYXIgIT0gcHJldlllYXIgJiYgc1syXSB8fFxuXHRcdFx0XHRuZXdNbnRoICE9IHByZXZNbnRoICYmIHNbM10gfHxcblx0XHRcdFx0bmV3RGF0ZSAhPSBwcmV2RGF0ZSAmJiBzWzRdIHx8XG5cdFx0XHRcdG5ld0hvdXIgIT0gcHJldkhvdXIgJiYgc1s1XSB8fFxuXHRcdFx0XHRuZXdNaW5zICE9IHByZXZNaW5zICYmIHNbNl0gfHxcblx0XHRcdFx0bmV3U2VjcyAhPSBwcmV2U2VjcyAmJiBzWzddIHx8XG5cdFx0XHRcdCAgICAgICAgICAgICAgICAgICAgICAgc1sxXVxuXHRcdFx0KTtcblxuXHRcdFx0cHJldlllYXIgPSBuZXdZZWFyO1xuXHRcdFx0cHJldk1udGggPSBuZXdNbnRoO1xuXHRcdFx0cHJldkRhdGUgPSBuZXdEYXRlO1xuXHRcdFx0cHJldkhvdXIgPSBuZXdIb3VyO1xuXHRcdFx0cHJldk1pbnMgPSBuZXdNaW5zO1xuXHRcdFx0cHJldlNlY3MgPSBuZXdTZWNzO1xuXG5cdFx0XHRyZXR1cm4gc3RhbXAoZGF0ZSk7XG5cdFx0fSk7XG5cdH1cbn1cblxuLy8gZm9yIHdoZW4gYXhpcy52YWx1ZXMgaXMgZGVmaW5lZCBhcyBhIHN0YXRpYyBmbXREYXRlIHRlbXBsYXRlIHN0cmluZ1xuZnVuY3Rpb24gdGltZUF4aXNWYWwodHpEYXRlLCBkYXRlVHBsKSB7XG5cdGxldCBzdGFtcCA9IGZtdERhdGUoZGF0ZVRwbCk7XG5cdHJldHVybiAoc2VsZiwgc3BsaXRzLCBheGlzSWR4LCBmb3VuZFNwYWNlLCBmb3VuZEluY3IpID0+IHNwbGl0cy5tYXAoc3BsaXQgPT4gc3RhbXAodHpEYXRlKHNwbGl0KSkpO1xufVxuXG5mdW5jdGlvbiBta0RhdGUoeSwgbSwgZCkge1xuXHRyZXR1cm4gbmV3IERhdGUoeSwgbSwgZCk7XG59XG5cbmZ1bmN0aW9uIHRpbWVTZXJpZXNTdGFtcChzdGFtcENmZywgZm10RGF0ZSkge1xuXHRyZXR1cm4gZm10RGF0ZShzdGFtcENmZyk7XG59XG5jb25zdCBfdGltZVNlcmllc1N0YW1wID0gJ3tZWVlZfS17TU19LXtERH0ge2h9OnttbX17YWF9JztcblxuZnVuY3Rpb24gdGltZVNlcmllc1ZhbCh0ekRhdGUsIHN0YW1wKSB7XG5cdHJldHVybiAoc2VsZiwgdmFsKSA9PiBzdGFtcCh0ekRhdGUodmFsKSk7XG59XG5cbmZ1bmN0aW9uIGxlZ2VuZFN0cm9rZShzZWxmLCBzZXJpZXNJZHgpIHtcblx0bGV0IHMgPSBzZWxmLnNlcmllc1tzZXJpZXNJZHhdO1xuXHRyZXR1cm4gcy53aWR0aCA/IHMuc3Ryb2tlKHNlbGYsIHNlcmllc0lkeCkgOiBzLnBvaW50cy53aWR0aCA/IHMucG9pbnRzLnN0cm9rZShzZWxmLCBzZXJpZXNJZHgpIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gbGVnZW5kRmlsbChzZWxmLCBzZXJpZXNJZHgpIHtcblx0cmV0dXJuIHNlbGYuc2VyaWVzW3Nlcmllc0lkeF0uZmlsbChzZWxmLCBzZXJpZXNJZHgpO1xufVxuXG5jb25zdCBsZWdlbmRPcHRzID0ge1xuXHRzaG93OiB0cnVlLFxuXHRsaXZlOiB0cnVlLFxuXHRpc29sYXRlOiBmYWxzZSxcblx0bWFya2Vyczoge1xuXHRcdHNob3c6IHRydWUsXG5cdFx0d2lkdGg6IDIsXG5cdFx0c3Ryb2tlOiBsZWdlbmRTdHJva2UsXG5cdFx0ZmlsbDogbGVnZW5kRmlsbCxcblx0XHRkYXNoOiBcInNvbGlkXCIsXG5cdH0sXG5cdGlkeDogbnVsbCxcblx0dmFsdWVzOiBbXSxcbn07XG5cbmZ1bmN0aW9uIGN1cnNvclBvaW50U2hvdyhzZWxmLCBzaSkge1xuXHRsZXQgbyA9IHNlbGYuY3Vyc29yLnBvaW50cztcblxuXHRsZXQgcHQgPSBwbGFjZURpdigpO1xuXG5cdGxldCBzdHJva2UgPSBvLnN0cm9rZShzZWxmLCBzaSk7XG5cdGxldCBmaWxsID0gby5maWxsKHNlbGYsIHNpKTtcblxuXHRwdC5zdHlsZS5iYWNrZ3JvdW5kID0gZmlsbCB8fCBzdHJva2U7XG5cblx0bGV0IHNpemUgPSBvLnNpemUoc2VsZiwgc2kpO1xuXHRsZXQgd2lkdGggPSBvLndpZHRoKHNlbGYsIHNpLCBzaXplKTtcblxuXHRpZiAod2lkdGgpXG5cdFx0cHQuc3R5bGUuYm9yZGVyID0gd2lkdGggKyBcInB4IHNvbGlkIFwiICsgc3Ryb2tlO1xuXG5cdGxldCBtYXIgPSBzaXplIC8gLTI7XG5cblx0c2V0U3R5bGVQeChwdCwgV0lEVEgsIHNpemUpO1xuXHRzZXRTdHlsZVB4KHB0LCBIRUlHSFQsIHNpemUpO1xuXHRzZXRTdHlsZVB4KHB0LCBcIm1hcmdpbkxlZnRcIiwgbWFyKTtcblx0c2V0U3R5bGVQeChwdCwgXCJtYXJnaW5Ub3BcIiwgbWFyKTtcblxuXHRyZXR1cm4gcHQ7XG59XG5cbmZ1bmN0aW9uIGN1cnNvclBvaW50RmlsbChzZWxmLCBzaSkge1xuXHRsZXQgcyA9IHNlbGYuc2VyaWVzW3NpXTtcblx0cmV0dXJuIHMuc3Ryb2tlKHNlbGYsIHNpKTtcbn1cblxuZnVuY3Rpb24gY3Vyc29yUG9pbnRTdHJva2Uoc2VsZiwgc2kpIHtcblx0bGV0IHMgPSBzZWxmLnNlcmllc1tzaV07XG5cdHJldHVybiBzLnN0cm9rZShzZWxmLCBzaSk7XG59XG5cbmZ1bmN0aW9uIGN1cnNvclBvaW50U2l6ZShzZWxmLCBzaSkge1xuXHRsZXQgcyA9IHNlbGYuc2VyaWVzW3NpXTtcblx0cmV0dXJuIHB0RGlhKHMud2lkdGgsIDEpO1xufVxuXG5mdW5jdGlvbiBkYXRhSWR4KHNlbGYsIHNlcmllc0lkeCwgY3Vyc29ySWR4KSB7XG5cdHJldHVybiBjdXJzb3JJZHg7XG59XG5cbmNvbnN0IG1vdmVUdXBsZSA9IFswLDBdO1xuXG5mdW5jdGlvbiBjdXJzb3JNb3ZlKHNlbGYsIG1vdXNlTGVmdDEsIG1vdXNlVG9wMSkge1xuXHRtb3ZlVHVwbGVbMF0gPSBtb3VzZUxlZnQxO1xuXHRtb3ZlVHVwbGVbMV0gPSBtb3VzZVRvcDE7XG5cdHJldHVybiBtb3ZlVHVwbGU7XG59XG5cbmZ1bmN0aW9uIGZpbHRCdG4wKHNlbGYsIHRhcmcsIGhhbmRsZSkge1xuXHRyZXR1cm4gZSA9PiB7XG5cdFx0ZS5idXR0b24gPT0gMCAmJiBoYW5kbGUoZSk7XG5cdH07XG59XG5cbmZ1bmN0aW9uIHBhc3NUaHJ1KHNlbGYsIHRhcmcsIGhhbmRsZSkge1xuXHRyZXR1cm4gaGFuZGxlO1xufVxuXG5jb25zdCBjdXJzb3JPcHRzID0ge1xuXHRzaG93OiB0cnVlLFxuXHR4OiB0cnVlLFxuXHR5OiB0cnVlLFxuXHRsb2NrOiBmYWxzZSxcblx0bW92ZTogY3Vyc29yTW92ZSxcblx0cG9pbnRzOiB7XG5cdFx0c2hvdzogICBjdXJzb3JQb2ludFNob3csXG5cdFx0c2l6ZTogICBjdXJzb3JQb2ludFNpemUsXG5cdFx0d2lkdGg6ICAwLFxuXHRcdHN0cm9rZTogY3Vyc29yUG9pbnRTdHJva2UsXG5cdFx0ZmlsbDogICBjdXJzb3JQb2ludEZpbGwsXG5cdH0sXG5cblx0YmluZDoge1xuXHRcdG1vdXNlZG93bjogICBmaWx0QnRuMCxcblx0XHRtb3VzZXVwOiAgICAgZmlsdEJ0bjAsXG5cdFx0Y2xpY2s6ICAgICAgIGZpbHRCdG4wLFxuXHRcdGRibGNsaWNrOiAgICBmaWx0QnRuMCxcblxuXHRcdG1vdXNlbW92ZTogICBwYXNzVGhydSxcblx0XHRtb3VzZWxlYXZlOiAgcGFzc1RocnUsXG5cdFx0bW91c2VlbnRlcjogIHBhc3NUaHJ1LFxuXHR9LFxuXG5cdGRyYWc6IHtcblx0XHRzZXRTY2FsZTogdHJ1ZSxcblx0XHR4OiB0cnVlLFxuXHRcdHk6IGZhbHNlLFxuXHRcdGRpc3Q6IDAsXG5cdFx0dW5pOiBudWxsLFxuXHRcdF94OiBmYWxzZSxcblx0XHRfeTogZmFsc2UsXG5cdH0sXG5cblx0Zm9jdXM6IHtcblx0XHRwcm94OiAtMSxcblx0fSxcblxuXHRsZWZ0OiAtMTAsXG5cdHRvcDogLTEwLFxuXHRpZHg6IG51bGwsXG5cdGRhdGFJZHgsXG59O1xuXG5jb25zdCBncmlkID0ge1xuXHRzaG93OiB0cnVlLFxuXHRzdHJva2U6IFwicmdiYSgwLDAsMCwwLjA3KVwiLFxuXHR3aWR0aDogMixcbi8vXHRkYXNoOiBbXSxcblx0ZmlsdGVyOiByZXRBcmcxLFxufTtcblxuY29uc3QgdGlja3MgPSBhc3NpZ24oe30sIGdyaWQsIHtzaXplOiAxMH0pO1xuXG5jb25zdCBmb250ICAgICAgPSAnMTJweCBzeXN0ZW0tdWksIC1hcHBsZS1zeXN0ZW0sIFwiU2Vnb2UgVUlcIiwgUm9ib3RvLCBcIkhlbHZldGljYSBOZXVlXCIsIEFyaWFsLCBcIk5vdG8gU2Fuc1wiLCBzYW5zLXNlcmlmLCBcIkFwcGxlIENvbG9yIEVtb2ppXCIsIFwiU2Vnb2UgVUkgRW1vamlcIiwgXCJTZWdvZSBVSSBTeW1ib2xcIiwgXCJOb3RvIENvbG9yIEVtb2ppXCInO1xuY29uc3QgbGFiZWxGb250ID0gXCJib2xkIFwiICsgZm9udDtcbmNvbnN0IGxpbmVNdWx0ID0gMS41O1x0XHQvLyBmb250LXNpemUgbXVsdGlwbGllclxuXG5jb25zdCB4QXhpc09wdHMgPSB7XG5cdHNob3c6IHRydWUsXG5cdHNjYWxlOiBcInhcIixcblx0c3Ryb2tlOiBoZXhCbGFjayxcblx0c3BhY2U6IDUwLFxuXHRnYXA6IDUsXG5cdHNpemU6IDUwLFxuXHRsYWJlbFNpemU6IDMwLFxuXHRsYWJlbEZvbnQsXG5cdHNpZGU6IDIsXG4vL1x0Y2xhc3M6IFwieC12YWxzXCIsXG4vL1x0aW5jcnM6IHRpbWVJbmNycyxcbi8vXHR2YWx1ZXM6IHRpbWVWYWxzLFxuLy9cdGZpbHRlcjogcmV0QXJnMSxcblx0Z3JpZCxcblx0dGlja3MsXG5cdGZvbnQsXG5cdHJvdGF0ZTogMCxcbn07XG5cbmNvbnN0IG51bVNlcmllc0xhYmVsID0gXCJWYWx1ZVwiO1xuY29uc3QgdGltZVNlcmllc0xhYmVsID0gXCJUaW1lXCI7XG5cbmNvbnN0IHhTZXJpZXNPcHRzID0ge1xuXHRzaG93OiB0cnVlLFxuXHRzY2FsZTogXCJ4XCIsXG5cdGF1dG86IGZhbHNlLFxuXHRzb3J0ZWQ6IDEsXG4vL1x0bGFiZWw6IFwiVGltZVwiLFxuLy9cdHZhbHVlOiB2ID0+IHN0YW1wKG5ldyBEYXRlKHYgKiAxZTMpKSxcblxuXHQvLyBpbnRlcm5hbCBjYWNoZXNcblx0bWluOiBpbmYsXG5cdG1heDogLWluZixcblx0aWR4czogW10sXG59O1xuXG5mdW5jdGlvbiBudW1BeGlzVmFscyhzZWxmLCBzcGxpdHMsIGF4aXNJZHgsIGZvdW5kU3BhY2UsIGZvdW5kSW5jcikge1xuXHRyZXR1cm4gc3BsaXRzLm1hcCh2ID0+IHYgPT0gbnVsbCA/IFwiXCIgOiBmbXROdW0odikpO1xufVxuXG5mdW5jdGlvbiBudW1BeGlzU3BsaXRzKHNlbGYsIGF4aXNJZHgsIHNjYWxlTWluLCBzY2FsZU1heCwgZm91bmRJbmNyLCBmb3VuZFNwYWNlLCBmb3JjZU1pbikge1xuXHRsZXQgc3BsaXRzID0gW107XG5cblx0bGV0IG51bURlYyA9IGZpeGVkRGVjLmdldChmb3VuZEluY3IpIHx8IDA7XG5cblx0c2NhbGVNaW4gPSBmb3JjZU1pbiA/IHNjYWxlTWluIDogcm91bmREZWMoaW5jclJvdW5kVXAoc2NhbGVNaW4sIGZvdW5kSW5jciksIG51bURlYyk7XG5cblx0Zm9yIChsZXQgdmFsID0gc2NhbGVNaW47IHZhbCA8PSBzY2FsZU1heDsgdmFsID0gcm91bmREZWModmFsICsgZm91bmRJbmNyLCBudW1EZWMpKVxuXHRcdHNwbGl0cy5wdXNoKE9iamVjdC5pcyh2YWwsIC0wKSA/IDAgOiB2YWwpO1x0XHQvLyBjb2FsZXNjZXMgLTBcblxuXHRyZXR1cm4gc3BsaXRzO1xufVxuXG4vLyB0aGlzIGRvZXNudCB3b3JrIGZvciBzaW4sIHdoaWNoIG5lZWRzIHRvIGNvbWUgb2ZmIGZyb20gMCBpbmRlcGVuZGVudGx5IGluIHBvcyBhbmQgbmVnIGRpcnNcbmZ1bmN0aW9uIGxvZ0F4aXNTcGxpdHMoc2VsZiwgYXhpc0lkeCwgc2NhbGVNaW4sIHNjYWxlTWF4LCBmb3VuZEluY3IsIGZvdW5kU3BhY2UsIGZvcmNlTWluKSB7XG5cdGNvbnN0IHNwbGl0cyA9IFtdO1xuXG5cdGNvbnN0IGxvZ0Jhc2UgPSBzZWxmLnNjYWxlc1tzZWxmLmF4ZXNbYXhpc0lkeF0uc2NhbGVdLmxvZztcblxuXHRjb25zdCBsb2dGbiA9IGxvZ0Jhc2UgPT0gMTAgPyBsb2cxMCA6IGxvZzI7XG5cblx0Y29uc3QgZXhwID0gZmxvb3IobG9nRm4oc2NhbGVNaW4pKTtcblxuXHRmb3VuZEluY3IgPSBwb3cobG9nQmFzZSwgZXhwKTtcblxuXHRpZiAoZXhwIDwgMClcblx0XHRmb3VuZEluY3IgPSByb3VuZERlYyhmb3VuZEluY3IsIC1leHApO1xuXG5cdGxldCBzcGxpdCA9IHNjYWxlTWluO1xuXG5cdGRvIHtcblx0XHRzcGxpdHMucHVzaChzcGxpdCk7XG5cdFx0c3BsaXQgPSByb3VuZERlYyhzcGxpdCArIGZvdW5kSW5jciwgZml4ZWREZWMuZ2V0KGZvdW5kSW5jcikpO1xuXG5cdFx0aWYgKHNwbGl0ID49IGZvdW5kSW5jciAqIGxvZ0Jhc2UpXG5cdFx0XHRmb3VuZEluY3IgPSBzcGxpdDtcblxuXHR9IHdoaWxlIChzcGxpdCA8PSBzY2FsZU1heCk7XG5cblx0cmV0dXJuIHNwbGl0cztcbn1cblxuZnVuY3Rpb24gYXNpbmhBeGlzU3BsaXRzKHNlbGYsIGF4aXNJZHgsIHNjYWxlTWluLCBzY2FsZU1heCwgZm91bmRJbmNyLCBmb3VuZFNwYWNlLCBmb3JjZU1pbikge1xuXHRsZXQgc2MgPSBzZWxmLnNjYWxlc1tzZWxmLmF4ZXNbYXhpc0lkeF0uc2NhbGVdO1xuXG5cdGxldCBsaW50aHJlc2ggPSBzYy5hc2luaDtcblxuXHRsZXQgcG9zU3BsaXRzID0gc2NhbGVNYXggPiBsaW50aHJlc2ggPyBsb2dBeGlzU3BsaXRzKHNlbGYsIGF4aXNJZHgsIG1heChsaW50aHJlc2gsIHNjYWxlTWluKSwgc2NhbGVNYXgsIGZvdW5kSW5jcikgOiBbbGludGhyZXNoXTtcblx0bGV0IHplcm8gPSBzY2FsZU1heCA+PSAwICYmIHNjYWxlTWluIDw9IDAgPyBbMF0gOiBbXTtcblx0bGV0IG5lZ1NwbGl0cyA9IHNjYWxlTWluIDwgLWxpbnRocmVzaCA/IGxvZ0F4aXNTcGxpdHMoc2VsZiwgYXhpc0lkeCwgbWF4KGxpbnRocmVzaCwgLXNjYWxlTWF4KSwgLXNjYWxlTWluLCBmb3VuZEluY3IpOiBbbGludGhyZXNoXTtcblxuXHRyZXR1cm4gbmVnU3BsaXRzLnJldmVyc2UoKS5tYXAodiA9PiAtdikuY29uY2F0KHplcm8sIHBvc1NwbGl0cyk7XG59XG5cbmNvbnN0IFJFX0FMTCAgID0gLy4vO1xuY29uc3QgUkVfMTIzNTcgPSAvWzEyMzU3XS87XG5jb25zdCBSRV8xMjUgICA9IC9bMTI1XS87XG5jb25zdCBSRV8xICAgICA9IC8xLztcblxuZnVuY3Rpb24gbG9nQXhpc1ZhbHNGaWx0KHNlbGYsIHNwbGl0cywgYXhpc0lkeCwgZm91bmRTcGFjZSwgZm91bmRJbmNyKSB7XG5cdGxldCBheGlzID0gc2VsZi5heGVzW2F4aXNJZHhdO1xuXHRsZXQgc2NhbGVLZXkgPSBheGlzLnNjYWxlO1xuXHRsZXQgc2MgPSBzZWxmLnNjYWxlc1tzY2FsZUtleV07XG5cblx0aWYgKHNjLmRpc3RyID09IDMgJiYgc2MubG9nID09IDIpXG5cdFx0cmV0dXJuIHNwbGl0cztcblxuXHRsZXQgdmFsVG9Qb3MgPSBzZWxmLnZhbFRvUG9zO1xuXG5cdGxldCBtaW5TcGFjZSA9IGF4aXMuX3NwYWNlO1xuXG5cdGxldCBfMTAgPSB2YWxUb1BvcygxMCwgc2NhbGVLZXkpO1xuXG5cdGxldCByZSA9IChcblx0XHR2YWxUb1Bvcyg5LCBzY2FsZUtleSkgLSBfMTAgPj0gbWluU3BhY2UgPyBSRV9BTEwgOlxuXHRcdHZhbFRvUG9zKDcsIHNjYWxlS2V5KSAtIF8xMCA+PSBtaW5TcGFjZSA/IFJFXzEyMzU3IDpcblx0XHR2YWxUb1Bvcyg1LCBzY2FsZUtleSkgLSBfMTAgPj0gbWluU3BhY2UgPyBSRV8xMjUgOlxuXHRcdFJFXzFcblx0KTtcblxuXHRyZXR1cm4gc3BsaXRzLm1hcCh2ID0+ICgoc2MuZGlzdHIgPT0gNCAmJiB2ID09IDApIHx8IHJlLnRlc3QodikpID8gdiA6IG51bGwpO1xufVxuXG5mdW5jdGlvbiBudW1TZXJpZXNWYWwoc2VsZiwgdmFsKSB7XG5cdHJldHVybiB2YWwgPT0gbnVsbCA/IFwiXCIgOiBmbXROdW0odmFsKTtcbn1cblxuY29uc3QgeUF4aXNPcHRzID0ge1xuXHRzaG93OiB0cnVlLFxuXHRzY2FsZTogXCJ5XCIsXG5cdHN0cm9rZTogaGV4QmxhY2ssXG5cdHNwYWNlOiAzMCxcblx0Z2FwOiA1LFxuXHRzaXplOiA1MCxcblx0bGFiZWxTaXplOiAzMCxcblx0bGFiZWxGb250LFxuXHRzaWRlOiAzLFxuLy9cdGNsYXNzOiBcInktdmFsc1wiLFxuLy9cdGluY3JzOiBudW1JbmNycyxcbi8vXHR2YWx1ZXM6ICh2YWxzLCBzcGFjZSkgPT4gdmFscyxcbi8vXHRmaWx0ZXI6IHJldEFyZzEsXG5cdGdyaWQsXG5cdHRpY2tzLFxuXHRmb250LFxuXHRyb3RhdGU6IDAsXG59O1xuXG4vLyB0YWtlcyBzdHJva2Ugd2lkdGhcbmZ1bmN0aW9uIHB0RGlhKHdpZHRoLCBtdWx0KSB7XG5cdGxldCBkaWEgPSAzICsgKHdpZHRoIHx8IDEpICogMjtcblx0cmV0dXJuIHJvdW5kRGVjKGRpYSAqIG11bHQsIDMpO1xufVxuXG5mdW5jdGlvbiBzZXJpZXNQb2ludHMoc2VsZiwgc2kpIHtcblx0bGV0IHsgc2NhbGUsIGlkeHMgfSA9IHNlbGYuc2VyaWVzWzBdO1xuXHRsZXQgeERhdGEgPSBzZWxmLmRhdGFbMF07XG5cdGxldCBwMCA9IHNlbGYudmFsVG9Qb3MoeERhdGFbaWR4c1swXV0sIHNjYWxlLCB0cnVlKTtcblx0bGV0IHAxID0gc2VsZi52YWxUb1Bvcyh4RGF0YVtpZHhzWzFdXSwgc2NhbGUsIHRydWUpO1xuXHRsZXQgZGltID0gYWJzKHAxIC0gcDApO1xuXG5cdGxldCBzID0gc2VsZi5zZXJpZXNbc2ldO1xuLy9cdGNvbnN0IGRpYSA9IHB0RGlhKHMud2lkdGgsIHB4UmF0aW8pO1xuXHRsZXQgbWF4UHRzID0gZGltIC8gKHMucG9pbnRzLnNwYWNlICogcHhSYXRpbyk7XG5cdHJldHVybiBpZHhzWzFdIC0gaWR4c1swXSA8PSBtYXhQdHM7XG59XG5cbmZ1bmN0aW9uIHNlcmllc0ZpbGxUbyhzZWxmLCBzZXJpZXNJZHgsIGRhdGFNaW4sIGRhdGFNYXgpIHtcblx0bGV0IHNjYWxlID0gc2VsZi5zY2FsZXNbc2VsZi5zZXJpZXNbc2VyaWVzSWR4XS5zY2FsZV07XG5cdGxldCBpc1VwcGVyQmFuZEVkZ2UgPSBzZWxmLmJhbmRzICYmIHNlbGYuYmFuZHMuc29tZShiID0+IGIuc2VyaWVzWzBdID09IHNlcmllc0lkeCk7XG5cdHJldHVybiBzY2FsZS5kaXN0ciA9PSAzIHx8IGlzVXBwZXJCYW5kRWRnZSA/IHNjYWxlLm1pbiA6IDA7XG59XG5cbmNvbnN0IHlTZXJpZXNPcHRzID0ge1xuXHRzY2FsZTogXCJ5XCIsXG5cdGF1dG86IHRydWUsXG5cdHNvcnRlZDogMCxcblx0c2hvdzogdHJ1ZSxcblx0YmFuZDogZmFsc2UsXG5cdHNwYW5HYXBzOiBmYWxzZSxcblx0YWxwaGE6IDEsXG5cdHBvaW50czoge1xuXHRcdHNob3c6IHNlcmllc1BvaW50cyxcblx0Ly9cdHN0cm9rZTogXCIjMDAwXCIsXG5cdC8vXHRmaWxsOiBcIiNmZmZcIixcblx0Ly9cdHdpZHRoOiAxLFxuXHQvL1x0c2l6ZTogMTAsXG5cdH0sXG4vL1x0bGFiZWw6IFwiVmFsdWVcIixcbi8vXHR2YWx1ZTogdiA9PiB2LFxuXHR2YWx1ZXM6IG51bGwsXG5cblx0Ly8gaW50ZXJuYWwgY2FjaGVzXG5cdG1pbjogaW5mLFxuXHRtYXg6IC1pbmYsXG5cdGlkeHM6IFtdLFxuXG5cdHBhdGg6IG51bGwsXG5cdGNsaXA6IG51bGwsXG59O1xuXG5mdW5jdGlvbiBjbGFtcFNjYWxlKHNlbGYsIHZhbCwgc2NhbGVNaW4sIHNjYWxlTWF4LCBzY2FsZUtleSkge1xuLypcblx0aWYgKHZhbCA8IDApIHtcblx0XHRsZXQgY3NzSGd0ID0gc2VsZi5iYm94LmhlaWdodCAvIHB4UmF0aW87XG5cdFx0bGV0IGFic1BvcyA9IHNlbGYudmFsVG9Qb3MoYWJzKHZhbCksIHNjYWxlS2V5KTtcblx0XHRsZXQgZnJvbUJ0bSA9IGNzc0hndCAtIGFic1Bvcztcblx0XHRyZXR1cm4gc2VsZi5wb3NUb1ZhbChjc3NIZ3QgKyBmcm9tQnRtLCBzY2FsZUtleSk7XG5cdH1cbiovXG5cdHJldHVybiBzY2FsZU1pbiAvIDEwO1xufVxuXG5jb25zdCB4U2NhbGVPcHRzID0ge1xuXHR0aW1lOiBGRUFUX1RJTUUsXG5cdGF1dG86IHRydWUsXG5cdGRpc3RyOiAxLFxuXHRsb2c6IDEwLFxuXHRhc2luaDogMSxcblx0bWluOiBudWxsLFxuXHRtYXg6IG51bGwsXG5cdGRpcjogMSxcblx0b3JpOiAwLFxufTtcblxuY29uc3QgeVNjYWxlT3B0cyA9IGFzc2lnbih7fSwgeFNjYWxlT3B0cywge1xuXHR0aW1lOiBmYWxzZSxcblx0b3JpOiAxLFxufSk7XG5cbmNvbnN0IHN5bmNzID0ge307XG5cbmZ1bmN0aW9uIF9zeW5jKGtleSwgb3B0cykge1xuXHRsZXQgcyA9IHN5bmNzW2tleV07XG5cblx0aWYgKCFzKSB7XG5cdFx0cyA9IHtcblx0XHRcdGtleSxcblx0XHRcdHBsb3RzOiBbXSxcblx0XHRcdHN1YihwbG90KSB7XG5cdFx0XHRcdHMucGxvdHMucHVzaChwbG90KTtcblx0XHRcdH0sXG5cdFx0XHR1bnN1YihwbG90KSB7XG5cdFx0XHRcdHMucGxvdHMgPSBzLnBsb3RzLmZpbHRlcihjID0+IGMgIT0gcGxvdCk7XG5cdFx0XHR9LFxuXHRcdFx0cHViKHR5cGUsIHNlbGYsIHgsIHksIHcsIGgsIGkpIHtcblx0XHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogPCBzLnBsb3RzLmxlbmd0aDsgaisrKVxuXHRcdFx0XHRcdHMucGxvdHNbal0gIT0gc2VsZiAmJiBzLnBsb3RzW2pdLnB1Yih0eXBlLCBzZWxmLCB4LCB5LCB3LCBoLCBpKTtcblx0XHRcdH0sXG5cdFx0fTtcblxuXHRcdGlmIChrZXkgIT0gbnVsbClcblx0XHRcdHN5bmNzW2tleV0gPSBzO1xuXHR9XG5cblx0cmV0dXJuIHM7XG59XG5cbmNvbnN0IEJBTkRfQ0xJUF9GSUxMICAgPSAxIDw8IDA7XG5jb25zdCBCQU5EX0NMSVBfU1RST0tFID0gMSA8PCAxO1xuXG5mdW5jdGlvbiBvcmllbnQodSwgc2VyaWVzSWR4LCBjYikge1xuXHRjb25zdCBzZXJpZXMgPSB1LnNlcmllc1tzZXJpZXNJZHhdO1xuXHRjb25zdCBzY2FsZXMgPSB1LnNjYWxlcztcblx0Y29uc3QgYmJveCAgID0gdS5iYm94O1xuXHRjb25zdCBzY2FsZVggPSBzY2FsZXNbdS5zZXJpZXNbMF0uc2NhbGVdO1xuXG5cdGxldCBkeCA9IHUuX2RhdGFbMF0sXG5cdFx0ZHkgPSB1Ll9kYXRhW3Nlcmllc0lkeF0sXG5cdFx0c3ggPSBzY2FsZVgsXG5cdFx0c3kgPSBzY2FsZXNbc2VyaWVzLnNjYWxlXSxcblx0XHRsID0gYmJveC5sZWZ0LFxuXHRcdHQgPSBiYm94LnRvcCxcblx0XHR3ID0gYmJveC53aWR0aCxcblx0XHRoID0gYmJveC5oZWlnaHQsXG5cdFx0SCA9IHUudmFsVG9Qb3NILFxuXHRcdFYgPSB1LnZhbFRvUG9zVjtcblxuXHRyZXR1cm4gKHN4Lm9yaSA9PSAwXG5cdFx0PyBjYihcblx0XHRcdHNlcmllcyxcblx0XHRcdGR4LFxuXHRcdFx0ZHksXG5cdFx0XHRzeCxcblx0XHRcdHN5LFxuXHRcdFx0SCxcblx0XHRcdFYsXG5cdFx0XHRsLFxuXHRcdFx0dCxcblx0XHRcdHcsXG5cdFx0XHRoLFxuXHRcdFx0bW92ZVRvSCxcblx0XHRcdGxpbmVUb0gsXG5cdFx0XHRyZWN0SCxcblx0XHRcdGFyY0gsXG5cdFx0XHRiZXppZXJDdXJ2ZVRvSCxcblx0XHQpXG5cdFx0OiBjYihcblx0XHRcdHNlcmllcyxcblx0XHRcdGR4LFxuXHRcdFx0ZHksXG5cdFx0XHRzeCxcblx0XHRcdHN5LFxuXHRcdFx0Vixcblx0XHRcdEgsXG5cdFx0XHR0LFxuXHRcdFx0bCxcblx0XHRcdGgsXG5cdFx0XHR3LFxuXHRcdFx0bW92ZVRvVixcblx0XHRcdGxpbmVUb1YsXG5cdFx0XHRyZWN0Vixcblx0XHRcdGFyY1YsXG5cdFx0XHRiZXppZXJDdXJ2ZVRvVixcblx0XHQpXG5cdCk7XG59XG5cbi8vIGNyZWF0ZXMgaW52ZXJ0ZWQgYmFuZCBjbGlwIHBhdGggKHRvd2FyZHMgZnJvbSBzdHJva2UgcGF0aCAtPiB5TWF4KVxuZnVuY3Rpb24gY2xpcEJhbmRMaW5lKHNlbGYsIHNlcmllc0lkeCwgaWR4MCwgaWR4MSwgc3Ryb2tlUGF0aCkge1xuXHRyZXR1cm4gb3JpZW50KHNlbGYsIHNlcmllc0lkeCwgKHNlcmllcywgZGF0YVgsIGRhdGFZLCBzY2FsZVgsIHNjYWxlWSwgdmFsVG9Qb3NYLCB2YWxUb1Bvc1ksIHhPZmYsIHlPZmYsIHhEaW0sIHlEaW0pID0+IHtcblx0XHRjb25zdCBkaXIgPSBzY2FsZVguZGlyICogKHNjYWxlWC5vcmkgPT0gMCA/IDEgOiAtMSk7XG5cdFx0Y29uc3QgbGluZVRvID0gc2NhbGVYLm9yaSA9PSAwID8gbGluZVRvSCA6IGxpbmVUb1Y7XG5cblx0XHRsZXQgZnJJZHgsIHRvSWR4O1xuXG5cdFx0aWYgKGRpciA9PSAxKSB7XG5cdFx0XHRmcklkeCA9IGlkeDA7XG5cdFx0XHR0b0lkeCA9IGlkeDE7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0ZnJJZHggPSBpZHgxO1xuXHRcdFx0dG9JZHggPSBpZHgwO1xuXHRcdH1cblxuXHRcdC8vIHBhdGggc3RhcnRcblx0XHRsZXQgeDAgPSBpbmNyUm91bmQodmFsVG9Qb3NYKGRhdGFYW2ZySWR4XSwgc2NhbGVYLCB4RGltLCB4T2ZmKSwgMC41KTtcblx0XHRsZXQgeTAgPSBpbmNyUm91bmQodmFsVG9Qb3NZKGRhdGFZW2ZySWR4XSwgc2NhbGVZLCB5RGltLCB5T2ZmKSwgMC41KTtcblx0XHQvLyBwYXRoIGVuZCB4XG5cdFx0bGV0IHgxID0gaW5jclJvdW5kKHZhbFRvUG9zWChkYXRhWFt0b0lkeF0sIHNjYWxlWCwgeERpbSwgeE9mZiksIDAuNSk7XG5cdFx0Ly8gdXBwZXIgeSBsaW1pdFxuXHRcdGxldCB5TGltaXQgPSBpbmNyUm91bmQodmFsVG9Qb3NZKHNjYWxlWS5tYXgsIHNjYWxlWSwgeURpbSwgeU9mZiksIDAuNSk7XG5cblx0XHRsZXQgY2xpcCA9IG5ldyBQYXRoMkQoc3Ryb2tlUGF0aCk7XG5cblx0XHRsaW5lVG8oY2xpcCwgeDEsIHlMaW1pdCk7XG5cdFx0bGluZVRvKGNsaXAsIHgwLCB5TGltaXQpO1xuXHRcdGxpbmVUbyhjbGlwLCB4MCwgeTApO1xuXG5cdFx0cmV0dXJuIGNsaXA7XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBjbGlwR2FwcyhnYXBzLCBvcmksIHBsb3RMZnQsIHBsb3RUb3AsIHBsb3RXaWQsIHBsb3RIZ3QpIHtcblx0bGV0IGNsaXAgPSBudWxsO1xuXG5cdC8vIGNyZWF0ZSBjbGlwIHBhdGggKGludmVydCBnYXBzIGFuZCBub24tZ2Fwcylcblx0aWYgKGdhcHMubGVuZ3RoID4gMCkge1xuXHRcdGNsaXAgPSBuZXcgUGF0aDJEKCk7XG5cblx0XHRjb25zdCByZWN0ID0gb3JpID09IDAgPyByZWN0SCA6IHJlY3RWO1xuXG5cdFx0bGV0IHByZXZHYXBFbmQgPSBwbG90TGZ0O1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBnYXBzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRsZXQgZyA9IGdhcHNbaV07XG5cblx0XHRcdHJlY3QoY2xpcCwgcHJldkdhcEVuZCwgcGxvdFRvcCwgZ1swXSAtIHByZXZHYXBFbmQsIHBsb3RUb3AgKyBwbG90SGd0KTtcblxuXHRcdFx0cHJldkdhcEVuZCA9IGdbMV07XG5cdFx0fVxuXG5cdFx0cmVjdChjbGlwLCBwcmV2R2FwRW5kLCBwbG90VG9wLCBwbG90TGZ0ICsgcGxvdFdpZCAtIHByZXZHYXBFbmQsIHBsb3RUb3AgKyBwbG90SGd0KTtcblx0fVxuXG5cdHJldHVybiBjbGlwO1xufVxuXG5mdW5jdGlvbiBhZGRHYXAoZ2FwcywgZnJvbVgsIHRvWCkge1xuXHRpZiAodG9YID4gZnJvbVgpIHtcblx0XHRsZXQgcHJldkdhcCA9IGdhcHNbZ2Fwcy5sZW5ndGggLSAxXTtcblxuXHRcdGlmIChwcmV2R2FwICYmIHByZXZHYXBbMF0gPT0gZnJvbVgpXHRcdFx0Ly8gVE9ETzogZ2FwcyBtdXN0IGJlIGVuY29kZWQgYXQgc3Ryb2tlIHdpZHRocz9cblx0XHRcdHByZXZHYXBbMV0gPSB0b1g7XG5cdFx0ZWxzZVxuXHRcdFx0Z2Fwcy5wdXNoKFtmcm9tWCwgdG9YXSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gcHhSb3VuZEdlbihweEFsaWduKSB7XG5cdHJldHVybiBweEFsaWduID09IDAgPyByZXRBcmcwIDogcHhBbGlnbiA9PSAxID8gcm91bmQgOiB2ID0+IGluY3JSb3VuZCh2LCBweEFsaWduKTtcbn1cblxuLy8gb3JpZW50YXRpb24taW52ZXJ0aW5nIGNhbnZhcyBmdW5jdGlvbnNcbmZ1bmN0aW9uIG1vdmVUb0gocCwgeCwgeSkgeyBwLm1vdmVUbyh4LCB5KTsgfVxuZnVuY3Rpb24gbW92ZVRvVihwLCB5LCB4KSB7IHAubW92ZVRvKHgsIHkpOyB9XG5mdW5jdGlvbiBsaW5lVG9IKHAsIHgsIHkpIHsgcC5saW5lVG8oeCwgeSk7IH1cbmZ1bmN0aW9uIGxpbmVUb1YocCwgeSwgeCkgeyBwLmxpbmVUbyh4LCB5KTsgfVxuZnVuY3Rpb24gcmVjdEgocCwgeCwgeSwgdywgaCkgeyBwLnJlY3QoeCwgeSwgdywgaCk7IH1cbmZ1bmN0aW9uIHJlY3RWKHAsIHksIHgsIGgsIHcpIHsgcC5yZWN0KHgsIHksIHcsIGgpOyB9XG5mdW5jdGlvbiBhcmNIKHAsIHgsIHksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKSB7IHAuYXJjKHgsIHksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKTsgfVxuZnVuY3Rpb24gYXJjVihwLCB5LCB4LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSkgeyBwLmFyYyh4LCB5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSk7IH1cbmZ1bmN0aW9uIGJlemllckN1cnZlVG9IKHAsIGJwMXgsIGJwMXksIGJwMngsIGJwMnksIHAyeCwgcDJ5KSB7IHAuYmV6aWVyQ3VydmVUbyhicDF4LCBicDF5LCBicDJ4LCBicDJ5LCBwMngsIHAyeSk7IH1mdW5jdGlvbiBiZXppZXJDdXJ2ZVRvVihwLCBicDF5LCBicDF4LCBicDJ5LCBicDJ4LCBwMnksIHAyeCkgeyBwLmJlemllckN1cnZlVG8oYnAxeCwgYnAxeSwgYnAyeCwgYnAyeSwgcDJ4LCBwMnkpOyB9XG5cbmZ1bmN0aW9uIF9kcmF3QWNjKGxpbmVUbykge1xuXHRyZXR1cm4gKHN0cm9rZSwgYWNjWCwgbWluWSwgbWF4WSwgaW5ZLCBvdXRZKSA9PiB7XG5cdFx0aWYgKG1pblkgIT0gbWF4WSkge1xuXHRcdFx0aWYgKGluWSAhPSBtaW5ZICYmIG91dFkgIT0gbWluWSlcblx0XHRcdFx0bGluZVRvKHN0cm9rZSwgYWNjWCwgbWluWSk7XG5cdFx0XHRpZiAoaW5ZICE9IG1heFkgJiYgb3V0WSAhPSBtYXhZKVxuXHRcdFx0XHRsaW5lVG8oc3Ryb2tlLCBhY2NYLCBtYXhZKTtcblxuXHRcdFx0bGluZVRvKHN0cm9rZSwgYWNjWCwgb3V0WSk7XG5cdFx0fVxuXHR9O1xufVxuXG5jb25zdCBkcmF3QWNjSCA9IF9kcmF3QWNjKGxpbmVUb0gpO1xuY29uc3QgZHJhd0FjY1YgPSBfZHJhd0FjYyhsaW5lVG9WKTtcblxuZnVuY3Rpb24gbGluZWFyKCkge1xuXHRyZXR1cm4gKHUsIHNlcmllc0lkeCwgaWR4MCwgaWR4MSkgPT4ge1xuXHRcdHJldHVybiBvcmllbnQodSwgc2VyaWVzSWR4LCAoc2VyaWVzLCBkYXRhWCwgZGF0YVksIHNjYWxlWCwgc2NhbGVZLCB2YWxUb1Bvc1gsIHZhbFRvUG9zWSwgeE9mZiwgeU9mZiwgeERpbSwgeURpbSkgPT4ge1xuXHRcdFx0bGV0IHB4Um91bmQgPSBzZXJpZXMucHhSb3VuZDtcblxuXHRcdFx0bGV0IGxpbmVUbywgZHJhd0FjYztcblxuXHRcdFx0aWYgKHNjYWxlWC5vcmkgPT0gMCkge1xuXHRcdFx0XHRsaW5lVG8gPSBsaW5lVG9IO1xuXHRcdFx0XHRkcmF3QWNjID0gZHJhd0FjY0g7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0bGluZVRvID0gbGluZVRvVjtcblx0XHRcdFx0ZHJhd0FjYyA9IGRyYXdBY2NWO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBkaXIgPSBzY2FsZVguZGlyICogKHNjYWxlWC5vcmkgPT0gMCA/IDEgOiAtMSk7XG5cblx0XHRcdGNvbnN0IF9wYXRocyA9IHtzdHJva2U6IG5ldyBQYXRoMkQoKSwgZmlsbDogbnVsbCwgY2xpcDogbnVsbCwgYmFuZDogbnVsbCwgZmxhZ3M6IEJBTkRfQ0xJUF9GSUxMfTtcblx0XHRcdGNvbnN0IHN0cm9rZSA9IF9wYXRocy5zdHJva2U7XG5cblx0XHRcdGxldCBtaW5ZID0gaW5mLFxuXHRcdFx0XHRtYXhZID0gLWluZixcblx0XHRcdFx0aW5ZLCBvdXRZLCBvdXRYLCBkcmF3bkF0WDtcblxuXHRcdFx0bGV0IGdhcHMgPSBbXTtcblxuXHRcdFx0bGV0IGFjY1ggPSBweFJvdW5kKHZhbFRvUG9zWChkYXRhWFtkaXIgPT0gMSA/IGlkeDAgOiBpZHgxXSwgc2NhbGVYLCB4RGltLCB4T2ZmKSk7XG5cdFx0XHRsZXQgYWNjR2FwcyA9IGZhbHNlO1xuXG5cdFx0XHQvLyBkYXRhIGVkZ2VzXG5cdFx0XHRsZXQgbGZ0SWR4ID0gbm9uTnVsbElkeChkYXRhWSwgaWR4MCwgaWR4MSwgIDEgKiBkaXIpO1xuXHRcdFx0bGV0IHJndElkeCA9IG5vbk51bGxJZHgoZGF0YVksIGlkeDAsIGlkeDEsIC0xICogZGlyKTtcblx0XHRcdGxldCBsZnRYID0gaW5jclJvdW5kKHZhbFRvUG9zWChkYXRhWFtsZnRJZHhdLCBzY2FsZVgsIHhEaW0sIHhPZmYpLCAwLjUpO1xuXHRcdFx0bGV0IHJndFggPSBpbmNyUm91bmQodmFsVG9Qb3NYKGRhdGFYW3JndElkeF0sIHNjYWxlWCwgeERpbSwgeE9mZiksIDAuNSk7XG5cblx0XHRcdGlmIChsZnRYID4geE9mZilcblx0XHRcdFx0YWRkR2FwKGdhcHMsIHhPZmYsIGxmdFgpO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gZGlyID09IDEgPyBpZHgwIDogaWR4MTsgaSA+PSBpZHgwICYmIGkgPD0gaWR4MTsgaSArPSBkaXIpIHtcblx0XHRcdFx0bGV0IHggPSBweFJvdW5kKHZhbFRvUG9zWChkYXRhWFtpXSwgc2NhbGVYLCB4RGltLCB4T2ZmKSk7XG5cblx0XHRcdFx0aWYgKHggPT0gYWNjWCkge1xuXHRcdFx0XHRcdGlmIChkYXRhWVtpXSAhPSBudWxsKSB7XG5cdFx0XHRcdFx0XHRvdXRZID0gcHhSb3VuZCh2YWxUb1Bvc1koZGF0YVlbaV0sIHNjYWxlWSwgeURpbSwgeU9mZikpO1xuXG5cdFx0XHRcdFx0XHRpZiAobWluWSA9PSBpbmYpIHtcblx0XHRcdFx0XHRcdFx0bGluZVRvKHN0cm9rZSwgeCwgb3V0WSk7XG5cdFx0XHRcdFx0XHRcdGluWSA9IG91dFk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdG1pblkgPSBtaW4ob3V0WSwgbWluWSk7XG5cdFx0XHRcdFx0XHRtYXhZID0gbWF4KG91dFksIG1heFkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIGlmICghYWNjR2FwcyAmJiBkYXRhWVtpXSA9PT0gbnVsbClcblx0XHRcdFx0XHRcdGFjY0dhcHMgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGxldCBfYWRkR2FwID0gZmFsc2U7XG5cblx0XHRcdFx0XHRpZiAobWluWSAhPSBpbmYpIHtcblx0XHRcdFx0XHRcdGRyYXdBY2Moc3Ryb2tlLCBhY2NYLCBtaW5ZLCBtYXhZLCBpblksIG91dFkpO1xuXHRcdFx0XHRcdFx0b3V0WCA9IGRyYXduQXRYID0gYWNjWDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSBpZiAoYWNjR2Fwcykge1xuXHRcdFx0XHRcdFx0X2FkZEdhcCA9IHRydWU7XG5cdFx0XHRcdFx0XHRhY2NHYXBzID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKGRhdGFZW2ldICE9IG51bGwpIHtcblx0XHRcdFx0XHRcdG91dFkgPSBweFJvdW5kKHZhbFRvUG9zWShkYXRhWVtpXSwgc2NhbGVZLCB5RGltLCB5T2ZmKSk7XG5cdFx0XHRcdFx0XHRsaW5lVG8oc3Ryb2tlLCB4LCBvdXRZKTtcblx0XHRcdFx0XHRcdG1pblkgPSBtYXhZID0gaW5ZID0gb3V0WTtcblxuXHRcdFx0XHRcdFx0Ly8gcHJpb3IgcGl4ZWwgY2FuIGhhdmUgZGF0YSBidXQgc3RpbGwgc3RhcnQgYSBnYXAgaWYgZW5kcyB3aXRoIG51bGxcblx0XHRcdFx0XHRcdGlmICh4IC0gYWNjWCA+IDEgJiYgZGF0YVlbaSAtIGRpcl0gPT09IG51bGwpXG5cdFx0XHRcdFx0XHRcdF9hZGRHYXAgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdG1pblkgPSBpbmY7XG5cdFx0XHRcdFx0XHRtYXhZID0gLWluZjtcblxuXHRcdFx0XHRcdFx0aWYgKCFhY2NHYXBzICYmIGRhdGFZW2ldID09PSBudWxsKVxuXHRcdFx0XHRcdFx0XHRhY2NHYXBzID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRfYWRkR2FwICYmIGFkZEdhcChnYXBzLCBvdXRYLCB4KTtcblxuXHRcdFx0XHRcdGFjY1ggPSB4O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChtaW5ZICE9IGluZiAmJiBtaW5ZICE9IG1heFkgJiYgZHJhd25BdFggIT0gYWNjWClcblx0XHRcdFx0ZHJhd0FjYyhzdHJva2UsIGFjY1gsIG1pblksIG1heFksIGluWSwgb3V0WSk7XG5cblx0XHRcdGlmIChyZ3RYIDwgeE9mZiArIHhEaW0pXG5cdFx0XHRcdGFkZEdhcChnYXBzLCByZ3RYLCB4T2ZmICsgeERpbSk7XG5cblx0XHRcdGlmIChzZXJpZXMuZmlsbCAhPSBudWxsKSB7XG5cdFx0XHRcdGxldCBmaWxsID0gX3BhdGhzLmZpbGwgPSBuZXcgUGF0aDJEKHN0cm9rZSk7XG5cblx0XHRcdFx0bGV0IGZpbGxUbyA9IHB4Um91bmQodmFsVG9Qb3NZKHNlcmllcy5maWxsVG8odSwgc2VyaWVzSWR4LCBzZXJpZXMubWluLCBzZXJpZXMubWF4KSwgc2NhbGVZLCB5RGltLCB5T2ZmKSk7XG5cblx0XHRcdFx0bGluZVRvKGZpbGwsIHJndFgsIGZpbGxUbyk7XG5cdFx0XHRcdGxpbmVUbyhmaWxsLCBsZnRYLCBmaWxsVG8pO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIXNlcmllcy5zcGFuR2Fwcylcblx0XHRcdFx0X3BhdGhzLmNsaXAgPSBjbGlwR2FwcyhnYXBzLCBzY2FsZVgub3JpLCB4T2ZmLCB5T2ZmLCB4RGltLCB5RGltKTtcblxuXHRcdFx0aWYgKHUuYmFuZHMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHQvLyBBRERMIE9QVDogb25seSBjcmVhdGUgYmFuZCBjbGlwcyBmb3Igc2VyaWVzIHRoYXQgYXJlIGJhbmQgbG93ZXIgZWRnZXNcblx0XHRcdFx0Ly8gaWYgKGIuc2VyaWVzWzFdID09IGkgJiYgX3BhdGhzLmJhbmQgPT0gbnVsbClcblx0XHRcdFx0X3BhdGhzLmJhbmQgPSBjbGlwQmFuZExpbmUodSwgc2VyaWVzSWR4LCBpZHgwLCBpZHgxLCBzdHJva2UpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gX3BhdGhzO1xuXHRcdH0pO1xuXHR9O1xufVxuXG5mdW5jdGlvbiBzdGVwcGVkKG9wdHMpIHtcblx0Y29uc3QgYWxpZ24gPSBpZk51bGwob3B0cy5hbGlnbiwgMSk7XG5cdC8vIHdoZXRoZXIgdG8gZHJhdyBhc2NlbmRlcnMvZGVzY2VuZGVycyBhdCBudWxsL2dhcCBib25kYXJpZXNcblx0Y29uc3QgYXNjRGVzYyA9IGlmTnVsbChvcHRzLmFzY0Rlc2MsIGZhbHNlKTtcblxuXHRyZXR1cm4gKHUsIHNlcmllc0lkeCwgaWR4MCwgaWR4MSkgPT4ge1xuXHRcdHJldHVybiBvcmllbnQodSwgc2VyaWVzSWR4LCAoc2VyaWVzLCBkYXRhWCwgZGF0YVksIHNjYWxlWCwgc2NhbGVZLCB2YWxUb1Bvc1gsIHZhbFRvUG9zWSwgeE9mZiwgeU9mZiwgeERpbSwgeURpbSkgPT4ge1xuXHRcdFx0bGV0IHB4Um91bmQgPSBzZXJpZXMucHhSb3VuZDtcblxuXHRcdFx0bGV0IGxpbmVUbyA9IHNjYWxlWC5vcmkgPT0gMCA/IGxpbmVUb0ggOiBsaW5lVG9WO1xuXG5cdFx0XHRjb25zdCBfcGF0aHMgPSB7c3Ryb2tlOiBuZXcgUGF0aDJEKCksIGZpbGw6IG51bGwsIGNsaXA6IG51bGwsIGJhbmQ6IG51bGwsIGZsYWdzOiBCQU5EX0NMSVBfRklMTH07XG5cdFx0XHRjb25zdCBzdHJva2UgPSBfcGF0aHMuc3Ryb2tlO1xuXG5cdFx0XHRjb25zdCBfZGlyID0gMSAqIHNjYWxlWC5kaXIgKiAoc2NhbGVYLm9yaSA9PSAwID8gMSA6IC0xKTtcblxuXHRcdFx0aWR4MCA9IG5vbk51bGxJZHgoZGF0YVksIGlkeDAsIGlkeDEsICAxKTtcblx0XHRcdGlkeDEgPSBub25OdWxsSWR4KGRhdGFZLCBpZHgwLCBpZHgxLCAtMSk7XG5cblx0XHRcdGxldCBnYXBzID0gW107XG5cdFx0XHRsZXQgaW5HYXAgPSBmYWxzZTtcblx0XHRcdGxldCBwcmV2WVBvcyAgPSBweFJvdW5kKHZhbFRvUG9zWShkYXRhWVtfZGlyID09IDEgPyBpZHgwIDogaWR4MV0sIHNjYWxlWSwgeURpbSwgeU9mZikpO1xuXHRcdFx0bGV0IGZpcnN0WFBvcyA9IHB4Um91bmQodmFsVG9Qb3NYKGRhdGFYW19kaXIgPT0gMSA/IGlkeDAgOiBpZHgxXSwgc2NhbGVYLCB4RGltLCB4T2ZmKSk7XG5cdFx0XHRsZXQgcHJldlhQb3MgPSBmaXJzdFhQb3M7XG5cblx0XHRcdGxpbmVUbyhzdHJva2UsIGZpcnN0WFBvcywgcHJldllQb3MpO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gX2RpciA9PSAxID8gaWR4MCA6IGlkeDE7IGkgPj0gaWR4MCAmJiBpIDw9IGlkeDE7IGkgKz0gX2Rpcikge1xuXHRcdFx0XHRsZXQgeVZhbDEgPSBkYXRhWVtpXTtcblxuXHRcdFx0XHRsZXQgeDEgPSBweFJvdW5kKHZhbFRvUG9zWChkYXRhWFtpXSwgc2NhbGVYLCB4RGltLCB4T2ZmKSk7XG5cblx0XHRcdFx0aWYgKHlWYWwxID09IG51bGwpIHtcblx0XHRcdFx0XHRpZiAoeVZhbDEgPT09IG51bGwpIHtcblx0XHRcdFx0XHRcdGFkZEdhcChnYXBzLCBwcmV2WFBvcywgeDEpO1xuXHRcdFx0XHRcdFx0aW5HYXAgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGxldCB5MSA9IHB4Um91bmQodmFsVG9Qb3NZKHlWYWwxLCBzY2FsZVksIHlEaW0sIHlPZmYpKTtcblxuXHRcdFx0XHRpZiAoaW5HYXApIHtcblx0XHRcdFx0XHRhZGRHYXAoZ2FwcywgcHJldlhQb3MsIHgxKTtcblxuXHRcdFx0XHRcdC8vIGRvbid0IGNsaXAgdmVydGljYWwgZXh0ZW5kZXJzXG5cdFx0XHRcdFx0aWYgKHByZXZZUG9zICE9IHkxKSB7XG5cdFx0XHRcdFx0XHRsZXQgaGFsZlN0cm9rZSA9IChzZXJpZXMud2lkdGggKiBweFJhdGlvKSAvIDI7XG5cblx0XHRcdFx0XHRcdGxldCBsYXN0R2FwID0gZ2Fwc1tnYXBzLmxlbmd0aCAtIDFdO1xuXG5cdFx0XHRcdFx0XHRsYXN0R2FwWzBdICs9IChhc2NEZXNjIHx8IGFsaWduID09ICAxKSA/IGhhbGZTdHJva2UgOiAtaGFsZlN0cm9rZTtcblx0XHRcdFx0XHRcdGxhc3RHYXBbMV0gLT0gKGFzY0Rlc2MgfHwgYWxpZ24gPT0gLTEpID8gaGFsZlN0cm9rZSA6IC1oYWxmU3Ryb2tlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGluR2FwID0gZmFsc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoYWxpZ24gPT0gMSlcblx0XHRcdFx0XHRsaW5lVG8oc3Ryb2tlLCB4MSwgcHJldllQb3MpO1xuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0bGluZVRvKHN0cm9rZSwgcHJldlhQb3MsIHkxKTtcblxuXHRcdFx0XHRsaW5lVG8oc3Ryb2tlLCB4MSwgeTEpO1xuXG5cdFx0XHRcdHByZXZZUG9zID0geTE7XG5cdFx0XHRcdHByZXZYUG9zID0geDE7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChzZXJpZXMuZmlsbCAhPSBudWxsKSB7XG5cdFx0XHRcdGxldCBmaWxsID0gX3BhdGhzLmZpbGwgPSBuZXcgUGF0aDJEKHN0cm9rZSk7XG5cblx0XHRcdFx0bGV0IGZpbGxUbyA9IHNlcmllcy5maWxsVG8odSwgc2VyaWVzSWR4LCBzZXJpZXMubWluLCBzZXJpZXMubWF4KTtcblx0XHRcdFx0bGV0IG1pblkgPSBweFJvdW5kKHZhbFRvUG9zWShmaWxsVG8sIHNjYWxlWSwgeURpbSwgeU9mZikpO1xuXG5cdFx0XHRcdGxpbmVUbyhmaWxsLCBwcmV2WFBvcywgbWluWSk7XG5cdFx0XHRcdGxpbmVUbyhmaWxsLCBmaXJzdFhQb3MsIG1pblkpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIXNlcmllcy5zcGFuR2Fwcylcblx0XHRcdFx0X3BhdGhzLmNsaXAgPSBjbGlwR2FwcyhnYXBzLCBzY2FsZVgub3JpLCB4T2ZmLCB5T2ZmLCB4RGltLCB5RGltKTtcblxuXHRcdFx0aWYgKHUuYmFuZHMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHQvLyBBRERMIE9QVDogb25seSBjcmVhdGUgYmFuZCBjbGlwcyBmb3Igc2VyaWVzIHRoYXQgYXJlIGJhbmQgbG93ZXIgZWRnZXNcblx0XHRcdFx0Ly8gaWYgKGIuc2VyaWVzWzFdID09IGkgJiYgX3BhdGhzLmJhbmQgPT0gbnVsbClcblx0XHRcdFx0X3BhdGhzLmJhbmQgPSBjbGlwQmFuZExpbmUodSwgc2VyaWVzSWR4LCBpZHgwLCBpZHgxLCBzdHJva2UpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gX3BhdGhzO1xuXHRcdH0pO1xuXHR9O1xufVxuXG5mdW5jdGlvbiBiYXJzKG9wdHMpIHtcblx0b3B0cyA9IG9wdHMgfHwgRU1QVFlfT0JKO1xuXHRjb25zdCBzaXplID0gaWZOdWxsKG9wdHMuc2l6ZSwgWzAuNiwgaW5mXSk7XG5cdGNvbnN0IGFsaWduID0gb3B0cy5hbGlnbiB8fCAwO1xuXHRjb25zdCBleHRyYUdhcCA9IChvcHRzLmdhcCB8fCAwKSAqIHB4UmF0aW87XG5cblx0Y29uc3QgZ2FwRmFjdG9yID0gMSAtIHNpemVbMF07XG5cdGNvbnN0IG1heFdpZHRoICA9IGlmTnVsbChzaXplWzFdLCBpbmYpICogcHhSYXRpbztcblxuXHRyZXR1cm4gKHUsIHNlcmllc0lkeCwgaWR4MCwgaWR4MSkgPT4ge1xuXHRcdHJldHVybiBvcmllbnQodSwgc2VyaWVzSWR4LCAoc2VyaWVzLCBkYXRhWCwgZGF0YVksIHNjYWxlWCwgc2NhbGVZLCB2YWxUb1Bvc1gsIHZhbFRvUG9zWSwgeE9mZiwgeU9mZiwgeERpbSwgeURpbSkgPT4ge1xuXHRcdFx0bGV0IHB4Um91bmQgPSBzZXJpZXMucHhSb3VuZDtcblxuXHRcdFx0Y29uc3QgX2RpciA9IHNjYWxlWC5kaXIgKiAoc2NhbGVYLm9yaSA9PSAwID8gMSA6IC0xKTtcblxuXHRcdFx0bGV0IHJlY3QgPSBzY2FsZVgub3JpID09IDAgPyByZWN0SCA6IHJlY3RWO1xuXG5cdFx0XHRsZXQgY29sV2lkID0geERpbTtcblxuXHRcdFx0aWYgKGRhdGFYLmxlbmd0aCA+IDEpIHtcblx0XHRcdFx0Ly8gc2NhbiBmdWxsIGRhdGFzZXQgZm9yIHNtYWxsZXN0IGFkamFjZW50IGRlbHRhXG5cdFx0XHRcdC8vIHdpbGwgbm90IHdvcmsgcHJvcGVybHkgZm9yIG5vbi1saW5lYXIgeCBzY2FsZXMsIHNpbmNlIGRvZXMgbm90IGRvIGV4cGVuc2l2ZSB2YWxUb1Bvc1ggY2FsY3MgdGlsbCBlbmRcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDEsIG1pbkRlbHRhID0gSW5maW5pdHk7IGkgPCBkYXRhWC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGxldCBkZWx0YSA9IGFicyhkYXRhWFtpXSAtIGRhdGFYW2ktMV0pO1xuXG5cdFx0XHRcdFx0aWYgKGRlbHRhIDwgbWluRGVsdGEpIHtcblx0XHRcdFx0XHRcdG1pbkRlbHRhID0gZGVsdGE7XG5cdFx0XHRcdFx0XHRjb2xXaWQgPSBhYnModmFsVG9Qb3NYKGRhdGFYW2ldLCBzY2FsZVgsIHhEaW0sIHhPZmYpIC0gdmFsVG9Qb3NYKGRhdGFYW2ktMV0sIHNjYWxlWCwgeERpbSwgeE9mZikpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRsZXQgZ2FwV2lkID0gY29sV2lkICogZ2FwRmFjdG9yO1xuXG5cdFx0XHRsZXQgZmlsbFRvWSA9IHNlcmllcy5maWxsVG8odSwgc2VyaWVzSWR4LCBzZXJpZXMubWluLCBzZXJpZXMubWF4KTtcblxuXHRcdFx0bGV0IHkwUG9zID0gdmFsVG9Qb3NZKGZpbGxUb1ksIHNjYWxlWSwgeURpbSwgeU9mZik7XG5cblx0XHRcdGxldCBzdHJva2VXaWR0aCA9IHB4Um91bmQoc2VyaWVzLndpZHRoICogcHhSYXRpbyk7XG5cblx0XHRcdGxldCBiYXJXaWQgPSBweFJvdW5kKG1pbihtYXhXaWR0aCwgY29sV2lkIC0gZ2FwV2lkKSAtIHN0cm9rZVdpZHRoIC0gZXh0cmFHYXApO1xuXG5cdFx0XHRjb25zdCB4U2hpZnQgPSAoYWxpZ24gPT0gMCA/IGJhcldpZCAvIDIgOiBhbGlnbiA9PSBfZGlyID8gMCA6IGJhcldpZCkgLSBhbGlnbiAqIF9kaXIgKiBleHRyYUdhcCAvIDI7XG5cblx0XHRcdGNvbnN0IF9wYXRocyA9IHtzdHJva2U6IG5ldyBQYXRoMkQoKSwgZmlsbDogbnVsbCwgY2xpcDogbnVsbCwgYmFuZDogbnVsbCwgZmxhZ3M6IEJBTkRfQ0xJUF9GSUxMIHwgQkFORF9DTElQX1NUUk9LRX07XG5cblx0XHRcdGNvbnN0IGhhc0JhbmRzID0gdS5iYW5kcy5sZW5ndGggPiAwO1xuXHRcdFx0bGV0IHlMaW1pdDtcblxuXHRcdFx0aWYgKGhhc0JhbmRzKSB7XG5cdFx0XHRcdC8vIEFEREwgT1BUOiBvbmx5IGNyZWF0ZSBiYW5kIGNsaXBzIGZvciBzZXJpZXMgdGhhdCBhcmUgYmFuZCBsb3dlciBlZGdlc1xuXHRcdFx0XHQvLyBpZiAoYi5zZXJpZXNbMV0gPT0gaSAmJiBfcGF0aHMuYmFuZCA9PSBudWxsKVxuXHRcdFx0XHRfcGF0aHMuYmFuZCA9IG5ldyBQYXRoMkQoKTtcblx0XHRcdFx0eUxpbWl0ID0gaW5jclJvdW5kKHZhbFRvUG9zWShzY2FsZVkubWF4LCBzY2FsZVksIHlEaW0sIHlPZmYpLCAwLjUpO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBzdHJva2UgPSBfcGF0aHMuc3Ryb2tlO1xuXHRcdFx0Y29uc3QgYmFuZCA9IF9wYXRocy5iYW5kO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gX2RpciA9PSAxID8gaWR4MCA6IGlkeDE7IGkgPj0gaWR4MCAmJiBpIDw9IGlkeDE7IGkgKz0gX2Rpcikge1xuXHRcdFx0XHRsZXQgeVZhbCA9IGRhdGFZW2ldO1xuXG5cdFx0XHRcdC8vIGludGVycG9sYXRlIHVwd2FyZHMgYmFuZCBjbGlwc1xuXHRcdFx0XHRpZiAoeVZhbCA9PSBudWxsKSB7XG5cdFx0XHRcdFx0aWYgKGhhc0JhbmRzKSB7XG5cdFx0XHRcdFx0XHQvLyBzaW1wbGUsIGJ1dCBpbmVmZmljaWVudCBiaS1kaXJlY3RpbmFsIGxpbmVhciBzY2FucyBvbiBlYWNoIGl0ZXJhdGlvblxuXHRcdFx0XHRcdFx0bGV0IHByZXZOb25OdWxsID0gbm9uTnVsbElkeChkYXRhWSwgX2RpciA9PSAxID8gaWR4MCA6IGlkeDEsIGksIC1fZGlyKTtcblx0XHRcdFx0XHRcdGxldCBuZXh0Tm9uTnVsbCA9IG5vbk51bGxJZHgoZGF0YVksIGksIF9kaXIgPT0gMSA/IGlkeDEgOiBpZHgwLCAgX2Rpcik7XG5cblx0XHRcdFx0XHRcdGxldCBwcmV2VmFsID0gZGF0YVlbcHJldk5vbk51bGxdO1xuXHRcdFx0XHRcdFx0bGV0IG5leHRWYWwgPSBkYXRhWVtuZXh0Tm9uTnVsbF07XG5cblx0XHRcdFx0XHRcdHlWYWwgPSBwcmV2VmFsICsgKGkgLSBwcmV2Tm9uTnVsbCkgLyAobmV4dE5vbk51bGwgLSBwcmV2Tm9uTnVsbCkgKiAobmV4dFZhbCAtIHByZXZWYWwpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGxldCB4VmFsID0gc2NhbGVYLmRpc3RyID09IDIgPyBpIDogZGF0YVhbaV07XG5cblx0XHRcdFx0Ly8gVE9ETzogYWxsIHhQb3MgY2FuIGJlIHByZS1jb21wdXRlZCBvbmNlIGZvciBhbGwgc2VyaWVzIGluIGFsaWduZWQgc2V0XG5cdFx0XHRcdGxldCB4UG9zID0gdmFsVG9Qb3NYKHhWYWwsIHNjYWxlWCwgeERpbSwgeE9mZik7XG5cdFx0XHRcdGxldCB5UG9zID0gdmFsVG9Qb3NZKHlWYWwsIHNjYWxlWSwgeURpbSwgeU9mZik7XG5cblx0XHRcdFx0bGV0IGxmdCA9IHB4Um91bmQoeFBvcyAtIHhTaGlmdCk7XG5cdFx0XHRcdGxldCBidG0gPSBweFJvdW5kKG1heCh5UG9zLCB5MFBvcykpO1xuXHRcdFx0XHRsZXQgdG9wID0gcHhSb3VuZChtaW4oeVBvcywgeTBQb3MpKTtcblx0XHRcdFx0bGV0IGJhckhndCA9IGJ0bSAtIHRvcDtcblxuXHRcdFx0XHRkYXRhWVtpXSAhPSBudWxsICYmIHJlY3Qoc3Ryb2tlLCBsZnQsIHRvcCwgYmFyV2lkLCBiYXJIZ3QpO1xuXG5cdFx0XHRcdGlmIChoYXNCYW5kcykge1xuXHRcdFx0XHRcdGJ0bSA9IHRvcDtcblx0XHRcdFx0XHR0b3AgPSB5TGltaXQ7XG5cdFx0XHRcdFx0YmFySGd0ID0gYnRtIC0gdG9wO1xuXHRcdFx0XHRcdHJlY3QoYmFuZCwgbGZ0LCB0b3AsIGJhcldpZCwgYmFySGd0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoc2VyaWVzLmZpbGwgIT0gbnVsbClcblx0XHRcdFx0X3BhdGhzLmZpbGwgPSBuZXcgUGF0aDJEKHN0cm9rZSk7XG5cblx0XHRcdHJldHVybiBfcGF0aHM7XG5cdFx0fSk7XG5cdH07XG59XG5cbmZ1bmN0aW9uIHNwbGluZUludGVycChpbnRlcnAsIG9wdHMpIHtcblx0cmV0dXJuICh1LCBzZXJpZXNJZHgsIGlkeDAsIGlkeDEpID0+IHtcblx0XHRyZXR1cm4gb3JpZW50KHUsIHNlcmllc0lkeCwgKHNlcmllcywgZGF0YVgsIGRhdGFZLCBzY2FsZVgsIHNjYWxlWSwgdmFsVG9Qb3NYLCB2YWxUb1Bvc1ksIHhPZmYsIHlPZmYsIHhEaW0sIHlEaW0pID0+IHtcblx0XHRcdGxldCBweFJvdW5kID0gc2VyaWVzLnB4Um91bmQ7XG5cblx0XHRcdGxldCBtb3ZlVG8sIGJlemllckN1cnZlVG8sIGxpbmVUbztcblxuXHRcdFx0aWYgKHNjYWxlWC5vcmkgPT0gMCkge1xuXHRcdFx0XHRtb3ZlVG8gPSBtb3ZlVG9IO1xuXHRcdFx0XHRsaW5lVG8gPSBsaW5lVG9IO1xuXHRcdFx0XHRiZXppZXJDdXJ2ZVRvID0gYmV6aWVyQ3VydmVUb0g7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0bW92ZVRvID0gbW92ZVRvVjtcblx0XHRcdFx0bGluZVRvID0gbGluZVRvVjtcblx0XHRcdFx0YmV6aWVyQ3VydmVUbyA9IGJlemllckN1cnZlVG9WO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBfZGlyID0gMSAqIHNjYWxlWC5kaXIgKiAoc2NhbGVYLm9yaSA9PSAwID8gMSA6IC0xKTtcblxuXHRcdFx0aWR4MCA9IG5vbk51bGxJZHgoZGF0YVksIGlkeDAsIGlkeDEsICAxKTtcblx0XHRcdGlkeDEgPSBub25OdWxsSWR4KGRhdGFZLCBpZHgwLCBpZHgxLCAtMSk7XG5cblx0XHRcdGxldCBnYXBzID0gW107XG5cdFx0XHRsZXQgaW5HYXAgPSBmYWxzZTtcblx0XHRcdGxldCBmaXJzdFhQb3MgPSBweFJvdW5kKHZhbFRvUG9zWChkYXRhWFtfZGlyID09IDEgPyBpZHgwIDogaWR4MV0sIHNjYWxlWCwgeERpbSwgeE9mZikpO1xuXHRcdFx0bGV0IHByZXZYUG9zID0gZmlyc3RYUG9zO1xuXG5cdFx0XHRsZXQgeENvb3JkcyA9IFtdO1xuXHRcdFx0bGV0IHlDb29yZHMgPSBbXTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IF9kaXIgPT0gMSA/IGlkeDAgOiBpZHgxOyBpID49IGlkeDAgJiYgaSA8PSBpZHgxOyBpICs9IF9kaXIpIHtcblx0XHRcdFx0bGV0IHlWYWwgPSBkYXRhWVtpXTtcblx0XHRcdFx0bGV0IHhWYWwgPSBkYXRhWFtpXTtcblx0XHRcdFx0bGV0IHhQb3MgPSB2YWxUb1Bvc1goeFZhbCwgc2NhbGVYLCB4RGltLCB4T2ZmKTtcblxuXHRcdFx0XHRpZiAoeVZhbCA9PSBudWxsKSB7XG5cdFx0XHRcdFx0aWYgKHlWYWwgPT09IG51bGwpIHtcblx0XHRcdFx0XHRcdGFkZEdhcChnYXBzLCBwcmV2WFBvcywgeFBvcyk7XG5cdFx0XHRcdFx0XHRpbkdhcCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGlmIChpbkdhcCkge1xuXHRcdFx0XHRcdFx0YWRkR2FwKGdhcHMsIHByZXZYUG9zLCB4UG9zKTtcblx0XHRcdFx0XHRcdGluR2FwID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0eENvb3Jkcy5wdXNoKChwcmV2WFBvcyA9IHhQb3MpKTtcblx0XHRcdFx0XHR5Q29vcmRzLnB1c2godmFsVG9Qb3NZKGRhdGFZW2ldLCBzY2FsZVksIHlEaW0sIHlPZmYpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBfcGF0aHMgPSB7c3Ryb2tlOiBpbnRlcnAoeENvb3JkcywgeUNvb3JkcywgbW92ZVRvLCBsaW5lVG8sIGJlemllckN1cnZlVG8sIHB4Um91bmQpLCBmaWxsOiBudWxsLCBjbGlwOiBudWxsLCBiYW5kOiBudWxsLCBmbGFnczogQkFORF9DTElQX0ZJTEx9O1xuXHRcdFx0Y29uc3Qgc3Ryb2tlID0gX3BhdGhzLnN0cm9rZTtcblxuXHRcdFx0aWYgKHNlcmllcy5maWxsICE9IG51bGwgJiYgc3Ryb2tlICE9IG51bGwpIHtcblx0XHRcdFx0bGV0IGZpbGwgPSBfcGF0aHMuZmlsbCA9IG5ldyBQYXRoMkQoc3Ryb2tlKTtcblxuXHRcdFx0XHRsZXQgZmlsbFRvID0gc2VyaWVzLmZpbGxUbyh1LCBzZXJpZXNJZHgsIHNlcmllcy5taW4sIHNlcmllcy5tYXgpO1xuXHRcdFx0XHRsZXQgbWluWSA9IHB4Um91bmQodmFsVG9Qb3NZKGZpbGxUbywgc2NhbGVZLCB5RGltLCB5T2ZmKSk7XG5cblx0XHRcdFx0bGluZVRvKGZpbGwsIHByZXZYUG9zLCBtaW5ZKTtcblx0XHRcdFx0bGluZVRvKGZpbGwsIGZpcnN0WFBvcywgbWluWSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghc2VyaWVzLnNwYW5HYXBzKVxuXHRcdFx0XHRfcGF0aHMuY2xpcCA9IGNsaXBHYXBzKGdhcHMsIHNjYWxlWC5vcmksIHhPZmYsIHlPZmYsIHhEaW0sIHlEaW0pO1xuXG5cdFx0XHRpZiAodS5iYW5kcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdC8vIEFEREwgT1BUOiBvbmx5IGNyZWF0ZSBiYW5kIGNsaXBzIGZvciBzZXJpZXMgdGhhdCBhcmUgYmFuZCBsb3dlciBlZGdlc1xuXHRcdFx0XHQvLyBpZiAoYi5zZXJpZXNbMV0gPT0gaSAmJiBfcGF0aHMuYmFuZCA9PSBudWxsKVxuXHRcdFx0XHRfcGF0aHMuYmFuZCA9IGNsaXBCYW5kTGluZSh1LCBzZXJpZXNJZHgsIGlkeDAsIGlkeDEsIHN0cm9rZSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBfcGF0aHM7XG5cblx0XHRcdC8vICBpZiBGRUFUX1BBVEhTOiBmYWxzZSBpbiByb2xsdXAuY29uZmlnLmpzXG5cdFx0XHQvL1x0dS5jdHguc2F2ZSgpO1xuXHRcdFx0Ly9cdHUuY3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0Ly9cdHUuY3R4LnJlY3QodS5iYm94LmxlZnQsIHUuYmJveC50b3AsIHUuYmJveC53aWR0aCwgdS5iYm94LmhlaWdodCk7XG5cdFx0XHQvL1x0dS5jdHguY2xpcCgpO1xuXHRcdFx0Ly9cdHUuY3R4LnN0cm9rZVN0eWxlID0gdS5zZXJpZXNbc2lkeF0uc3Ryb2tlO1xuXHRcdFx0Ly9cdHUuY3R4LnN0cm9rZShzdHJva2UpO1xuXHRcdFx0Ly9cdHUuY3R4LmZpbGxTdHlsZSA9IHUuc2VyaWVzW3NpZHhdLmZpbGw7XG5cdFx0XHQvL1x0dS5jdHguZmlsbChmaWxsKTtcblx0XHRcdC8vXHR1LmN0eC5yZXN0b3JlKCk7XG5cdFx0XHQvL1x0cmV0dXJuIG51bGw7XG5cdFx0fSk7XG5cdH07XG59XG5cbmZ1bmN0aW9uIG1vbm90b25lQ3ViaWMob3B0cykge1xuXHRyZXR1cm4gc3BsaW5lSW50ZXJwKF9tb25vdG9uZUN1YmljKTtcbn1cblxuLy8gTW9ub3RvbmUgQ3ViaWMgU3BsaW5lIGludGVycG9sYXRpb24sIGFkYXB0ZWQgZnJvbSB0aGUgQ2hhcnRpc3QuanMgaW1wbGVtZW50YXRpb246XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZ2lvbmt1bnovY2hhcnRpc3QtanMvYmxvYi9lN2U3ODIwMWJmZmU5NjA5OTE1ZTVlNTNjZmFmYTI5YTVkNmM0OWY5L3NyYy9zY3JpcHRzL2ludGVycG9sYXRpb24uanMjTDI0MC1MMzY5XG5mdW5jdGlvbiBfbW9ub3RvbmVDdWJpYyh4cywgeXMsIG1vdmVUbywgbGluZVRvLCBiZXppZXJDdXJ2ZVRvLCBweFJvdW5kKSB7XG5cdGNvbnN0IG4gPSB4cy5sZW5ndGg7XG5cblx0aWYgKG4gPCAyKVxuXHRcdHJldHVybiBudWxsO1xuXG5cdGNvbnN0IHBhdGggPSBuZXcgUGF0aDJEKCk7XG5cblx0bW92ZVRvKHBhdGgsIHhzWzBdLCB5c1swXSk7XG5cblx0aWYgKG4gPT0gMilcblx0XHRsaW5lVG8ocGF0aCwgeHNbMV0sIHlzWzFdKTtcblx0ZWxzZSB7XG5cdFx0bGV0IG1zICA9IEFycmF5KG4pLFxuXHRcdFx0ZHMgID0gQXJyYXkobiAtIDEpLFxuXHRcdFx0ZHlzID0gQXJyYXkobiAtIDEpLFxuXHRcdFx0ZHhzID0gQXJyYXkobiAtIDEpO1xuXG5cdFx0Ly8gY2FsYyBkZWx0YXMgYW5kIGRlcml2YXRpdmVcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG4gLSAxOyBpKyspIHtcblx0XHRcdGR5c1tpXSA9IHlzW2kgKyAxXSAtIHlzW2ldO1xuXHRcdFx0ZHhzW2ldID0geHNbaSArIDFdIC0geHNbaV07XG5cdFx0XHRkc1tpXSAgPSBkeXNbaV0gLyBkeHNbaV07XG5cdFx0fVxuXG5cdFx0Ly8gZGV0ZXJtaW5lIGRlc2lyZWQgc2xvcGUgKG0pIGF0IGVhY2ggcG9pbnQgdXNpbmcgRnJpdHNjaC1DYXJsc29uIG1ldGhvZFxuXHRcdC8vIGh0dHA6Ly9tYXRoLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy80NTIxOC9pbXBsZW1lbnRhdGlvbi1vZi1tb25vdG9uZS1jdWJpYy1pbnRlcnBvbGF0aW9uXG5cdFx0bXNbMF0gPSBkc1swXTtcblxuXHRcdGZvciAobGV0IGkgPSAxOyBpIDwgbiAtIDE7IGkrKykge1xuXHRcdFx0aWYgKGRzW2ldID09PSAwIHx8IGRzW2kgLSAxXSA9PT0gMCB8fCAoZHNbaSAtIDFdID4gMCkgIT09IChkc1tpXSA+IDApKVxuXHRcdFx0XHRtc1tpXSA9IDA7XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0bXNbaV0gPSAzICogKGR4c1tpIC0gMV0gKyBkeHNbaV0pIC8gKFxuXHRcdFx0XHRcdCgyICogZHhzW2ldICsgZHhzW2kgLSAxXSkgLyBkc1tpIC0gMV0gK1xuXHRcdFx0XHRcdChkeHNbaV0gKyAyICogZHhzW2kgLSAxXSkgLyBkc1tpXVxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdGlmICghaXNGaW5pdGUobXNbaV0pKVxuXHRcdFx0XHRcdG1zW2ldID0gMDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRtc1tuIC0gMV0gPSBkc1tuIC0gMl07XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG4gLSAxOyBpKyspIHtcblx0XHRcdGJlemllckN1cnZlVG8oXG5cdFx0XHRcdHBhdGgsXG5cdFx0XHRcdHhzW2ldICsgZHhzW2ldIC8gMyxcblx0XHRcdFx0eXNbaV0gKyBtc1tpXSAqIGR4c1tpXSAvIDMsXG5cdFx0XHRcdHhzW2kgKyAxXSAtIGR4c1tpXSAvIDMsXG5cdFx0XHRcdHlzW2kgKyAxXSAtIG1zW2kgKyAxXSAqIGR4c1tpXSAvIDMsXG5cdFx0XHRcdHhzW2kgKyAxXSxcblx0XHRcdFx0eXNbaSArIDFdLFxuXHRcdFx0KTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcGF0aDtcbn1cblxuY29uc3QgY3Vyc29yUGxvdHMgPSBuZXcgU2V0KCk7XG5cbmZ1bmN0aW9uIGludmFsaWRhdGVSZWN0cygpIHtcblx0Y3Vyc29yUGxvdHMuZm9yRWFjaCh1ID0+IHtcblx0XHR1LnN5bmNSZWN0KHRydWUpO1xuXHR9KTtcbn1cblxub24ocmVzaXplLCB3aW4sIGludmFsaWRhdGVSZWN0cyk7XG5vbihzY3JvbGwsIHdpbiwgaW52YWxpZGF0ZVJlY3RzLCB0cnVlKTtcblxuY29uc3QgbGluZWFyUGF0aCA9IGxpbmVhcigpIDtcblxuZnVuY3Rpb24gc2V0RGVmYXVsdHMoZCwgeG8sIHlvLCBpbml0WSkge1xuXHRsZXQgZDIgPSBpbml0WSA/IFtkWzBdLCBkWzFdXS5jb25jYXQoZC5zbGljZSgyKSkgOiBbZFswXV0uY29uY2F0KGQuc2xpY2UoMSkpO1xuXHRyZXR1cm4gZDIubWFwKChvLCBpKSA9PiBzZXREZWZhdWx0KG8sIGksIHhvLCB5bykpO1xufVxuXG5mdW5jdGlvbiBzZXREZWZhdWx0KG8sIGksIHhvLCB5bykge1xuXHRyZXR1cm4gYXNzaWduKHt9LCAoaSA9PSAwID8geG8gOiB5byksIG8pO1xufVxuXG5mdW5jdGlvbiBzbmFwTnVtWChzZWxmLCBkYXRhTWluLCBkYXRhTWF4KSB7XG5cdHJldHVybiBkYXRhTWluID09IG51bGwgPyBudWxsTnVsbFR1cGxlIDogW2RhdGFNaW4sIGRhdGFNYXhdO1xufVxuXG5jb25zdCBzbmFwVGltZVggPSBzbmFwTnVtWDtcblxuLy8gdGhpcyBlbnN1cmVzIHRoYXQgbm9uLXRlbXBvcmFsL251bWVyaWMgeS1heGVzIGdldCBtdWx0aXBsZS1zbmFwcGVkIHBhZGRpbmcgYWRkZWQgYWJvdmUvYmVsb3dcbi8vIFRPRE86IGFsc28gYWNjb3VudCBmb3IgaW5jcnMgd2hlbiBzbmFwcGluZyB0byBlbnN1cmUgdG9wIG9mIGF4aXMgZ2V0cyBhIHRpY2sgJiB2YWx1ZVxuZnVuY3Rpb24gc25hcE51bVkoc2VsZiwgZGF0YU1pbiwgZGF0YU1heCkge1xuXHRyZXR1cm4gZGF0YU1pbiA9PSBudWxsID8gbnVsbE51bGxUdXBsZSA6IHJhbmdlTnVtKGRhdGFNaW4sIGRhdGFNYXgsIDAuMSwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIHNuYXBMb2dZKHNlbGYsIGRhdGFNaW4sIGRhdGFNYXgsIHNjYWxlKSB7XG5cdHJldHVybiBkYXRhTWluID09IG51bGwgPyBudWxsTnVsbFR1cGxlIDogcmFuZ2VMb2coZGF0YU1pbiwgZGF0YU1heCwgc2VsZi5zY2FsZXNbc2NhbGVdLmxvZywgZmFsc2UpO1xufVxuXG5jb25zdCBzbmFwTG9nWCA9IHNuYXBMb2dZO1xuXG5mdW5jdGlvbiBzbmFwQXNpbmhZKHNlbGYsIGRhdGFNaW4sIGRhdGFNYXgsIHNjYWxlKSB7XG5cdHJldHVybiBkYXRhTWluID09IG51bGwgPyBudWxsTnVsbFR1cGxlIDogcmFuZ2VBc2luaChkYXRhTWluLCBkYXRhTWF4LCBzZWxmLnNjYWxlc1tzY2FsZV0ubG9nLCBmYWxzZSk7XG59XG5cbmNvbnN0IHNuYXBBc2luaFggPSBzbmFwQXNpbmhZO1xuXG4vLyBkaW0gaXMgbG9naWNhbCAoZ2V0Q2xpZW50Qm91bmRpbmdSZWN0KSBwaXhlbHMsIG5vdCBjYW52YXMgcGl4ZWxzXG5mdW5jdGlvbiBmaW5kSW5jcihtaW4sIG1heCwgaW5jcnMsIGRpbSwgbWluU3BhY2UpIHtcblx0bGV0IHB4UGVyVW5pdCA9IGRpbSAvIChtYXggLSBtaW4pO1xuXG5cdGxldCBtaW5EZWMgPSAoXCJcIitmbG9vcihtaW4pKS5sZW5ndGg7XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBpbmNycy5sZW5ndGg7IGkrKykge1xuXHRcdGxldCBzcGFjZSA9IGluY3JzW2ldICogcHhQZXJVbml0O1xuXG5cdFx0bGV0IGluY3JEZWMgPSBpbmNyc1tpXSA8IDEwID8gZml4ZWREZWMuZ2V0KGluY3JzW2ldKSA6IDA7XG5cblx0XHRpZiAoc3BhY2UgPj0gbWluU3BhY2UgJiYgbWluRGVjICsgaW5jckRlYyA8IDE3KVxuXHRcdFx0cmV0dXJuIFtpbmNyc1tpXSwgc3BhY2VdO1xuXHR9XG5cblx0cmV0dXJuIFswLCAwXTtcbn1cblxuZnVuY3Rpb24gcHhSYXRpb0ZvbnQoZm9udCkge1xuXHRsZXQgZm9udFNpemU7XG5cdGZvbnQgPSBmb250LnJlcGxhY2UoLyhcXGQrKXB4LywgKG0sIHAxKSA9PiAoZm9udFNpemUgPSByb3VuZChwMSAqIHB4UmF0aW8pKSArICdweCcpO1xuXHRyZXR1cm4gW2ZvbnQsIGZvbnRTaXplXTtcbn1cblxuZnVuY3Rpb24gdVBsb3Qob3B0cywgZGF0YSwgdGhlbikge1xuXHRjb25zdCBzZWxmID0ge307XG5cblx0Ly8gVE9ETzogY2FjaGUgZGVub21zICYgbWlucyBzY2FsZS5jYWNoZSA9IHtyLCBtaW4sIH1cblx0ZnVuY3Rpb24gZ2V0VmFsUGN0KHZhbCwgc2NhbGUpIHtcblx0XHRsZXQgX3ZhbCA9IChcblx0XHRcdHNjYWxlLmRpc3RyID09IDMgPyBsb2cxMCh2YWwgPiAwID8gdmFsIDogc2NhbGUuY2xhbXAoc2VsZiwgdmFsLCBzY2FsZS5taW4sIHNjYWxlLm1heCwgc2NhbGUua2V5KSkgOlxuXHRcdFx0c2NhbGUuZGlzdHIgPT0gNCA/IGFzaW5oKHZhbCwgc2NhbGUuYXNpbmgpIDpcblx0XHRcdHZhbFxuXHRcdCk7XG5cblx0XHRyZXR1cm4gKF92YWwgLSBzY2FsZS5fbWluKSAvIChzY2FsZS5fbWF4IC0gc2NhbGUuX21pbik7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRIUG9zKHZhbCwgc2NhbGUsIGRpbSwgb2ZmKSB7XG5cdFx0bGV0IHBjdCA9IGdldFZhbFBjdCh2YWwsIHNjYWxlKTtcblx0XHRyZXR1cm4gb2ZmICsgZGltICogKHNjYWxlLmRpciA9PSAtMSA/ICgxIC0gcGN0KSA6IHBjdCk7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRWUG9zKHZhbCwgc2NhbGUsIGRpbSwgb2ZmKSB7XG5cdFx0bGV0IHBjdCA9IGdldFZhbFBjdCh2YWwsIHNjYWxlKTtcblx0XHRyZXR1cm4gb2ZmICsgZGltICogKHNjYWxlLmRpciA9PSAtMSA/IHBjdCA6ICgxIC0gcGN0KSk7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRQb3ModmFsLCBzY2FsZSwgZGltLCBvZmYpIHtcblx0XHRyZXR1cm4gc2NhbGUub3JpID09IDAgPyBnZXRIUG9zKHZhbCwgc2NhbGUsIGRpbSwgb2ZmKSA6IGdldFZQb3ModmFsLCBzY2FsZSwgZGltLCBvZmYpO1xuXHR9XG5cblx0c2VsZi52YWxUb1Bvc0ggPSBnZXRIUG9zO1xuXHRzZWxmLnZhbFRvUG9zViA9IGdldFZQb3M7XG5cblx0bGV0IHJlYWR5ID0gZmFsc2U7XG5cdHNlbGYuc3RhdHVzID0gMDtcblxuXHRjb25zdCByb290ID0gc2VsZi5yb290ID0gcGxhY2VEaXYoVVBMT1QpO1xuXG5cdGlmIChvcHRzLmlkICE9IG51bGwpXG5cdFx0cm9vdC5pZCA9IG9wdHMuaWQ7XG5cblx0YWRkQ2xhc3Mocm9vdCwgb3B0cy5jbGFzcyk7XG5cblx0aWYgKG9wdHMudGl0bGUpIHtcblx0XHRsZXQgdGl0bGUgPSBwbGFjZURpdihUSVRMRSwgcm9vdCk7XG5cdFx0dGl0bGUudGV4dENvbnRlbnQgPSBvcHRzLnRpdGxlO1xuXHR9XG5cblx0Y29uc3QgY2FuID0gcGxhY2VUYWcoXCJjYW52YXNcIik7XG5cdGNvbnN0IGN0eCA9IHNlbGYuY3R4ID0gY2FuLmdldENvbnRleHQoXCIyZFwiKTtcblxuXHRjb25zdCB3cmFwID0gcGxhY2VEaXYoV1JBUCwgcm9vdCk7XG5cdGNvbnN0IHVuZGVyID0gc2VsZi51bmRlciA9IHBsYWNlRGl2KFVOREVSLCB3cmFwKTtcblx0d3JhcC5hcHBlbmRDaGlsZChjYW4pO1xuXHRjb25zdCBvdmVyID0gc2VsZi5vdmVyID0gcGxhY2VEaXYoT1ZFUiwgd3JhcCk7XG5cblx0b3B0cyA9IGNvcHkob3B0cyk7XG5cblx0Y29uc3QgcHhBbGlnbiA9ICtpZk51bGwob3B0cy5weEFsaWduLCAxKTtcblxuXHRjb25zdCBweFJvdW5kID0gcHhSb3VuZEdlbihweEFsaWduKTtcblxuXHQob3B0cy5wbHVnaW5zIHx8IFtdKS5mb3JFYWNoKHAgPT4ge1xuXHRcdGlmIChwLm9wdHMpXG5cdFx0XHRvcHRzID0gcC5vcHRzKHNlbGYsIG9wdHMpIHx8IG9wdHM7XG5cdH0pO1xuXG5cdGNvbnN0IG1zID0gb3B0cy5tcyB8fCAxZS0zO1xuXG5cdGNvbnN0IHNlcmllcyAgPSBzZWxmLnNlcmllcyA9IHNldERlZmF1bHRzKG9wdHMuc2VyaWVzIHx8IFtdLCB4U2VyaWVzT3B0cywgeVNlcmllc09wdHMsIGZhbHNlKTtcblx0Y29uc3QgYXhlcyAgICA9IHNlbGYuYXhlcyAgID0gc2V0RGVmYXVsdHMob3B0cy5heGVzICAgfHwgW10sIHhBeGlzT3B0cywgICB5QXhpc09wdHMsICAgIHRydWUpO1xuXHRjb25zdCBzY2FsZXMgID0gc2VsZi5zY2FsZXMgPSB7fTtcblx0Y29uc3QgYmFuZHMgICA9IHNlbGYuYmFuZHMgID0gb3B0cy5iYW5kcyB8fCBbXTtcblxuXHRiYW5kcy5mb3JFYWNoKGIgPT4ge1xuXHRcdGIuZmlsbCA9IGZuT3JTZWxmKGIuZmlsbCB8fCBudWxsKTtcblx0fSk7XG5cblx0Y29uc3QgeFNjYWxlS2V5ID0gc2VyaWVzWzBdLnNjYWxlO1xuXG5cdGNvbnN0IGRyYXdPcmRlck1hcCA9IHtcblx0XHRheGVzOiBkcmF3QXhlc0dyaWQsXG5cdFx0c2VyaWVzOiBkcmF3U2VyaWVzLFxuXHR9O1xuXG5cdGNvbnN0IGRyYXdPcmRlciA9IChvcHRzLmRyYXdPcmRlciB8fCBbXCJheGVzXCIsIFwic2VyaWVzXCJdKS5tYXAoa2V5ID0+IGRyYXdPcmRlck1hcFtrZXldKTtcblxuXHRmdW5jdGlvbiBpbml0U2NhbGUoc2NhbGVLZXkpIHtcblx0XHRsZXQgc2MgPSBzY2FsZXNbc2NhbGVLZXldO1xuXG5cdFx0aWYgKHNjID09IG51bGwpIHtcblx0XHRcdGxldCBzY2FsZU9wdHMgPSAob3B0cy5zY2FsZXMgfHwgRU1QVFlfT0JKKVtzY2FsZUtleV0gfHwgRU1QVFlfT0JKO1xuXG5cdFx0XHRpZiAoc2NhbGVPcHRzLmZyb20gIT0gbnVsbCkge1xuXHRcdFx0XHQvLyBlbnN1cmUgcGFyZW50IGlzIGluaXRpYWxpemVkXG5cdFx0XHRcdGluaXRTY2FsZShzY2FsZU9wdHMuZnJvbSk7XG5cdFx0XHRcdC8vIGRlcGVuZGVudCBzY2FsZXMgaW5oZXJpdFxuXHRcdFx0XHRzY2FsZXNbc2NhbGVLZXldID0gYXNzaWduKHt9LCBzY2FsZXNbc2NhbGVPcHRzLmZyb21dLCBzY2FsZU9wdHMpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHNjID0gc2NhbGVzW3NjYWxlS2V5XSA9IGFzc2lnbih7fSwgKHNjYWxlS2V5ID09IHhTY2FsZUtleSA/IHhTY2FsZU9wdHMgOiB5U2NhbGVPcHRzKSwgc2NhbGVPcHRzKTtcblxuXHRcdFx0XHRzYy5rZXkgPSBzY2FsZUtleTtcblxuXHRcdFx0XHRsZXQgaXNUaW1lID0gc2MudGltZTtcblxuXHRcdFx0XHRsZXQgcm4gPSBzYy5yYW5nZTtcblxuXHRcdFx0XHRsZXQgcmFuZ2VJc0FyciA9IGlzQXJyKHJuKTtcblxuXHRcdFx0XHRpZiAoc2NhbGVLZXkgIT0geFNjYWxlS2V5ICYmICFyYW5nZUlzQXJyICYmIGlzT2JqKHJuKSkge1xuXHRcdFx0XHRcdGxldCBjZmcgPSBybjtcblx0XHRcdFx0XHQvLyB0aGlzIGlzIHNpbWlsYXIgdG8gc25hcE51bVlcblx0XHRcdFx0XHRybiA9IChzZWxmLCBkYXRhTWluLCBkYXRhTWF4KSA9PiBkYXRhTWluID09IG51bGwgPyBudWxsTnVsbFR1cGxlIDogcmFuZ2VOdW0oZGF0YU1pbiwgZGF0YU1heCwgY2ZnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNjLnJhbmdlID0gZm5PclNlbGYocm4gfHwgKGlzVGltZSA/IHNuYXBUaW1lWCA6IHNjYWxlS2V5ID09IHhTY2FsZUtleSA/XG5cdFx0XHRcdFx0KHNjLmRpc3RyID09IDMgPyBzbmFwTG9nWCA6IHNjLmRpc3RyID09IDQgPyBzbmFwQXNpbmhYIDogc25hcE51bVgpIDpcblx0XHRcdFx0XHQoc2MuZGlzdHIgPT0gMyA/IHNuYXBMb2dZIDogc2MuZGlzdHIgPT0gNCA/IHNuYXBBc2luaFkgOiBzbmFwTnVtWSlcblx0XHRcdFx0KSk7XG5cblx0XHRcdFx0c2MuYXV0byA9IGZuT3JTZWxmKHJhbmdlSXNBcnIgPyBmYWxzZSA6IHNjLmF1dG8pO1xuXG5cdFx0XHRcdHNjLmNsYW1wID0gZm5PclNlbGYoc2MuY2xhbXAgfHwgY2xhbXBTY2FsZSk7XG5cblx0XHRcdFx0Ly8gY2FjaGVzIGZvciBleHBlbnNpdmUgb3BzIGxpa2UgYXNpbmgoKSAmIGxvZygpXG5cdFx0XHRcdHNjLl9taW4gPSBzYy5fbWF4ID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpbml0U2NhbGUoXCJ4XCIpO1xuXHRpbml0U2NhbGUoXCJ5XCIpO1xuXG5cdHNlcmllcy5mb3JFYWNoKHMgPT4ge1xuXHRcdGluaXRTY2FsZShzLnNjYWxlKTtcblx0fSk7XG5cblx0YXhlcy5mb3JFYWNoKGEgPT4ge1xuXHRcdGluaXRTY2FsZShhLnNjYWxlKTtcblx0fSk7XG5cblx0Zm9yIChsZXQgayBpbiBvcHRzLnNjYWxlcylcblx0XHRpbml0U2NhbGUoayk7XG5cblx0Y29uc3Qgc2NhbGVYID0gc2NhbGVzW3hTY2FsZUtleV07XG5cblx0Y29uc3QgeFNjYWxlRGlzdHIgPSBzY2FsZVguZGlzdHI7XG5cblx0bGV0IHZhbFRvUG9zWCwgdmFsVG9Qb3NZLCBtb3ZlVG8sIGFyYztcblxuXHRpZiAoc2NhbGVYLm9yaSA9PSAwKSB7XG5cdFx0YWRkQ2xhc3Mocm9vdCwgT1JJX0haKTtcblx0XHR2YWxUb1Bvc1ggPSBnZXRIUG9zO1xuXHRcdHZhbFRvUG9zWSA9IGdldFZQb3M7XG5cdFx0bW92ZVRvICAgID0gbW92ZVRvSDtcblx0XHRhcmMgICAgICAgPSBhcmNIO1xuXHRcdC8qXG5cdFx0dXBkT3JpRGltcyA9ICgpID0+IHtcblx0XHRcdHhEaW1DYW4gPSBwbG90V2lkO1xuXHRcdFx0eE9mZkNhbiA9IHBsb3RMZnQ7XG5cdFx0XHR5RGltQ2FuID0gcGxvdEhndDtcblx0XHRcdHlPZmZDYW4gPSBwbG90VG9wO1xuXG5cdFx0XHR4RGltQ3NzID0gcGxvdFdpZENzcztcblx0XHRcdHhPZmZDc3MgPSBwbG90TGZ0Q3NzO1xuXHRcdFx0eURpbUNzcyA9IHBsb3RIZ3RDc3M7XG5cdFx0XHR5T2ZmQ3NzID0gcGxvdFRvcENzcztcblx0XHR9O1xuXHRcdCovXG5cdH1cblx0ZWxzZSB7XG5cdFx0YWRkQ2xhc3Mocm9vdCwgT1JJX1ZUKTtcblx0XHR2YWxUb1Bvc1ggPSBnZXRWUG9zO1xuXHRcdHZhbFRvUG9zWSA9IGdldEhQb3M7XG5cdFx0bW92ZVRvICAgID0gbW92ZVRvVjtcblx0XHRhcmMgICAgICAgPSBhcmNWO1xuXHRcdC8qXG5cdFx0dXBkT3JpRGltcyA9ICgpID0+IHtcblx0XHRcdHhEaW1DYW4gPSBwbG90SGd0O1xuXHRcdFx0eE9mZkNhbiA9IHBsb3RUb3A7XG5cdFx0XHR5RGltQ2FuID0gcGxvdFdpZDtcblx0XHRcdHlPZmZDYW4gPSBwbG90TGZ0O1xuXG5cdFx0XHR4RGltQ3NzID0gcGxvdEhndENzcztcblx0XHRcdHhPZmZDc3MgPSBwbG90VG9wQ3NzO1xuXHRcdFx0eURpbUNzcyA9IHBsb3RXaWRDc3M7XG5cdFx0XHR5T2ZmQ3NzID0gcGxvdExmdENzcztcblx0XHR9O1xuXHRcdCovXG5cdH1cblxuXHRjb25zdCBwZW5kU2NhbGVzID0ge307XG5cblx0Ly8gZXhwbGljaXRseS1zZXQgaW5pdGlhbCBzY2FsZXNcblx0Zm9yIChsZXQgayBpbiBzY2FsZXMpIHtcblx0XHRsZXQgc2MgPSBzY2FsZXNba107XG5cblx0XHRpZiAoc2MubWluICE9IG51bGwgfHwgc2MubWF4ICE9IG51bGwpIHtcblx0XHRcdHBlbmRTY2FsZXNba10gPSB7bWluOiBzYy5taW4sIG1heDogc2MubWF4fTtcblx0XHRcdHNjLm1pbiA9IHNjLm1heCA9IG51bGw7XG5cdFx0fVxuXHR9XG5cbi8vXHRzZWxmLnR6ID0gb3B0cy50eiB8fCBJbnRsLkRhdGVUaW1lRm9ybWF0KCkucmVzb2x2ZWRPcHRpb25zKCkudGltZVpvbmU7XG5cdGNvbnN0IF90ekRhdGUgID0gKG9wdHMudHpEYXRlIHx8ICh0cyA9PiBuZXcgRGF0ZShyb3VuZCh0cyAvIG1zKSkpKTtcblx0Y29uc3QgX2ZtdERhdGUgPSAob3B0cy5mbXREYXRlIHx8IGZtdERhdGUpO1xuXG5cdGNvbnN0IF90aW1lQXhpc1NwbGl0cyA9IChtcyA9PSAxID8gdGltZUF4aXNTcGxpdHNNcyhfdHpEYXRlKSA6IHRpbWVBeGlzU3BsaXRzUyhfdHpEYXRlKSk7XG5cdGNvbnN0IF90aW1lQXhpc1ZhbHMgICA9IHRpbWVBeGlzVmFscyhfdHpEYXRlLCB0aW1lQXhpc1N0YW1wcygobXMgPT0gMSA/IF90aW1lQXhpc1N0YW1wc01zIDogX3RpbWVBeGlzU3RhbXBzUyksIF9mbXREYXRlKSk7XG5cdGNvbnN0IF90aW1lU2VyaWVzVmFsICA9IHRpbWVTZXJpZXNWYWwoX3R6RGF0ZSwgdGltZVNlcmllc1N0YW1wKF90aW1lU2VyaWVzU3RhbXAsIF9mbXREYXRlKSk7XG5cblx0Y29uc3QgbGVnZW5kICAgICA9IChzZWxmLmxlZ2VuZCA9IGFzc2lnbih7fSwgbGVnZW5kT3B0cywgb3B0cy5sZWdlbmQpKTtcblx0Y29uc3Qgc2hvd0xlZ2VuZCA9IGxlZ2VuZC5zaG93O1xuXHRjb25zdCBtYXJrZXJzICAgID0gbGVnZW5kLm1hcmtlcnM7XG5cblx0e1xuXHRcdG1hcmtlcnMud2lkdGggID0gZm5PclNlbGYobWFya2Vycy53aWR0aCk7XG5cdFx0bWFya2Vycy5kYXNoICAgPSBmbk9yU2VsZihtYXJrZXJzLmRhc2gpO1xuXHRcdG1hcmtlcnMuc3Ryb2tlID0gZm5PclNlbGYobWFya2Vycy5zdHJva2UpO1xuXHRcdG1hcmtlcnMuZmlsbCAgID0gZm5PclNlbGYobWFya2Vycy5maWxsKTtcblx0fVxuXG5cdGxldCBsZWdlbmRFbDtcblx0bGV0IGxlZ2VuZFJvd3MgPSBbXTtcblx0bGV0IGxlZ2VuZENlbGxzID0gW107XG5cdGxldCBsZWdlbmRDb2xzO1xuXHRsZXQgbXVsdGlWYWxMZWdlbmQgPSBmYWxzZTtcblx0bGV0IE5VTExfTEVHRU5EX1ZBTFVFUyA9IHt9O1xuXG5cdGlmIChsZWdlbmQubGl2ZSkge1xuXHRcdGNvbnN0IGdldE11bHRpVmFscyA9IHNlcmllc1sxXSA/IHNlcmllc1sxXS52YWx1ZXMgOiBudWxsO1xuXHRcdG11bHRpVmFsTGVnZW5kID0gZ2V0TXVsdGlWYWxzICE9IG51bGw7XG5cdFx0bGVnZW5kQ29scyA9IG11bHRpVmFsTGVnZW5kID8gZ2V0TXVsdGlWYWxzKHNlbGYsIDEsIDApIDoge186IDB9O1xuXG5cdFx0Zm9yIChsZXQgayBpbiBsZWdlbmRDb2xzKVxuXHRcdFx0TlVMTF9MRUdFTkRfVkFMVUVTW2tdID0gXCItLVwiO1xuXHR9XG5cblx0aWYgKHNob3dMZWdlbmQpIHtcblx0XHRsZWdlbmRFbCA9IHBsYWNlVGFnKFwidGFibGVcIiwgTEVHRU5ELCByb290KTtcblxuXHRcdGlmIChtdWx0aVZhbExlZ2VuZCkge1xuXHRcdFx0bGV0IGhlYWQgPSBwbGFjZVRhZyhcInRyXCIsIExFR0VORF9USEVBRCwgbGVnZW5kRWwpO1xuXHRcdFx0cGxhY2VUYWcoXCJ0aFwiLCBudWxsLCBoZWFkKTtcblxuXHRcdFx0Zm9yICh2YXIga2V5IGluIGxlZ2VuZENvbHMpXG5cdFx0XHRcdHBsYWNlVGFnKFwidGhcIiwgTEVHRU5EX0xBQkVMLCBoZWFkKS50ZXh0Q29udGVudCA9IGtleTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRhZGRDbGFzcyhsZWdlbmRFbCwgTEVHRU5EX0lOTElORSk7XG5cdFx0XHRsZWdlbmQubGl2ZSAmJiBhZGRDbGFzcyhsZWdlbmRFbCwgTEVHRU5EX0xJVkUpO1xuXHRcdH1cblx0fVxuXG5cdGNvbnN0IHNvbiAgPSB7c2hvdzogdHJ1ZX07XG5cdGNvbnN0IHNvZmYgPSB7c2hvdzogZmFsc2V9O1xuXG5cdGZ1bmN0aW9uIGluaXRMZWdlbmRSb3cocywgaSkge1xuXHRcdGlmIChpID09IDAgJiYgKG11bHRpVmFsTGVnZW5kIHx8ICFsZWdlbmQubGl2ZSkpXG5cdFx0XHRyZXR1cm4gbnVsbE51bGxUdXBsZTtcblxuXHRcdGxldCBjZWxscyA9IFtdO1xuXG5cdFx0bGV0IHJvdyA9IHBsYWNlVGFnKFwidHJcIiwgTEVHRU5EX1NFUklFUywgbGVnZW5kRWwsIGxlZ2VuZEVsLmNoaWxkTm9kZXNbaV0pO1xuXG5cdFx0YWRkQ2xhc3Mocm93LCBzLmNsYXNzKTtcblxuXHRcdGlmICghcy5zaG93KVxuXHRcdFx0YWRkQ2xhc3Mocm93LCBPRkYpO1xuXG5cdFx0bGV0IGxhYmVsID0gcGxhY2VUYWcoXCJ0aFwiLCBudWxsLCByb3cpO1xuXG5cdFx0aWYgKG1hcmtlcnMuc2hvdykge1xuXHRcdFx0bGV0IGluZGljID0gcGxhY2VEaXYoTEVHRU5EX01BUktFUiwgbGFiZWwpO1xuXG5cdFx0XHRpZiAoaSA+IDApIHtcblx0XHRcdFx0bGV0IHdpZHRoICA9IG1hcmtlcnMud2lkdGgoc2VsZiwgaSk7XG5cblx0XHRcdFx0aWYgKHdpZHRoKVxuXHRcdFx0XHRcdGluZGljLnN0eWxlLmJvcmRlciA9IHdpZHRoICsgXCJweCBcIiArIG1hcmtlcnMuZGFzaChzZWxmLCBpKSArIFwiIFwiICsgbWFya2Vycy5zdHJva2Uoc2VsZiwgaSk7XG5cblx0XHRcdFx0aW5kaWMuc3R5bGUuYmFja2dyb3VuZCA9IG1hcmtlcnMuZmlsbChzZWxmLCBpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRsZXQgdGV4dCA9IHBsYWNlRGl2KExFR0VORF9MQUJFTCwgbGFiZWwpO1xuXHRcdHRleHQudGV4dENvbnRlbnQgPSBzLmxhYmVsO1xuXG5cdFx0aWYgKGkgPiAwKSB7XG5cdFx0XHRpZiAoIW1hcmtlcnMuc2hvdylcblx0XHRcdFx0dGV4dC5zdHlsZS5jb2xvciA9IHMud2lkdGggPiAwID8gbWFya2Vycy5zdHJva2Uoc2VsZiwgaSkgOiBtYXJrZXJzLmZpbGwoc2VsZiwgaSk7XG5cblx0XHRcdG9uTW91c2UoXCJjbGlja1wiLCBsYWJlbCwgZSA9PiB7XG5cdFx0XHRcdGlmIChjdXJzb3IuX2xvY2spXG5cdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdGxldCBzZXJpZXNJZHggPSBzZXJpZXMuaW5kZXhPZihzKTtcblxuXHRcdFx0XHRpZiAoZS5jdHJsS2V5ICE9IGxlZ2VuZC5pc29sYXRlKSB7XG5cdFx0XHRcdFx0Ly8gaWYgYW55IG90aGVyIHNlcmllcyBpcyBzaG93biwgaXNvbGF0ZSB0aGlzIG9uZS4gZWxzZSBzaG93IGFsbFxuXHRcdFx0XHRcdGxldCBpc29sYXRlID0gc2VyaWVzLnNvbWUoKHMsIGkpID0+IGkgPiAwICYmIGkgIT0gc2VyaWVzSWR4ICYmIHMuc2hvdyk7XG5cblx0XHRcdFx0XHRzZXJpZXMuZm9yRWFjaCgocywgaSkgPT4ge1xuXHRcdFx0XHRcdFx0aSA+IDAgJiYgc2V0U2VyaWVzKGksIGlzb2xhdGUgPyAoaSA9PSBzZXJpZXNJZHggPyBzb24gOiBzb2ZmKSA6IHNvbiwgc3luY09wdHMuc2V0U2VyaWVzKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0c2V0U2VyaWVzKHNlcmllc0lkeCwge3Nob3c6ICFzLnNob3d9LCBzeW5jT3B0cy5zZXRTZXJpZXMpO1xuXHRcdFx0fSk7XG5cblx0XHRcdGlmIChjdXJzb3JGb2N1cykge1xuXHRcdFx0XHRvbk1vdXNlKG1vdXNlZW50ZXIsIGxhYmVsLCBlID0+IHtcblx0XHRcdFx0XHRpZiAoY3Vyc29yLl9sb2NrKVxuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdFx0c2V0U2VyaWVzKHNlcmllcy5pbmRleE9mKHMpLCBGT0NVU19UUlVFLCBzeW5jT3B0cy5zZXRTZXJpZXMpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gbGVnZW5kQ29scykge1xuXHRcdFx0bGV0IHYgPSBwbGFjZVRhZyhcInRkXCIsIExFR0VORF9WQUxVRSwgcm93KTtcblx0XHRcdHYudGV4dENvbnRlbnQgPSBcIi0tXCI7XG5cdFx0XHRjZWxscy5wdXNoKHYpO1xuXHRcdH1cblxuXHRcdHJldHVybiBbcm93LCBjZWxsc107XG5cdH1cblxuXHRjb25zdCBtb3VzZUxpc3RlbmVycyA9IG5ldyBNYXAoKTtcblxuXHRmdW5jdGlvbiBvbk1vdXNlKGV2LCB0YXJnLCBmbikge1xuXHRcdGNvbnN0IHRhcmdMaXN0ZW5lcnMgPSBtb3VzZUxpc3RlbmVycy5nZXQodGFyZykgfHwge307XG5cdFx0Y29uc3QgbGlzdGVuZXIgPSBjdXJzb3IuYmluZFtldl0oc2VsZiwgdGFyZywgZm4pO1xuXG5cdFx0aWYgKGxpc3RlbmVyKSB7XG5cdFx0XHRvbihldiwgdGFyZywgdGFyZ0xpc3RlbmVyc1tldl0gPSBsaXN0ZW5lcik7XG5cdFx0XHRtb3VzZUxpc3RlbmVycy5zZXQodGFyZywgdGFyZ0xpc3RlbmVycyk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gb2ZmTW91c2UoZXYsIHRhcmcsIGZuKSB7XG5cdFx0Y29uc3QgdGFyZ0xpc3RlbmVycyA9IG1vdXNlTGlzdGVuZXJzLmdldCh0YXJnKSB8fCB7fTtcblxuXHRcdGZvciAobGV0IGsgaW4gdGFyZ0xpc3RlbmVycykge1xuXHRcdFx0aWYgKGV2ID09IG51bGwgfHwgayA9PSBldikge1xuXHRcdFx0XHRvZmYoaywgdGFyZywgdGFyZ0xpc3RlbmVyc1trXSk7XG5cdFx0XHRcdGRlbGV0ZSB0YXJnTGlzdGVuZXJzW2tdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChldiA9PSBudWxsKVxuXHRcdFx0bW91c2VMaXN0ZW5lcnMuZGVsZXRlKHRhcmcpO1xuXHR9XG5cblx0bGV0IGZ1bGxXaWRDc3MgPSAwO1xuXHRsZXQgZnVsbEhndENzcyA9IDA7XG5cblx0bGV0IHBsb3RXaWRDc3MgPSAwO1xuXHRsZXQgcGxvdEhndENzcyA9IDA7XG5cblx0Ly8gcGxvdCBtYXJnaW5zIHRvIGFjY291bnQgZm9yIGF4ZXNcblx0bGV0IHBsb3RMZnRDc3MgPSAwO1xuXHRsZXQgcGxvdFRvcENzcyA9IDA7XG5cblx0bGV0IHBsb3RMZnQgPSAwO1xuXHRsZXQgcGxvdFRvcCA9IDA7XG5cdGxldCBwbG90V2lkID0gMDtcblx0bGV0IHBsb3RIZ3QgPSAwO1xuXG5cdHNlbGYuYmJveCA9IHt9O1xuXG5cdGxldCBzaG91bGRTZXRTY2FsZXMgPSBmYWxzZTtcblx0bGV0IHNob3VsZFNldFNpemUgPSBmYWxzZTtcblx0bGV0IHNob3VsZENvbnZlcmdlU2l6ZSA9IGZhbHNlO1xuXHRsZXQgc2hvdWxkU2V0Q3Vyc29yID0gZmFsc2U7XG5cdGxldCBzaG91bGRTZXRMZWdlbmQgPSBmYWxzZTtcblxuXHRmdW5jdGlvbiBfc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG5cdFx0aWYgKHdpZHRoICE9IHNlbGYud2lkdGggfHwgaGVpZ2h0ICE9IHNlbGYuaGVpZ2h0KVxuXHRcdFx0Y2FsY1NpemUod2lkdGgsIGhlaWdodCk7XG5cblx0XHRyZXNldFlTZXJpZXMoZmFsc2UpO1xuXG5cdFx0c2hvdWxkQ29udmVyZ2VTaXplID0gdHJ1ZTtcblx0XHRzaG91bGRTZXRTaXplID0gdHJ1ZTtcblx0XHRzaG91bGRTZXRDdXJzb3IgPSBjdXJzb3IubGVmdCA+PSAwO1xuXHRcdHNob3VsZFNldExlZ2VuZCA9IHRydWU7XG5cdFx0Y29tbWl0KCk7XG5cdH1cblxuXHRmdW5jdGlvbiBjYWxjU2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG5cdC8vXHRsb2coXCJjYWxjU2l6ZSgpXCIsIGFyZ3VtZW50cyk7XG5cblx0XHRzZWxmLndpZHRoICA9IGZ1bGxXaWRDc3MgPSBwbG90V2lkQ3NzID0gd2lkdGg7XG5cdFx0c2VsZi5oZWlnaHQgPSBmdWxsSGd0Q3NzID0gcGxvdEhndENzcyA9IGhlaWdodDtcblx0XHRwbG90TGZ0Q3NzICA9IHBsb3RUb3BDc3MgPSAwO1xuXG5cdFx0Y2FsY1Bsb3RSZWN0KCk7XG5cdFx0Y2FsY0F4ZXNSZWN0cygpO1xuXG5cdFx0bGV0IGJiID0gc2VsZi5iYm94O1xuXG5cdFx0cGxvdExmdCA9IGJiLmxlZnQgICA9IGluY3JSb3VuZChwbG90TGZ0Q3NzICogcHhSYXRpbywgMC41KTtcblx0XHRwbG90VG9wID0gYmIudG9wICAgID0gaW5jclJvdW5kKHBsb3RUb3BDc3MgKiBweFJhdGlvLCAwLjUpO1xuXHRcdHBsb3RXaWQgPSBiYi53aWR0aCAgPSBpbmNyUm91bmQocGxvdFdpZENzcyAqIHB4UmF0aW8sIDAuNSk7XG5cdFx0cGxvdEhndCA9IGJiLmhlaWdodCA9IGluY3JSb3VuZChwbG90SGd0Q3NzICogcHhSYXRpbywgMC41KTtcblxuXHQvL1x0dXBkT3JpRGltcygpO1xuXHR9XG5cblx0Ly8gZW5zdXJlcyBzaXplIGNhbGMgY29udmVyZ2VuY2Vcblx0Y29uc3QgQ1lDTEVfTElNSVQgPSAzO1xuXG5cdGZ1bmN0aW9uIGNvbnZlcmdlU2l6ZSgpIHtcblx0XHRsZXQgY29udmVyZ2VkID0gZmFsc2U7XG5cblx0XHRsZXQgY3ljbGVOdW0gPSAwO1xuXG5cdFx0d2hpbGUgKCFjb252ZXJnZWQpIHtcblx0XHRcdGN5Y2xlTnVtKys7XG5cblx0XHRcdGxldCBheGVzQ29udmVyZ2VkID0gYXhlc0NhbGMoY3ljbGVOdW0pO1xuXHRcdFx0bGV0IHBhZGRpbmdDb252ZXJnZWQgPSBwYWRkaW5nQ2FsYyhjeWNsZU51bSk7XG5cblx0XHRcdGNvbnZlcmdlZCA9IGN5Y2xlTnVtID09IENZQ0xFX0xJTUlUIHx8IChheGVzQ29udmVyZ2VkICYmIHBhZGRpbmdDb252ZXJnZWQpO1xuXG5cdFx0XHRpZiAoIWNvbnZlcmdlZCkge1xuXHRcdFx0XHRjYWxjU2l6ZShzZWxmLndpZHRoLCBzZWxmLmhlaWdodCk7XG5cdFx0XHRcdHNob3VsZFNldFNpemUgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHNldFNpemUoe3dpZHRoLCBoZWlnaHR9KSB7XG5cdFx0X3NldFNpemUod2lkdGgsIGhlaWdodCk7XG5cdH1cblxuXHRzZWxmLnNldFNpemUgPSBzZXRTaXplO1xuXG5cdC8vIGFjY3VtdWxhdGUgYXhpcyBvZmZzZXRzLCByZWR1Y2UgY2FudmFzIHdpZHRoXG5cdGZ1bmN0aW9uIGNhbGNQbG90UmVjdCgpIHtcblx0XHQvLyBlYXNlbWVudHMgZm9yIGVkZ2UgbGFiZWxzXG5cdFx0bGV0IGhhc1RvcEF4aXMgPSBmYWxzZTtcblx0XHRsZXQgaGFzQnRtQXhpcyA9IGZhbHNlO1xuXHRcdGxldCBoYXNSZ3RBeGlzID0gZmFsc2U7XG5cdFx0bGV0IGhhc0xmdEF4aXMgPSBmYWxzZTtcblxuXHRcdGF4ZXMuZm9yRWFjaCgoYXhpcywgaSkgPT4ge1xuXHRcdFx0aWYgKGF4aXMuc2hvdyAmJiBheGlzLl9zaG93KSB7XG5cdFx0XHRcdGxldCB7c2lkZSwgX3NpemV9ID0gYXhpcztcblx0XHRcdFx0bGV0IGlzVnQgPSBzaWRlICUgMjtcblx0XHRcdFx0bGV0IGxhYmVsU2l6ZSA9IGF4aXMubGFiZWxTaXplID0gKGF4aXMubGFiZWwgIT0gbnVsbCA/IChheGlzLmxhYmVsU2l6ZSB8fCAzMCkgOiAwKTtcblxuXHRcdFx0XHRsZXQgZnVsbFNpemUgPSBfc2l6ZSArIGxhYmVsU2l6ZTtcblxuXHRcdFx0XHRpZiAoZnVsbFNpemUgPiAwKSB7XG5cdFx0XHRcdFx0aWYgKGlzVnQpIHtcblx0XHRcdFx0XHRcdHBsb3RXaWRDc3MgLT0gZnVsbFNpemU7XG5cblx0XHRcdFx0XHRcdGlmIChzaWRlID09IDMpIHtcblx0XHRcdFx0XHRcdFx0cGxvdExmdENzcyArPSBmdWxsU2l6ZTtcblx0XHRcdFx0XHRcdFx0aGFzTGZ0QXhpcyA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRcdGhhc1JndEF4aXMgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdHBsb3RIZ3RDc3MgLT0gZnVsbFNpemU7XG5cblx0XHRcdFx0XHRcdGlmIChzaWRlID09IDApIHtcblx0XHRcdFx0XHRcdFx0cGxvdFRvcENzcyArPSBmdWxsU2l6ZTtcblx0XHRcdFx0XHRcdFx0aGFzVG9wQXhpcyA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRcdGhhc0J0bUF4aXMgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0c2lkZXNXaXRoQXhlc1swXSA9IGhhc1RvcEF4aXM7XG5cdFx0c2lkZXNXaXRoQXhlc1sxXSA9IGhhc1JndEF4aXM7XG5cdFx0c2lkZXNXaXRoQXhlc1syXSA9IGhhc0J0bUF4aXM7XG5cdFx0c2lkZXNXaXRoQXhlc1szXSA9IGhhc0xmdEF4aXM7XG5cblx0XHQvLyBoeiBwYWRkaW5nXG5cdFx0cGxvdFdpZENzcyAtPSBfcGFkZGluZ1sxXSArIF9wYWRkaW5nWzNdO1xuXHRcdHBsb3RMZnRDc3MgKz0gX3BhZGRpbmdbM107XG5cblx0XHQvLyB2dCBwYWRkaW5nXG5cdFx0cGxvdEhndENzcyAtPSBfcGFkZGluZ1syXSArIF9wYWRkaW5nWzBdO1xuXHRcdHBsb3RUb3BDc3MgKz0gX3BhZGRpbmdbMF07XG5cdH1cblxuXHRmdW5jdGlvbiBjYWxjQXhlc1JlY3RzKCkge1xuXHRcdC8vIHdpbGwgYWNjdW0gK1xuXHRcdGxldCBvZmYxID0gcGxvdExmdENzcyArIHBsb3RXaWRDc3M7XG5cdFx0bGV0IG9mZjIgPSBwbG90VG9wQ3NzICsgcGxvdEhndENzcztcblx0XHQvLyB3aWxsIGFjY3VtIC1cblx0XHRsZXQgb2ZmMyA9IHBsb3RMZnRDc3M7XG5cdFx0bGV0IG9mZjAgPSBwbG90VG9wQ3NzO1xuXG5cdFx0ZnVuY3Rpb24gaW5jck9mZnNldChzaWRlLCBzaXplKSB7XG5cdFx0XHRzd2l0Y2ggKHNpZGUpIHtcblx0XHRcdFx0Y2FzZSAxOiBvZmYxICs9IHNpemU7IHJldHVybiBvZmYxIC0gc2l6ZTtcblx0XHRcdFx0Y2FzZSAyOiBvZmYyICs9IHNpemU7IHJldHVybiBvZmYyIC0gc2l6ZTtcblx0XHRcdFx0Y2FzZSAzOiBvZmYzIC09IHNpemU7IHJldHVybiBvZmYzICsgc2l6ZTtcblx0XHRcdFx0Y2FzZSAwOiBvZmYwIC09IHNpemU7IHJldHVybiBvZmYwICsgc2l6ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRheGVzLmZvckVhY2goKGF4aXMsIGkpID0+IHtcblx0XHRcdGlmIChheGlzLnNob3cgJiYgYXhpcy5fc2hvdykge1xuXHRcdFx0XHRsZXQgc2lkZSA9IGF4aXMuc2lkZTtcblxuXHRcdFx0XHRheGlzLl9wb3MgPSBpbmNyT2Zmc2V0KHNpZGUsIGF4aXMuX3NpemUpO1xuXG5cdFx0XHRcdGlmIChheGlzLmxhYmVsICE9IG51bGwpXG5cdFx0XHRcdFx0YXhpcy5fbHBvcyA9IGluY3JPZmZzZXQoc2lkZSwgYXhpcy5sYWJlbFNpemUpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0Y29uc3QgY3Vyc29yID0gKHNlbGYuY3Vyc29yID0gYXNzaWduKHt9LCBjdXJzb3JPcHRzLCBvcHRzLmN1cnNvcikpO1xuXG5cdHtcblx0XHRjdXJzb3IuX2xvY2sgPSBmYWxzZTtcblxuXHRcdGxldCBwb2ludHMgPSBjdXJzb3IucG9pbnRzO1xuXG5cdFx0cG9pbnRzLnNob3cgICA9IGZuT3JTZWxmKHBvaW50cy5zaG93KTtcblx0XHRwb2ludHMuc2l6ZSAgID0gZm5PclNlbGYocG9pbnRzLnNpemUpO1xuXHRcdHBvaW50cy5zdHJva2UgPSBmbk9yU2VsZihwb2ludHMuc3Ryb2tlKTtcblx0XHRwb2ludHMud2lkdGggID0gZm5PclNlbGYocG9pbnRzLndpZHRoKTtcblx0XHRwb2ludHMuZmlsbCAgID0gZm5PclNlbGYocG9pbnRzLmZpbGwpO1xuXHR9XG5cblx0Y29uc3QgZm9jdXMgPSBzZWxmLmZvY3VzID0gYXNzaWduKHt9LCBvcHRzLmZvY3VzIHx8IHthbHBoYTogMC4zfSwgY3Vyc29yLmZvY3VzKTtcblx0Y29uc3QgY3Vyc29yRm9jdXMgPSBmb2N1cy5wcm94ID49IDA7XG5cblx0Ly8gc2VyaWVzLWludGVyc2VjdGlvbiBtYXJrZXJzXG5cdGxldCBjdXJzb3JQdHMgPSBbbnVsbF07XG5cblx0ZnVuY3Rpb24gaW5pdEN1cnNvclB0KHMsIHNpKSB7XG5cdFx0aWYgKHNpID4gMCkge1xuXHRcdFx0bGV0IHB0ID0gY3Vyc29yLnBvaW50cy5zaG93KHNlbGYsIHNpKTtcblxuXHRcdFx0aWYgKHB0KSB7XG5cdFx0XHRcdGFkZENsYXNzKHB0LCBDVVJTT1JfUFQpO1xuXHRcdFx0XHRhZGRDbGFzcyhwdCwgcy5jbGFzcyk7XG5cdFx0XHRcdHRyYW5zKHB0LCAtMTAsIC0xMCwgcGxvdFdpZENzcywgcGxvdEhndENzcyk7XG5cdFx0XHRcdG92ZXIuaW5zZXJ0QmVmb3JlKHB0LCBjdXJzb3JQdHNbc2ldKTtcblxuXHRcdFx0XHRyZXR1cm4gcHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gaW5pdFNlcmllcyhzLCBpKSB7XG5cdFx0bGV0IGlzVGltZSA9IHNjYWxlc1tzLnNjYWxlXS50aW1lO1xuXG5cdFx0bGV0IHN2ID0gcy52YWx1ZTtcblx0XHRzLnZhbHVlID0gaXNUaW1lID8gKGlzU3RyKHN2KSA/IHRpbWVTZXJpZXNWYWwoX3R6RGF0ZSwgdGltZVNlcmllc1N0YW1wKHN2LCBfZm10RGF0ZSkpIDogc3YgfHwgX3RpbWVTZXJpZXNWYWwpIDogc3YgfHwgbnVtU2VyaWVzVmFsO1xuXHRcdHMubGFiZWwgPSBzLmxhYmVsIHx8IChpc1RpbWUgPyB0aW1lU2VyaWVzTGFiZWwgOiBudW1TZXJpZXNMYWJlbCk7XG5cblx0XHRpZiAoaSA+IDApIHtcblx0XHRcdHMud2lkdGggID0gcy53aWR0aCA9PSBudWxsID8gMSA6IHMud2lkdGg7XG5cdFx0XHRzLnBhdGhzICA9IHMucGF0aHMgfHwgbGluZWFyUGF0aCB8fCByZXROdWxsO1xuXHRcdFx0cy5maWxsVG8gPSBmbk9yU2VsZihzLmZpbGxUbyB8fCBzZXJpZXNGaWxsVG8pO1xuXHRcdFx0cy5weEFsaWduID0gK2lmTnVsbChzLnB4QWxpZ24sIHB4QWxpZ24pO1xuXHRcdFx0cy5weFJvdW5kID0gcHhSb3VuZEdlbihzLnB4QWxpZ24pO1xuXG5cdFx0XHRzLnN0cm9rZSA9IGZuT3JTZWxmKHMuc3Ryb2tlIHx8IG51bGwpO1xuXHRcdFx0cy5maWxsICAgPSBmbk9yU2VsZihzLmZpbGwgfHwgbnVsbCk7XG5cdFx0XHRzLl9zdHJva2UgPSBzLl9maWxsID0gcy5fcGF0aHMgPSBzLl9mb2N1cyA9IG51bGw7XG5cblx0XHRcdGxldCBfcHREaWEgPSBwdERpYShzLndpZHRoLCAxKTtcblx0XHRcdGxldCBwb2ludHMgPSBzLnBvaW50cyA9IGFzc2lnbih7fSwge1xuXHRcdFx0XHRzaXplOiBfcHREaWEsXG5cdFx0XHRcdHdpZHRoOiBtYXgoMSwgX3B0RGlhICogLjIpLFxuXHRcdFx0XHRzdHJva2U6IHMuc3Ryb2tlLFxuXHRcdFx0XHRzcGFjZTogX3B0RGlhICogMixcblx0XHRcdFx0X3N0cm9rZTogbnVsbCxcblx0XHRcdFx0X2ZpbGw6IG51bGwsXG5cdFx0XHR9LCBzLnBvaW50cyk7XG5cdFx0XHRwb2ludHMuc2hvdyAgID0gZm5PclNlbGYocG9pbnRzLnNob3cpO1xuXHRcdFx0cG9pbnRzLmZpbGwgICA9IGZuT3JTZWxmKHBvaW50cy5maWxsKTtcblx0XHRcdHBvaW50cy5zdHJva2UgPSBmbk9yU2VsZihwb2ludHMuc3Ryb2tlKTtcblx0XHR9XG5cblx0XHRpZiAoc2hvd0xlZ2VuZCkge1xuXHRcdFx0bGV0IHJvd0NlbGxzID0gaW5pdExlZ2VuZFJvdyhzLCBpKTtcblx0XHRcdGxlZ2VuZFJvd3Muc3BsaWNlKGksIDAsIHJvd0NlbGxzWzBdKTtcblx0XHRcdGxlZ2VuZENlbGxzLnNwbGljZShpLCAwLCByb3dDZWxsc1sxXSk7XG5cdFx0XHRsZWdlbmQudmFsdWVzLnB1c2gobnVsbCk7XHQvLyBOVUxMX0xFR0VORF9WQUxTIG5vdCB5ZXQgYXZpbCBoZXJlIDooXG5cdFx0fVxuXG5cdFx0aWYgKGN1cnNvci5zaG93KSB7XG5cdFx0XHRsZXQgcHQgPSBpbml0Q3Vyc29yUHQocywgaSk7XG5cdFx0XHRwdCAmJiBjdXJzb3JQdHMuc3BsaWNlKGksIDAsIHB0KTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBhZGRTZXJpZXMob3B0cywgc2kpIHtcblx0XHRzaSA9IHNpID09IG51bGwgPyBzZXJpZXMubGVuZ3RoIDogc2k7XG5cblx0XHRvcHRzID0gc2V0RGVmYXVsdChvcHRzLCBzaSwgeFNlcmllc09wdHMsIHlTZXJpZXNPcHRzKTtcblx0XHRzZXJpZXMuc3BsaWNlKHNpLCAwLCBvcHRzKTtcblx0XHRpbml0U2VyaWVzKHNlcmllc1tzaV0sIHNpKTtcblx0fVxuXG5cdHNlbGYuYWRkU2VyaWVzID0gYWRkU2VyaWVzO1xuXG5cdGZ1bmN0aW9uIGRlbFNlcmllcyhpKSB7XG5cdFx0c2VyaWVzLnNwbGljZShpLCAxKTtcblxuXHRcdGlmIChzaG93TGVnZW5kKSB7XG5cdFx0XHRsZWdlbmQudmFsdWVzLnNwbGljZShpLCAxKTtcblxuXHRcdFx0bGVnZW5kQ2VsbHMuc3BsaWNlKGksIDEpO1xuXHRcdFx0bGV0IHRyID0gbGVnZW5kUm93cy5zcGxpY2UoaSwgMSlbMF07XG5cdFx0XHRvZmZNb3VzZShudWxsLCB0ci5maXJzdENoaWxkKTtcblx0XHRcdHRyLnJlbW92ZSgpO1xuXHRcdH1cblxuXHRcdGN1cnNvclB0cy5sZW5ndGggPiAxICYmIGN1cnNvclB0cy5zcGxpY2UoaSwgMSlbMF0ucmVtb3ZlKCk7XG5cblx0XHQvLyBUT0RPOiBkZS1pbml0IG5vLWxvbmdlci1uZWVkZWQgc2NhbGVzP1xuXHR9XG5cblx0c2VsZi5kZWxTZXJpZXMgPSBkZWxTZXJpZXM7XG5cblx0Y29uc3Qgc2lkZXNXaXRoQXhlcyA9IFtmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZV07XG5cblx0ZnVuY3Rpb24gaW5pdEF4aXMoYXhpcywgaSkge1xuXHRcdGF4aXMuX3Nob3cgPSBheGlzLnNob3c7XG5cblx0XHRpZiAoYXhpcy5zaG93KSB7XG5cdFx0XHRsZXQgaXNWdCA9IGF4aXMuc2lkZSAlIDI7XG5cblx0XHRcdGxldCBzYyA9IHNjYWxlc1theGlzLnNjYWxlXTtcblxuXHRcdFx0Ly8gdGhpcyBjYW4gb2NjdXIgaWYgYWxsIHNlcmllcyBzcGVjaWZ5IG5vbi1kZWZhdWx0IHNjYWxlc1xuXHRcdFx0aWYgKHNjID09IG51bGwpIHtcblx0XHRcdFx0YXhpcy5zY2FsZSA9IGlzVnQgPyBzZXJpZXNbMV0uc2NhbGUgOiB4U2NhbGVLZXk7XG5cdFx0XHRcdHNjID0gc2NhbGVzW2F4aXMuc2NhbGVdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBhbHNvIHNldCBkZWZhdWx0cyBmb3IgaW5jcnMgJiB2YWx1ZXMgYmFzZWQgb24gYXhpcyBkaXN0clxuXHRcdFx0bGV0IGlzVGltZSA9IHNjLnRpbWU7XG5cblx0XHRcdGF4aXMuc2l6ZSAgID0gZm5PclNlbGYoYXhpcy5zaXplKTtcblx0XHRcdGF4aXMuc3BhY2UgID0gZm5PclNlbGYoYXhpcy5zcGFjZSk7XG5cdFx0XHRheGlzLnJvdGF0ZSA9IGZuT3JTZWxmKGF4aXMucm90YXRlKTtcblx0XHRcdGF4aXMuaW5jcnMgID0gZm5PclNlbGYoYXhpcy5pbmNycyAgfHwgKCAgICAgICAgICBzYy5kaXN0ciA9PSAyID8gd2hvbGVJbmNycyA6IChpc1RpbWUgPyAobXMgPT0gMSA/IHRpbWVJbmNyc01zIDogdGltZUluY3JzUykgOiBudW1JbmNycykpKTtcblx0XHRcdGF4aXMuc3BsaXRzID0gZm5PclNlbGYoYXhpcy5zcGxpdHMgfHwgKGlzVGltZSAmJiBzYy5kaXN0ciA9PSAxID8gX3RpbWVBeGlzU3BsaXRzIDogc2MuZGlzdHIgPT0gMyA/IGxvZ0F4aXNTcGxpdHMgOiBzYy5kaXN0ciA9PSA0ID8gYXNpbmhBeGlzU3BsaXRzIDogbnVtQXhpc1NwbGl0cykpO1xuXG5cdFx0XHRheGlzLnN0cm9rZSAgICAgICA9IGZuT3JTZWxmKGF4aXMuc3Ryb2tlKTtcblx0XHRcdGF4aXMuZ3JpZC5zdHJva2UgID0gZm5PclNlbGYoYXhpcy5ncmlkLnN0cm9rZSk7XG5cdFx0XHRheGlzLnRpY2tzLnN0cm9rZSA9IGZuT3JTZWxmKGF4aXMudGlja3Muc3Ryb2tlKTtcblxuXHRcdFx0bGV0IGF2ID0gYXhpcy52YWx1ZXM7XG5cblx0XHRcdGF4aXMudmFsdWVzID0gKFxuXHRcdFx0XHQvLyBzdGF0aWMgYXJyYXkgb2YgdGljayB2YWx1ZXNcblx0XHRcdFx0aXNBcnIoYXYpICYmICFpc0FycihhdlswXSkgPyBmbk9yU2VsZihhdikgOlxuXHRcdFx0XHQvLyB0ZW1wb3JhbFxuXHRcdFx0XHRpc1RpbWUgPyAoXG5cdFx0XHRcdFx0Ly8gY29uZmlnIGFycmF5IG9mIGZtdERhdGUgc3RyaW5nIHRwbHNcblx0XHRcdFx0XHRpc0FycihhdikgP1xuXHRcdFx0XHRcdFx0dGltZUF4aXNWYWxzKF90ekRhdGUsIHRpbWVBeGlzU3RhbXBzKGF2LCBfZm10RGF0ZSkpIDpcblx0XHRcdFx0XHQvLyBmbXREYXRlIHN0cmluZyB0cGxcblx0XHRcdFx0XHRpc1N0cihhdikgP1xuXHRcdFx0XHRcdFx0dGltZUF4aXNWYWwoX3R6RGF0ZSwgYXYpIDpcblx0XHRcdFx0XHRhdiB8fCBfdGltZUF4aXNWYWxzXG5cdFx0XHRcdCkgOiBhdiB8fCBudW1BeGlzVmFsc1xuXHRcdFx0KTtcblxuXHRcdFx0YXhpcy5maWx0ZXIgPSBmbk9yU2VsZihheGlzLmZpbHRlciB8fCAoICAgICAgICAgIHNjLmRpc3RyID49IDMgPyBsb2dBeGlzVmFsc0ZpbHQgOiByZXRBcmcxKSk7XG5cblx0XHRcdGF4aXMuZm9udCAgICAgID0gcHhSYXRpb0ZvbnQoYXhpcy5mb250KTtcblx0XHRcdGF4aXMubGFiZWxGb250ID0gcHhSYXRpb0ZvbnQoYXhpcy5sYWJlbEZvbnQpO1xuXG5cdFx0XHRheGlzLl9zaXplICAgPSBheGlzLnNpemUoc2VsZiwgbnVsbCwgaSwgMCk7XG5cblx0XHRcdGF4aXMuX3NwYWNlICA9XG5cdFx0XHRheGlzLl9yb3RhdGUgPVxuXHRcdFx0YXhpcy5faW5jcnMgID1cblx0XHRcdGF4aXMuX2ZvdW5kICA9XHQvLyBmb3VuZEluY3JTcGFjZVxuXHRcdFx0YXhpcy5fc3BsaXRzID1cblx0XHRcdGF4aXMuX3ZhbHVlcyA9IG51bGw7XG5cblx0XHRcdGlmIChheGlzLl9zaXplID4gMClcblx0XHRcdFx0c2lkZXNXaXRoQXhlc1tpXSA9IHRydWU7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gYXV0b1BhZFNpZGUoc2VsZiwgc2lkZSwgc2lkZXNXaXRoQXhlcywgY3ljbGVOdW0pIHtcblx0XHRsZXQgW2hhc1RvcEF4aXMsIGhhc1JndEF4aXMsIGhhc0J0bUF4aXMsIGhhc0xmdEF4aXNdID0gc2lkZXNXaXRoQXhlcztcblxuXHRcdGxldCBvcmkgPSBzaWRlICUgMjtcblx0XHRsZXQgc2l6ZSA9IDA7XG5cblx0XHRpZiAob3JpID09IDAgJiYgKGhhc0xmdEF4aXMgfHwgaGFzUmd0QXhpcykpXG5cdFx0XHRzaXplID0gKHNpZGUgPT0gMCAmJiAhaGFzVG9wQXhpcyB8fCBzaWRlID09IDIgJiYgIWhhc0J0bUF4aXMgPyByb3VuZCh4QXhpc09wdHMuc2l6ZSAvIDMpIDogMCk7XG5cdFx0aWYgKG9yaSA9PSAxICYmIChoYXNUb3BBeGlzIHx8IGhhc0J0bUF4aXMpKVxuXHRcdFx0c2l6ZSA9IChzaWRlID09IDEgJiYgIWhhc1JndEF4aXMgfHwgc2lkZSA9PSAzICYmICFoYXNMZnRBeGlzID8gcm91bmQoeUF4aXNPcHRzLnNpemUgLyAyKSA6IDApO1xuXG5cdFx0cmV0dXJuIHNpemU7XG5cdH1cblxuXHRjb25zdCBwYWRkaW5nID0gc2VsZi5wYWRkaW5nID0gKG9wdHMucGFkZGluZyB8fCBbYXV0b1BhZFNpZGUsYXV0b1BhZFNpZGUsYXV0b1BhZFNpZGUsYXV0b1BhZFNpZGVdKS5tYXAocCA9PiBmbk9yU2VsZihpZk51bGwocCwgYXV0b1BhZFNpZGUpKSk7XG5cdGNvbnN0IF9wYWRkaW5nID0gc2VsZi5fcGFkZGluZyA9IHBhZGRpbmcubWFwKChwLCBpKSA9PiBwKHNlbGYsIGksIHNpZGVzV2l0aEF4ZXMsIDApKTtcblxuXHRsZXQgZGF0YUxlbjtcblxuXHQvLyByZW5kZXJlZCBkYXRhIHdpbmRvd1xuXHRsZXQgaTAgPSBudWxsO1xuXHRsZXQgaTEgPSBudWxsO1xuXHRjb25zdCBpZHhzID0gc2VyaWVzWzBdLmlkeHM7XG5cblx0bGV0IGRhdGEwID0gbnVsbDtcblxuXHRsZXQgdmlhQXV0b1NjYWxlWCA9IGZhbHNlO1xuXG5cdGZ1bmN0aW9uIHNldERhdGEoX2RhdGEsIF9yZXNldFNjYWxlcykge1xuXHRcdGRhdGEgPSAoX2RhdGEgfHwgW10pLnNsaWNlKCk7XG5cdFx0ZGF0YVswXSA9IGRhdGFbMF0gfHwgW107XG5cblx0XHRzZWxmLmRhdGEgPSBkYXRhLnNsaWNlKCk7XG5cdFx0ZGF0YTAgPSBkYXRhWzBdO1xuXHRcdGRhdGFMZW4gPSBkYXRhMC5sZW5ndGg7XG5cblx0XHRpZiAoeFNjYWxlRGlzdHIgPT0gMilcblx0XHRcdGRhdGFbMF0gPSBkYXRhMC5tYXAoKHYsIGkpID0+IGkpO1xuXG5cdFx0c2VsZi5fZGF0YSA9IGRhdGE7XG5cblx0XHRyZXNldFlTZXJpZXModHJ1ZSk7XG5cblx0XHRmaXJlKFwic2V0RGF0YVwiKTtcblxuXHRcdGlmIChfcmVzZXRTY2FsZXMgIT09IGZhbHNlKSB7XG5cdFx0XHRsZXQgeHNjID0gc2NhbGVYO1xuXG5cdFx0XHRpZiAoeHNjLmF1dG8oc2VsZiwgdmlhQXV0b1NjYWxlWCkpXG5cdFx0XHRcdGF1dG9TY2FsZVgoKTtcblx0XHRcdGVsc2Vcblx0XHRcdFx0X3NldFNjYWxlKHhTY2FsZUtleSwgeHNjLm1pbiwgeHNjLm1heCk7XG5cblx0XHRcdHNob3VsZFNldEN1cnNvciA9IGN1cnNvci5sZWZ0ID49IDA7XG5cdFx0XHRzaG91bGRTZXRMZWdlbmQgPSB0cnVlO1xuXHRcdFx0Y29tbWl0KCk7XG5cdFx0fVxuXHR9XG5cblx0c2VsZi5zZXREYXRhID0gc2V0RGF0YTtcblxuXHRmdW5jdGlvbiBhdXRvU2NhbGVYKCkge1xuXHRcdHZpYUF1dG9TY2FsZVggPSB0cnVlO1xuXG5cdFx0bGV0IF9taW4sIF9tYXg7XG5cblx0XHRpZiAoZGF0YUxlbiA+IDApIHtcblx0XHRcdGkwID0gaWR4c1swXSA9IDA7XG5cdFx0XHRpMSA9IGlkeHNbMV0gPSBkYXRhTGVuIC0gMTtcblxuXHRcdFx0X21pbiA9IGRhdGFbMF1baTBdO1xuXHRcdFx0X21heCA9IGRhdGFbMF1baTFdO1xuXG5cdFx0XHRpZiAoeFNjYWxlRGlzdHIgPT0gMikge1xuXHRcdFx0XHRfbWluID0gaTA7XG5cdFx0XHRcdF9tYXggPSBpMTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKGRhdGFMZW4gPT0gMSkge1xuXHRcdFx0XHRpZiAoeFNjYWxlRGlzdHIgPT0gMylcblx0XHRcdFx0XHRbX21pbiwgX21heF0gPSByYW5nZUxvZyhfbWluLCBfbWluLCBzY2FsZVgubG9nLCBmYWxzZSk7XG5cdFx0XHRcdGVsc2UgaWYgKHhTY2FsZURpc3RyID09IDQpXG5cdFx0XHRcdFx0W19taW4sIF9tYXhdID0gcmFuZ2VBc2luaChfbWluLCBfbWluLCBzY2FsZVgubG9nLCBmYWxzZSk7XG5cdFx0XHRcdGVsc2UgaWYgKHNjYWxlWC50aW1lKVxuXHRcdFx0XHRcdF9tYXggPSBfbWluICsgcm91bmQoODY0MDAgLyBtcyk7XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRbX21pbiwgX21heF0gPSByYW5nZU51bShfbWluLCBfbWF4LCAwLjEsIHRydWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGkwID0gaWR4c1swXSA9IF9taW4gPSBudWxsO1xuXHRcdFx0aTEgPSBpZHhzWzFdID0gX21heCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0X3NldFNjYWxlKHhTY2FsZUtleSwgX21pbiwgX21heCk7XG5cdH1cblxuXHRmdW5jdGlvbiBzZXRDdHhTdHlsZShzdHJva2UsIHdpZHRoLCBkYXNoLCBjYXAsIGZpbGwpIHtcblx0XHRjdHguc3Ryb2tlU3R5bGUgPSBzdHJva2UgfHwgdHJhbnNwYXJlbnQ7XG5cdFx0Y3R4LmxpbmVXaWR0aCA9IHdpZHRoO1xuXHRcdGN0eC5saW5lSm9pbiA9IFwicm91bmRcIjtcblx0XHRjdHgubGluZUNhcCA9IGNhcCB8fCBcImJ1dHRcIjsgLy8gKOKAv3zigL8pXG5cdFx0Y3R4LnNldExpbmVEYXNoKGRhc2ggfHwgW10pO1xuXHRcdGN0eC5maWxsU3R5bGUgPSBmaWxsIHx8IHRyYW5zcGFyZW50O1xuXHR9XG5cblx0ZnVuY3Rpb24gc2V0U2NhbGVzKCkge1xuXHQvL1x0bG9nKFwic2V0U2NhbGVzKClcIiwgYXJndW1lbnRzKTtcblxuXHRcdC8vIHdpcCBzY2FsZXNcblx0XHRsZXQgd2lwU2NhbGVzID0gY29weShzY2FsZXMsIGZhc3RJc09iaik7XG5cblx0XHRmb3IgKGxldCBrIGluIHdpcFNjYWxlcykge1xuXHRcdFx0bGV0IHdzYyA9IHdpcFNjYWxlc1trXTtcblx0XHRcdGxldCBwc2MgPSBwZW5kU2NhbGVzW2tdO1xuXG5cdFx0XHRpZiAocHNjICE9IG51bGwgJiYgcHNjLm1pbiAhPSBudWxsKSB7XG5cdFx0XHRcdGFzc2lnbih3c2MsIHBzYyk7XG5cblx0XHRcdFx0Ly8gZXhwbGljaXRseSBzZXR0aW5nIHRoZSB4LXNjYWxlIGludmFsaWRhdGVzIGV2ZXJ5dGhpbmcgKGFjdHMgYXMgcmVkcmF3KVxuXHRcdFx0XHRpZiAoayA9PSB4U2NhbGVLZXkpXG5cdFx0XHRcdFx0cmVzZXRZU2VyaWVzKHRydWUpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoayAhPSB4U2NhbGVLZXkpIHtcblx0XHRcdFx0aWYgKGRhdGFMZW4gPT0gMCAmJiB3c2MuZnJvbSA9PSBudWxsKSB7XG5cdFx0XHRcdFx0bGV0IG1pbk1heCA9IHdzYy5yYW5nZShzZWxmLCBudWxsLCBudWxsLCBrKTtcblx0XHRcdFx0XHR3c2MubWluID0gbWluTWF4WzBdO1xuXHRcdFx0XHRcdHdzYy5tYXggPSBtaW5NYXhbMV07XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0d3NjLm1pbiA9IGluZjtcblx0XHRcdFx0XHR3c2MubWF4ID0gLWluZjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChkYXRhTGVuID4gMCkge1xuXHRcdFx0Ly8gcHJlLXJhbmdlIHktc2NhbGVzIGZyb20geSBzZXJpZXMnIGRhdGEgdmFsdWVzXG5cdFx0XHRzZXJpZXMuZm9yRWFjaCgocywgaSkgPT4ge1xuXHRcdFx0XHRsZXQgayA9IHMuc2NhbGU7XG5cdFx0XHRcdGxldCB3c2MgPSB3aXBTY2FsZXNba107XG5cdFx0XHRcdGxldCBwc2MgPSBwZW5kU2NhbGVzW2tdO1xuXG5cdFx0XHRcdGlmIChpID09IDApIHtcblx0XHRcdFx0XHRsZXQgbWluTWF4ID0gd3NjLnJhbmdlKHNlbGYsIHdzYy5taW4sIHdzYy5tYXgsIGspO1xuXG5cdFx0XHRcdFx0d3NjLm1pbiA9IG1pbk1heFswXTtcblx0XHRcdFx0XHR3c2MubWF4ID0gbWluTWF4WzFdO1xuXG5cdFx0XHRcdFx0aTAgPSBjbG9zZXN0SWR4KHdzYy5taW4sIGRhdGFbMF0pO1xuXHRcdFx0XHRcdGkxID0gY2xvc2VzdElkeCh3c2MubWF4LCBkYXRhWzBdKTtcblxuXHRcdFx0XHRcdC8vIGNsb3Nlc3QgaW5kaWNlcyBjYW4gYmUgb3V0c2lkZSBvZiB2aWV3XG5cdFx0XHRcdFx0aWYgKGRhdGFbMF1baTBdIDwgd3NjLm1pbilcblx0XHRcdFx0XHRcdGkwKys7XG5cdFx0XHRcdFx0aWYgKGRhdGFbMF1baTFdID4gd3NjLm1heClcblx0XHRcdFx0XHRcdGkxLS07XG5cblx0XHRcdFx0XHRzLm1pbiA9IGRhdGEwW2kwXTtcblx0XHRcdFx0XHRzLm1heCA9IGRhdGEwW2kxXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmIChzLnNob3cgJiYgcy5hdXRvICYmIHdzYy5hdXRvKHNlbGYsIHZpYUF1dG9TY2FsZVgpICYmIChwc2MgPT0gbnVsbCB8fCBwc2MubWluID09IG51bGwpKSB7XG5cdFx0XHRcdFx0Ly8gb25seSBydW4gZ2V0TWluTWF4KCkgZm9yIGludmFsaWRhdGVkIHNlcmllcyBkYXRhLCBlbHNlIHJldXNlXG5cdFx0XHRcdFx0bGV0IG1pbk1heCA9IHMubWluID09IG51bGwgPyAod3NjLmRpc3RyID09IDMgPyBnZXRNaW5NYXhMb2coZGF0YVtpXSwgaTAsIGkxKSA6IGdldE1pbk1heChkYXRhW2ldLCBpMCwgaTEsIHMuc29ydGVkKSkgOiBbcy5taW4sIHMubWF4XTtcblxuXHRcdFx0XHRcdC8vIGluaXRpYWwgbWluL21heFxuXHRcdFx0XHRcdHdzYy5taW4gPSBtaW4od3NjLm1pbiwgcy5taW4gPSBtaW5NYXhbMF0pO1xuXHRcdFx0XHRcdHdzYy5tYXggPSBtYXgod3NjLm1heCwgcy5tYXggPSBtaW5NYXhbMV0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cy5pZHhzWzBdID0gaTA7XG5cdFx0XHRcdHMuaWR4c1sxXSA9IGkxO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIHJhbmdlIGluZGVwZW5kZW50IHNjYWxlc1xuXHRcdFx0Zm9yIChsZXQgayBpbiB3aXBTY2FsZXMpIHtcblx0XHRcdFx0bGV0IHdzYyA9IHdpcFNjYWxlc1trXTtcblx0XHRcdFx0bGV0IHBzYyA9IHBlbmRTY2FsZXNba107XG5cblx0XHRcdFx0aWYgKHdzYy5mcm9tID09IG51bGwgJiYgKHBzYyA9PSBudWxsIHx8IHBzYy5taW4gPT0gbnVsbCkpIHtcblx0XHRcdFx0XHRsZXQgbWluTWF4ID0gd3NjLnJhbmdlKFxuXHRcdFx0XHRcdFx0c2VsZixcblx0XHRcdFx0XHRcdHdzYy5taW4gPT0gIGluZiA/IG51bGwgOiB3c2MubWluLFxuXHRcdFx0XHRcdFx0d3NjLm1heCA9PSAtaW5mID8gbnVsbCA6IHdzYy5tYXgsXG5cdFx0XHRcdFx0XHRrXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR3c2MubWluID0gbWluTWF4WzBdO1xuXHRcdFx0XHRcdHdzYy5tYXggPSBtaW5NYXhbMV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyByYW5nZSBkZXBlbmRlbnQgc2NhbGVzXG5cdFx0Zm9yIChsZXQgayBpbiB3aXBTY2FsZXMpIHtcblx0XHRcdGxldCB3c2MgPSB3aXBTY2FsZXNba107XG5cblx0XHRcdGlmICh3c2MuZnJvbSAhPSBudWxsKSB7XG5cdFx0XHRcdGxldCBiYXNlID0gd2lwU2NhbGVzW3dzYy5mcm9tXTtcblx0XHRcdFx0bGV0IG1pbk1heCA9IHdzYy5yYW5nZShzZWxmLCBiYXNlLm1pbiwgYmFzZS5tYXgsIGspO1xuXHRcdFx0XHR3c2MubWluID0gbWluTWF4WzBdO1xuXHRcdFx0XHR3c2MubWF4ID0gbWluTWF4WzFdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGxldCBjaGFuZ2VkID0ge307XG5cdFx0bGV0IGFueUNoYW5nZWQgPSBmYWxzZTtcblxuXHRcdGZvciAobGV0IGsgaW4gd2lwU2NhbGVzKSB7XG5cdFx0XHRsZXQgd3NjID0gd2lwU2NhbGVzW2tdO1xuXHRcdFx0bGV0IHNjID0gc2NhbGVzW2tdO1xuXG5cdFx0XHRpZiAoc2MubWluICE9IHdzYy5taW4gfHwgc2MubWF4ICE9IHdzYy5tYXgpIHtcblx0XHRcdFx0c2MubWluID0gd3NjLm1pbjtcblx0XHRcdFx0c2MubWF4ID0gd3NjLm1heDtcblxuXHRcdFx0XHRsZXQgZGlzdHIgPSBzYy5kaXN0cjtcblxuXHRcdFx0XHRzYy5fbWluID0gZGlzdHIgPT0gMyA/IGxvZzEwKHNjLm1pbikgOiBkaXN0ciA9PSA0ID8gYXNpbmgoc2MubWluLCBzYy5hc2luaCkgOiBzYy5taW47XG5cdFx0XHRcdHNjLl9tYXggPSBkaXN0ciA9PSAzID8gbG9nMTAoc2MubWF4KSA6IGRpc3RyID09IDQgPyBhc2luaChzYy5tYXgsIHNjLmFzaW5oKSA6IHNjLm1heDtcblxuXHRcdFx0XHRjaGFuZ2VkW2tdID0gYW55Q2hhbmdlZCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGFueUNoYW5nZWQpIHtcblx0XHRcdC8vIGludmFsaWRhdGUgcGF0aHMgb2YgYWxsIHNlcmllcyBvbiBjaGFuZ2VkIHNjYWxlc1xuXHRcdFx0c2VyaWVzLmZvckVhY2gocyA9PiB7XG5cdFx0XHRcdGlmIChjaGFuZ2VkW3Muc2NhbGVdKVxuXHRcdFx0XHRcdHMuX3BhdGhzID0gbnVsbDtcblx0XHRcdH0pO1xuXG5cdFx0XHRmb3IgKGxldCBrIGluIGNoYW5nZWQpIHtcblx0XHRcdFx0c2hvdWxkQ29udmVyZ2VTaXplID0gdHJ1ZTtcblx0XHRcdFx0ZmlyZShcInNldFNjYWxlXCIsIGspO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoY3Vyc29yLnNob3cpXG5cdFx0XHRcdHNob3VsZFNldEN1cnNvciA9IGN1cnNvci5sZWZ0ID49IDA7XG5cdFx0fVxuXG5cdFx0Zm9yIChsZXQgayBpbiBwZW5kU2NhbGVzKVxuXHRcdFx0cGVuZFNjYWxlc1trXSA9IG51bGw7XG5cdH1cblxuXHQvLyBUT0RPOiBkcmF3V3JhcChzaSwgZHJhd1BvaW50cykgKHNhdmUsIHJlc3RvcmUsIHRyYW5zbGF0ZSwgY2xpcClcblx0ZnVuY3Rpb24gZHJhd1BvaW50cyhzaSkge1xuXHQvL1x0bG9nKFwiZHJhd1BvaW50cygpXCIsIGFyZ3VtZW50cyk7XG5cblx0XHRsZXQgcyA9IHNlcmllc1tzaV07XG5cdFx0bGV0IHAgPSBzLnBvaW50cztcblx0XHRsZXQgX3B4Um91bmQgPSBzLnB4Um91bmQ7XG5cblx0XHRjb25zdCB3aWR0aCA9IHJvdW5kRGVjKHAud2lkdGggKiBweFJhdGlvLCAzKTtcblx0XHRjb25zdCBvZmZzZXQgPSAod2lkdGggJSAyKSAvIDI7XG5cdFx0Y29uc3QgaXNTdHJva2VkID0gcC53aWR0aCA+IDA7XG5cblx0XHRsZXQgcmFkID0gKHAuc2l6ZSAtIHAud2lkdGgpIC8gMiAqIHB4UmF0aW87XG5cdFx0bGV0IGRpYSA9IHJvdW5kRGVjKHJhZCAqIDIsIDMpO1xuXG5cdFx0Y29uc3QgX3B4QWxpZ24gPSBzLnB4QWxpZ24gPT0gMTtcblxuXHRcdF9weEFsaWduICYmIGN0eC50cmFuc2xhdGUob2Zmc2V0LCBvZmZzZXQpO1xuXG5cdFx0Y3R4LnNhdmUoKTtcblxuXHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRjdHgucmVjdChcblx0XHRcdHBsb3RMZnQgLSBkaWEsXG5cdFx0XHRwbG90VG9wIC0gZGlhLFxuXHRcdFx0cGxvdFdpZCArIGRpYSAqIDIsXG5cdFx0XHRwbG90SGd0ICsgZGlhICogMixcblx0XHQpO1xuXHRcdGN0eC5jbGlwKCk7XG5cblx0XHRjdHguZ2xvYmFsQWxwaGEgPSBzLmFscGhhO1xuXG5cdFx0Y29uc3QgcGF0aCA9IG5ldyBQYXRoMkQoKTtcblxuXHRcdGNvbnN0IHNjYWxlWSA9IHNjYWxlc1tzLnNjYWxlXTtcblxuXHRcdGxldCB4RGltLCB4T2ZmLCB5RGltLCB5T2ZmO1xuXG5cdFx0aWYgKHNjYWxlWC5vcmkgPT0gMCkge1xuXHRcdFx0eERpbSA9IHBsb3RXaWQ7XG5cdFx0XHR4T2ZmID0gcGxvdExmdDtcblx0XHRcdHlEaW0gPSBwbG90SGd0O1xuXHRcdFx0eU9mZiA9IHBsb3RUb3A7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0eERpbSA9IHBsb3RIZ3Q7XG5cdFx0XHR4T2ZmID0gcGxvdFRvcDtcblx0XHRcdHlEaW0gPSBwbG90V2lkO1xuXHRcdFx0eU9mZiA9IHBsb3RMZnQ7XG5cdFx0fVxuXG5cdFx0Zm9yIChsZXQgcGkgPSBpMDsgcGkgPD0gaTE7IHBpKyspIHtcblx0XHRcdGlmIChkYXRhW3NpXVtwaV0gIT0gbnVsbCkge1xuXHRcdFx0XHRsZXQgeCA9IF9weFJvdW5kKHZhbFRvUG9zWChkYXRhWzBdW3BpXSwgIHNjYWxlWCwgeERpbSwgeE9mZikpO1xuXHRcdFx0XHRsZXQgeSA9IF9weFJvdW5kKHZhbFRvUG9zWShkYXRhW3NpXVtwaV0sIHNjYWxlWSwgeURpbSwgeU9mZikpO1xuXG5cdFx0XHRcdG1vdmVUbyhwYXRoLCB4ICsgcmFkLCB5KTtcblx0XHRcdFx0YXJjKHBhdGgsIHgsIHksIHJhZCwgMCwgUEkgKiAyKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRjb25zdCBfc3Ryb2tlID0gcC5fc3Ryb2tlID0gcC5zdHJva2Uoc2VsZiwgc2kpO1xuXHRcdGNvbnN0IF9maWxsICAgPSBwLl9maWxsICAgPSBwLmZpbGwoc2VsZiwgc2kpO1xuXG5cdFx0c2V0Q3R4U3R5bGUoXG5cdFx0XHRfc3Ryb2tlLFxuXHRcdFx0d2lkdGgsXG5cdFx0XHRwLmRhc2gsXG5cdFx0XHRwLmNhcCxcblx0XHRcdF9maWxsIHx8IChpc1N0cm9rZWQgPyBcIiNmZmZcIiA6IHMuX3N0cm9rZSksXG5cdFx0KTtcblxuXHRcdGN0eC5maWxsKHBhdGgpO1xuXHRcdGlzU3Ryb2tlZCAmJiBjdHguc3Ryb2tlKHBhdGgpO1xuXG5cdFx0Y3R4Lmdsb2JhbEFscGhhID0gMTtcblxuXHRcdGN0eC5yZXN0b3JlKCk7XG5cblx0XHRfcHhBbGlnbiAmJiBjdHgudHJhbnNsYXRlKC1vZmZzZXQsIC1vZmZzZXQpO1xuXHR9XG5cblx0Ly8gZ3JhYnMgdGhlIG5lYXJlc3QgaW5kaWNlcyB3aXRoIHkgZGF0YSBvdXRzaWRlIG9mIHgtc2NhbGUgbGltaXRzXG5cdGZ1bmN0aW9uIGdldE91dGVySWR4cyh5ZGF0YSkge1xuXHRcdGxldCBfaTAgPSBjbGFtcChpMCAtIDEsIDAsIGRhdGFMZW4gLSAxKTtcblx0XHRsZXQgX2kxID0gY2xhbXAoaTEgKyAxLCAwLCBkYXRhTGVuIC0gMSk7XG5cblx0XHR3aGlsZSAoeWRhdGFbX2kwXSA9PSBudWxsICYmIF9pMCA+IDApXG5cdFx0XHRfaTAtLTtcblxuXHRcdHdoaWxlICh5ZGF0YVtfaTFdID09IG51bGwgJiYgX2kxIDwgZGF0YUxlbiAtIDEpXG5cdFx0XHRfaTErKztcblxuXHRcdHJldHVybiBbX2kwLCBfaTFdO1xuXHR9XG5cblx0ZnVuY3Rpb24gZHJhd1NlcmllcygpIHtcblx0XHRpZiAoZGF0YUxlbiA+IDApIHtcblx0XHRcdHNlcmllcy5mb3JFYWNoKChzLCBpKSA9PiB7XG5cdFx0XHRcdGlmIChpID4gMCAmJiBzLnNob3cgJiYgcy5fcGF0aHMgPT0gbnVsbCkge1xuXHRcdFx0XHRcdGxldCBfaWR4cyA9IGdldE91dGVySWR4cyhkYXRhW2ldKTtcblx0XHRcdFx0XHRzLl9wYXRocyA9IHMucGF0aHMoc2VsZiwgaSwgX2lkeHNbMF0sIF9pZHhzWzFdKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdHNlcmllcy5mb3JFYWNoKChzLCBpKSA9PiB7XG5cdFx0XHRcdGlmIChpID4gMCAmJiBzLnNob3cpIHtcblx0XHRcdFx0XHRpZiAocy5fcGF0aHMpXG5cdFx0XHRcdFx0XHRkcmF3UGF0aChpKTtcblxuXHRcdFx0XHRcdGlmIChzLnBvaW50cy5zaG93KHNlbGYsIGksIGkwLCBpMSkpXG5cdFx0XHRcdFx0XHRkcmF3UG9pbnRzKGkpO1xuXG5cdFx0XHRcdFx0ZmlyZShcImRyYXdTZXJpZXNcIiwgaSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGRyYXdQYXRoKHNpKSB7XG5cdFx0Y29uc3QgcyA9IHNlcmllc1tzaV07XG5cblx0XHRjb25zdCB7IHN0cm9rZSwgZmlsbCwgY2xpcCwgZmxhZ3MgfSA9IHMuX3BhdGhzO1xuXHRcdGNvbnN0IHdpZHRoID0gcm91bmREZWMocy53aWR0aCAqIHB4UmF0aW8sIDMpO1xuXHRcdGNvbnN0IG9mZnNldCA9ICh3aWR0aCAlIDIpIC8gMjtcblxuXHRcdGNvbnN0IHN0cm9rZVN0eWxlID0gcy5fc3Ryb2tlID0gcy5zdHJva2Uoc2VsZiwgc2kpO1xuXHRcdGNvbnN0IGZpbGxTdHlsZSAgID0gcy5fZmlsbCAgID0gcy5maWxsKHNlbGYsIHNpKTtcblxuXHRcdGN0eC5nbG9iYWxBbHBoYSA9IHMuYWxwaGE7XG5cblx0XHRjb25zdCBfcHhBbGlnbiA9IHMucHhBbGlnbiA9PSAxO1xuXG5cdFx0X3B4QWxpZ24gJiYgY3R4LnRyYW5zbGF0ZShvZmZzZXQsIG9mZnNldCk7XG5cblx0XHRjdHguc2F2ZSgpO1xuXG5cdFx0bGV0IGxmdCA9IHBsb3RMZnQsXG5cdFx0XHR0b3AgPSBwbG90VG9wLFxuXHRcdFx0d2lkID0gcGxvdFdpZCxcblx0XHRcdGhndCA9IHBsb3RIZ3Q7XG5cblx0XHRsZXQgaGFsZldpZCA9IHdpZHRoICogcHhSYXRpbyAvIDI7XG5cblx0XHRpZiAocy5taW4gPT0gMClcblx0XHRcdGhndCArPSBoYWxmV2lkO1xuXG5cdFx0aWYgKHMubWF4ID09IDApIHtcblx0XHRcdHRvcCAtPSBoYWxmV2lkO1xuXHRcdFx0aGd0ICs9IGhhbGZXaWQ7XG5cdFx0fVxuXG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdGN0eC5yZWN0KGxmdCwgdG9wLCB3aWQsIGhndCk7XG5cdFx0Y3R4LmNsaXAoKTtcblxuXHRcdGNsaXAgJiYgY3R4LmNsaXAoY2xpcCk7XG5cblx0XHRmaWxsU3Ryb2tlKHNpLCBzdHJva2VTdHlsZSwgd2lkdGgsIHMuZGFzaCwgcy5jYXAsIGZpbGxTdHlsZSwgc3Ryb2tlLCBmaWxsLCBmbGFncyk7XG5cblx0XHRjdHgucmVzdG9yZSgpO1xuXG5cdFx0X3B4QWxpZ24gJiYgY3R4LnRyYW5zbGF0ZSgtb2Zmc2V0LCAtb2Zmc2V0KTtcblxuXHRcdGN0eC5nbG9iYWxBbHBoYSA9IDE7XG5cdH1cblxuXHRmdW5jdGlvbiBmaWxsU3Ryb2tlKHNpLCBzdHJva2VTdHlsZSwgbGluZVdpZHRoLCBsaW5lRGFzaCwgbGluZUNhcCwgZmlsbFN0eWxlLCBzdHJva2VQYXRoLCBmaWxsUGF0aCwgZmxhZ3MpIHtcblx0XHRsZXQgZGlkU3Ryb2tlRmlsbCA9IGZhbHNlO1xuXG5cdFx0Ly8gZm9yIGFsbCBiYW5kcyB3aGVyZSB0aGlzIHNlcmllcyBpcyB0aGUgdG9wIGVkZ2UsIGNyZWF0ZSB1cHdhcmRzIGNsaXBzIHVzaW5nIHRoZSBib3R0b20gZWRnZXNcblx0XHQvLyBhbmQgYXBwbHkgY2xpcHMgKyBmaWxsIHdpdGggYmFuZCBmaWxsIG9yIGRmbHRGaWxsXG5cdFx0YmFuZHMuZm9yRWFjaCgoYiwgYmkpID0+IHtcblx0XHRcdC8vIGlzVXBwZXJFZGdlP1xuXHRcdFx0aWYgKGIuc2VyaWVzWzBdID09IHNpKSB7XG5cdFx0XHRcdGxldCBsb3dlckVkZ2UgPSBzZXJpZXNbYi5zZXJpZXNbMV1dO1xuXG5cdFx0XHRcdGxldCBjbGlwID0gKGxvd2VyRWRnZS5fcGF0aHMgfHwgRU1QVFlfT0JKKS5iYW5kO1xuXG5cdFx0XHRcdGN0eC5zYXZlKCk7XG5cblx0XHRcdFx0bGV0IF9maWxsU3R5bGUgPSBudWxsO1xuXG5cdFx0XHRcdC8vIGhhc0xvd2VyRWRnZT9cblx0XHRcdFx0aWYgKGxvd2VyRWRnZS5zaG93ICYmIGNsaXApXG5cdFx0XHRcdFx0X2ZpbGxTdHlsZSA9IGIuZmlsbChzZWxmLCBiaSkgfHwgZmlsbFN0eWxlO1xuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0Y2xpcCA9IG51bGw7XG5cblx0XHRcdFx0c3Ryb2tlRmlsbChzdHJva2VTdHlsZSwgbGluZVdpZHRoLCBsaW5lRGFzaCwgbGluZUNhcCwgX2ZpbGxTdHlsZSwgc3Ryb2tlUGF0aCwgZmlsbFBhdGgsIGNsaXAsIGZsYWdzKTtcblxuXHRcdFx0XHRjdHgucmVzdG9yZSgpO1xuXG5cdFx0XHRcdGRpZFN0cm9rZUZpbGwgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0aWYgKCFkaWRTdHJva2VGaWxsKVxuXHRcdFx0c3Ryb2tlRmlsbChzdHJva2VTdHlsZSwgbGluZVdpZHRoLCBsaW5lRGFzaCwgbGluZUNhcCwgZmlsbFN0eWxlLCBzdHJva2VQYXRoLCBmaWxsUGF0aCwgbnVsbCwgZmxhZ3MpO1xuXHR9XG5cblx0Y29uc3QgQ0xJUF9GSUxMX1NUUk9LRSA9IEJBTkRfQ0xJUF9GSUxMIHwgQkFORF9DTElQX1NUUk9LRTtcblxuXHRmdW5jdGlvbiBzdHJva2VGaWxsKHN0cm9rZVN0eWxlLCBsaW5lV2lkdGgsIGxpbmVEYXNoLCBsaW5lQ2FwLCBmaWxsU3R5bGUsIHN0cm9rZVBhdGgsIGZpbGxQYXRoLCBjbGlwLCBmbGFncykge1xuXHRcdHNldEN0eFN0eWxlKHN0cm9rZVN0eWxlLCBsaW5lV2lkdGgsIGxpbmVEYXNoLCBsaW5lQ2FwLCBmaWxsU3R5bGUpO1xuXG5cdFx0aWYgKGNsaXApIHtcblx0XHRcdGlmICgoZmxhZ3MgJiBDTElQX0ZJTExfU1RST0tFKSA9PSBDTElQX0ZJTExfU1RST0tFKSB7XG5cdFx0XHRcdGN0eC5jbGlwKGNsaXApO1xuXHRcdFx0XHRkb0ZpbGwoZmlsbFN0eWxlLCBmaWxsUGF0aCk7XG5cdFx0XHRcdGRvU3Ryb2tlKHN0cm9rZVN0eWxlLCBzdHJva2VQYXRoLCBsaW5lV2lkdGgpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoZmxhZ3MgJiBCQU5EX0NMSVBfU1RST0tFKSB7XG5cdFx0XHRcdGRvRmlsbChmaWxsU3R5bGUsIGZpbGxQYXRoKTtcblx0XHRcdFx0Y3R4LmNsaXAoY2xpcCk7XG5cdFx0XHRcdGRvU3Ryb2tlKHN0cm9rZVN0eWxlLCBzdHJva2VQYXRoLCBsaW5lV2lkdGgpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoZmxhZ3MgJiBCQU5EX0NMSVBfRklMTCkge1xuXHRcdFx0XHRjdHguc2F2ZSgpO1xuXHRcdFx0XHRjdHguY2xpcChjbGlwKTtcblx0XHRcdFx0ZG9GaWxsKGZpbGxTdHlsZSwgZmlsbFBhdGgpO1xuXHRcdFx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdFx0XHRkb1N0cm9rZShzdHJva2VTdHlsZSwgc3Ryb2tlUGF0aCwgbGluZVdpZHRoKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRkb0ZpbGwoZmlsbFN0eWxlLCBmaWxsUGF0aCk7XG5cdFx0XHRkb1N0cm9rZShzdHJva2VTdHlsZSwgc3Ryb2tlUGF0aCwgbGluZVdpZHRoKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBkb1N0cm9rZShzdHJva2VTdHlsZSwgc3Ryb2tlUGF0aCwgbGluZVdpZHRoKSB7XG5cdFx0c3Ryb2tlU3R5bGUgJiYgc3Ryb2tlUGF0aCAmJiBsaW5lV2lkdGggJiYgY3R4LnN0cm9rZShzdHJva2VQYXRoKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGRvRmlsbChmaWxsU3R5bGUsIGZpbGxQYXRoKSB7XG5cdFx0ZmlsbFN0eWxlICAgJiYgZmlsbFBhdGggJiYgY3R4LmZpbGwoZmlsbFBhdGgpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0SW5jclNwYWNlKGF4aXNJZHgsIG1pbiwgbWF4LCBmdWxsRGltKSB7XG5cdFx0bGV0IGF4aXMgPSBheGVzW2F4aXNJZHhdO1xuXG5cdFx0bGV0IGluY3JTcGFjZTtcblxuXHRcdGlmIChmdWxsRGltIDw9IDApXG5cdFx0XHRpbmNyU3BhY2UgPSBbMCwgMF07XG5cdFx0ZWxzZSB7XG5cdFx0XHRsZXQgbWluU3BhY2UgPSBheGlzLl9zcGFjZSA9IGF4aXMuc3BhY2Uoc2VsZiwgYXhpc0lkeCwgbWluLCBtYXgsIGZ1bGxEaW0pO1xuXHRcdFx0bGV0IGluY3JzICAgID0gYXhpcy5faW5jcnMgPSBheGlzLmluY3JzKHNlbGYsIGF4aXNJZHgsIG1pbiwgbWF4LCBmdWxsRGltLCBtaW5TcGFjZSk7XG5cdFx0XHRpbmNyU3BhY2UgICAgPSBheGlzLl9mb3VuZCA9IGZpbmRJbmNyKG1pbiwgbWF4LCBpbmNycywgZnVsbERpbSwgbWluU3BhY2UpO1xuXHRcdH1cblxuXHRcdHJldHVybiBpbmNyU3BhY2U7XG5cdH1cblxuXHRmdW5jdGlvbiBkcmF3T3J0aG9MaW5lcyhvZmZzLCBmaWx0cywgb3JpLCBzaWRlLCBwb3MwLCBsZW4sIHdpZHRoLCBzdHJva2UsIGRhc2gsIGNhcCkge1xuXHRcdGxldCBvZmZzZXQgPSAod2lkdGggJSAyKSAvIDI7XG5cblx0XHRweEFsaWduID09IDEgJiYgY3R4LnRyYW5zbGF0ZShvZmZzZXQsIG9mZnNldCk7XG5cblx0XHRzZXRDdHhTdHlsZShzdHJva2UsIHdpZHRoLCBkYXNoLCBjYXApO1xuXG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXG5cdFx0bGV0IHgwLCB5MCwgeDEsIHkxLCBwb3MxID0gcG9zMCArIChzaWRlID09IDAgfHwgc2lkZSA9PSAzID8gLWxlbiA6IGxlbik7XG5cblx0XHRpZiAob3JpID09IDApIHtcblx0XHRcdHkwID0gcG9zMDtcblx0XHRcdHkxID0gcG9zMTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHR4MCA9IHBvczA7XG5cdFx0XHR4MSA9IHBvczE7XG5cdFx0fVxuXG5cdFx0b2Zmcy5mb3JFYWNoKChvZmYsIGkpID0+IHtcblx0XHRcdGlmIChmaWx0c1tpXSA9PSBudWxsKVxuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdGlmIChvcmkgPT0gMClcblx0XHRcdFx0eDAgPSB4MSA9IG9mZjtcblx0XHRcdGVsc2Vcblx0XHRcdFx0eTAgPSB5MSA9IG9mZjtcblxuXHRcdFx0Y3R4Lm1vdmVUbyh4MCwgeTApO1xuXHRcdFx0Y3R4LmxpbmVUbyh4MSwgeTEpO1xuXHRcdH0pO1xuXG5cdFx0Y3R4LnN0cm9rZSgpO1xuXG5cdFx0cHhBbGlnbiA9PSAxICYmIGN0eC50cmFuc2xhdGUoLW9mZnNldCwgLW9mZnNldCk7XG5cdH1cblxuXHRmdW5jdGlvbiBheGVzQ2FsYyhjeWNsZU51bSkge1xuXHQvL1x0bG9nKFwiYXhlc0NhbGMoKVwiLCBhcmd1bWVudHMpO1xuXG5cdFx0bGV0IGNvbnZlcmdlZCA9IHRydWU7XG5cblx0XHRheGVzLmZvckVhY2goKGF4aXMsIGkpID0+IHtcblx0XHRcdGlmICghYXhpcy5zaG93KVxuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdGxldCBzY2FsZSA9IHNjYWxlc1theGlzLnNjYWxlXTtcblxuXHRcdFx0aWYgKHNjYWxlLm1pbiA9PSBudWxsKSB7XG5cdFx0XHRcdGlmIChheGlzLl9zaG93KSB7XG5cdFx0XHRcdFx0Y29udmVyZ2VkID0gZmFsc2U7XG5cdFx0XHRcdFx0YXhpcy5fc2hvdyA9IGZhbHNlO1xuXHRcdFx0XHRcdHJlc2V0WVNlcmllcyhmYWxzZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGlmICghYXhpcy5fc2hvdykge1xuXHRcdFx0XHRcdGNvbnZlcmdlZCA9IGZhbHNlO1xuXHRcdFx0XHRcdGF4aXMuX3Nob3cgPSB0cnVlO1xuXHRcdFx0XHRcdHJlc2V0WVNlcmllcyhmYWxzZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0bGV0IHNpZGUgPSBheGlzLnNpZGU7XG5cdFx0XHRsZXQgb3JpID0gc2lkZSAlIDI7XG5cblx0XHRcdGxldCB7bWluLCBtYXh9ID0gc2NhbGU7XHRcdC8vIFx0XHQvLyBzaG91bGQgdGhpcyB0b2dnbGUgdGhlbSAuX3Nob3cgPSBmYWxzZVxuXG5cdFx0XHRsZXQgW19pbmNyLCBfc3BhY2VdID0gZ2V0SW5jclNwYWNlKGksIG1pbiwgbWF4LCBvcmkgPT0gMCA/IHBsb3RXaWRDc3MgOiBwbG90SGd0Q3NzKTtcblxuXHRcdFx0aWYgKF9zcGFjZSA9PSAwKVxuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdC8vIGlmIHdlJ3JlIHVzaW5nIGluZGV4IHBvc2l0aW9ucywgZm9yY2UgZmlyc3QgdGljayB0byBtYXRjaCBwYXNzZWQgaW5kZXhcblx0XHRcdGxldCBmb3JjZU1pbiA9IHNjYWxlLmRpc3RyID09IDI7XG5cblx0XHRcdGxldCBfc3BsaXRzID0gYXhpcy5fc3BsaXRzID0gYXhpcy5zcGxpdHMoc2VsZiwgaSwgbWluLCBtYXgsIF9pbmNyLCBfc3BhY2UsIGZvcmNlTWluKTtcblxuXHRcdFx0Ly8gdGljayBsYWJlbHNcblx0XHRcdC8vIEJPTyB0aGlzIGFzc3VtZXMgYSBzcGVjaWZpYyBkYXRhL3Nlcmllc1xuXHRcdFx0bGV0IHNwbGl0cyA9IHNjYWxlLmRpc3RyID09IDIgPyBfc3BsaXRzLm1hcChpID0+IGRhdGEwW2ldKSA6IF9zcGxpdHM7XG5cdFx0XHRsZXQgaW5jciAgID0gc2NhbGUuZGlzdHIgPT0gMiA/IGRhdGEwW19zcGxpdHNbMV1dIC0gZGF0YTBbX3NwbGl0c1swXV0gOiBfaW5jcjtcblxuXHRcdFx0bGV0IHZhbHVlcyA9IGF4aXMuX3ZhbHVlcyA9IGF4aXMudmFsdWVzKHNlbGYsIGF4aXMuZmlsdGVyKHNlbGYsIHNwbGl0cywgaSwgX3NwYWNlLCBpbmNyKSwgaSwgX3NwYWNlLCBpbmNyKTtcblxuXHRcdFx0Ly8gcm90YXRpbmcgb2YgbGFiZWxzIG9ubHkgc3VwcG9ydGVkIG9uIGJvdHRvbSB4IGF4aXNcblx0XHRcdGF4aXMuX3JvdGF0ZSA9IHNpZGUgPT0gMiA/IGF4aXMucm90YXRlKHNlbGYsIHZhbHVlcywgaSwgX3NwYWNlKSA6IDA7XG5cblx0XHRcdGxldCBvbGRTaXplID0gYXhpcy5fc2l6ZTtcblxuXHRcdFx0YXhpcy5fc2l6ZSA9IGNlaWwoYXhpcy5zaXplKHNlbGYsIHZhbHVlcywgaSwgY3ljbGVOdW0pKTtcblxuXHRcdFx0aWYgKG9sZFNpemUgIT0gbnVsbCAmJiBheGlzLl9zaXplICE9IG9sZFNpemUpXHRcdFx0Ly8gcmVhZHkgJiYgP1xuXHRcdFx0XHRjb252ZXJnZWQgPSBmYWxzZTtcblx0XHR9KTtcblxuXHRcdHJldHVybiBjb252ZXJnZWQ7XG5cdH1cblxuXHRmdW5jdGlvbiBwYWRkaW5nQ2FsYyhjeWNsZU51bSkge1xuXHRcdGxldCBjb252ZXJnZWQgPSB0cnVlO1xuXG5cdFx0cGFkZGluZy5mb3JFYWNoKChwLCBpKSA9PiB7XG5cdFx0XHRsZXQgX3AgPSBwKHNlbGYsIGksIHNpZGVzV2l0aEF4ZXMsIGN5Y2xlTnVtKTtcblxuXHRcdFx0aWYgKF9wICE9IF9wYWRkaW5nW2ldKVxuXHRcdFx0XHRjb252ZXJnZWQgPSBmYWxzZTtcblxuXHRcdFx0X3BhZGRpbmdbaV0gPSBfcDtcblx0XHR9KTtcblxuXHRcdHJldHVybiBjb252ZXJnZWQ7XG5cdH1cblxuXHRmdW5jdGlvbiBkcmF3QXhlc0dyaWQoKSB7XG5cdFx0YXhlcy5mb3JFYWNoKChheGlzLCBpKSA9PiB7XG5cdFx0XHRpZiAoIWF4aXMuc2hvdyB8fCAhYXhpcy5fc2hvdylcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRsZXQgc2NhbGUgPSBzY2FsZXNbYXhpcy5zY2FsZV07XG5cdFx0XHRsZXQgc2lkZSA9IGF4aXMuc2lkZTtcblx0XHRcdGxldCBvcmkgPSBzaWRlICUgMjtcblxuXHRcdFx0bGV0IHBsb3REaW0gPSBvcmkgPT0gMCA/IHBsb3RXaWQgOiBwbG90SGd0O1xuXHRcdFx0bGV0IHBsb3RPZmYgPSBvcmkgPT0gMCA/IHBsb3RMZnQgOiBwbG90VG9wO1xuXG5cdFx0XHRsZXQgYXhpc0dhcCA9IHJvdW5kKGF4aXMuZ2FwICogcHhSYXRpbyk7XG5cblx0XHRcdGxldCBbX2luY3IsIF9zcGFjZV0gPSBheGlzLl9mb3VuZDtcblxuXHRcdFx0bGV0IHgsIHk7XG5cblx0XHRcdGxldCBmaWxsU3R5bGUgPSBheGlzLnN0cm9rZShzZWxmLCBpKTtcblxuXHRcdFx0Ly8gYXhpcyBsYWJlbFxuXHRcdFx0aWYgKGF4aXMubGFiZWwpIHtcblx0XHRcdFx0Y3R4LnNhdmUoKTtcblxuXHRcdFx0XHRsZXQgYmFzZUxwb3MgPSByb3VuZChheGlzLl9scG9zICogcHhSYXRpbyk7XG5cblx0XHRcdFx0aWYgKG9yaSA9PSAxKSB7XG5cdFx0XHRcdFx0eCA9IHkgPSAwO1xuXG5cdFx0XHRcdFx0Y3R4LnRyYW5zbGF0ZShcblx0XHRcdFx0XHRcdGJhc2VMcG9zLFxuXHRcdFx0XHRcdFx0cm91bmQocGxvdFRvcCArIHBsb3RIZ3QgLyAyKSxcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdGN0eC5yb3RhdGUoKHNpZGUgPT0gMyA/IC1QSSA6IFBJKSAvIDIpO1xuXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0eCA9IHJvdW5kKHBsb3RMZnQgKyBwbG90V2lkIC8gMik7XG5cdFx0XHRcdFx0eSA9IGJhc2VMcG9zO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y3R4LmZvbnQgICAgICAgICA9IGF4aXMubGFiZWxGb250WzBdO1xuXHRcdFx0XHRjdHguZmlsbFN0eWxlICAgID0gZmlsbFN0eWxlO1xuXHRcdFx0XHRjdHgudGV4dEFsaWduICAgID0gXCJjZW50ZXJcIjtcblx0XHRcdFx0Y3R4LnRleHRCYXNlbGluZSA9IHNpZGUgPT0gMiA/IFRPUCA6IEJPVFRPTTtcblxuXHRcdFx0XHRjdHguZmlsbFRleHQoYXhpcy5sYWJlbCwgeCwgeSk7XG5cblx0XHRcdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKF9zcGFjZSA9PSAwKVxuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdGxldCBfc3BsaXRzID0gYXhpcy5fc3BsaXRzO1xuXG5cdFx0XHQvLyB0aWNrIGxhYmVsc1xuXHRcdFx0Ly8gQk9PIHRoaXMgYXNzdW1lcyBhIHNwZWNpZmljIGRhdGEvc2VyaWVzXG5cdFx0XHRsZXQgc3BsaXRzID0gc2NhbGUuZGlzdHIgPT0gMiA/IF9zcGxpdHMubWFwKGkgPT4gZGF0YTBbaV0pIDogX3NwbGl0cztcblx0XHRcdGxldCBpbmNyICAgPSBzY2FsZS5kaXN0ciA9PSAyID8gZGF0YTBbX3NwbGl0c1sxXV0gLSBkYXRhMFtfc3BsaXRzWzBdXSA6IF9pbmNyO1xuXG5cdFx0XHRsZXQgdGlja3MgPSBheGlzLnRpY2tzO1xuXHRcdFx0bGV0IHRpY2tTaXplID0gdGlja3Muc2hvdyA/IHJvdW5kKHRpY2tzLnNpemUgKiBweFJhdGlvKSA6IDA7XG5cblx0XHRcdC8vIHJvdGF0aW5nIG9mIGxhYmVscyBvbmx5IHN1cHBvcnRlZCBvbiBib3R0b20geCBheGlzXG5cdFx0XHRsZXQgYW5nbGUgPSBheGlzLl9yb3RhdGUgKiAtUEkvMTgwO1xuXG5cdFx0XHRsZXQgYmFzZVBvcyAgPSBweFJvdW5kKGF4aXMuX3BvcyAqIHB4UmF0aW8pO1xuXHRcdFx0bGV0IHNoaWZ0QW10ID0gdGlja1NpemUgKyBheGlzR2FwO1xuXHRcdFx0bGV0IHNoaWZ0RGlyID0gb3JpID09IDAgJiYgc2lkZSA9PSAwIHx8IG9yaSA9PSAxICYmIHNpZGUgPT0gMyA/IC0xIDogMTtcblx0XHRcdGxldCBmaW5hbFBvcyA9IGJhc2VQb3MgKyBzaGlmdEFtdCAqIHNoaWZ0RGlyO1xuXHRcdFx0ICAgIHkgICAgICAgID0gb3JpID09IDAgPyBmaW5hbFBvcyA6IDA7XG5cdFx0XHQgICAgeCAgICAgICAgPSBvcmkgPT0gMSA/IGZpbmFsUG9zIDogMDtcblxuXHRcdFx0Y3R4LmZvbnQgICAgICAgICA9IGF4aXMuZm9udFswXTtcblx0XHRcdGN0eC5maWxsU3R5bGUgICAgPSBmaWxsU3R5bGU7XG5cdFx0XHRjdHgudGV4dEFsaWduICAgID0gYXhpcy5hbGlnbiA9PSAxID8gTEVGVCA6XG5cdFx0XHQgICAgICAgICAgICAgICAgICAgYXhpcy5hbGlnbiA9PSAyID8gUklHSFQgOlxuXHRcdFx0ICAgICAgICAgICAgICAgICAgIGFuZ2xlID4gMCA/IExFRlQgOlxuXHRcdFx0ICAgICAgICAgICAgICAgICAgIGFuZ2xlIDwgMCA/IFJJR0hUIDpcblx0XHRcdCAgICAgICAgICAgICAgICAgICBvcmkgPT0gMCA/IFwiY2VudGVyXCIgOiBzaWRlID09IDMgPyBSSUdIVCA6IExFRlQ7XG5cdFx0XHRjdHgudGV4dEJhc2VsaW5lID0gYW5nbGUgfHxcblx0XHRcdCAgICAgICAgICAgICAgICAgICBvcmkgPT0gMSA/IFwibWlkZGxlXCIgOiBzaWRlID09IDIgPyBUT1AgICA6IEJPVFRPTTtcblxuXHRcdFx0bGV0IGxpbmVIZWlnaHQgPSBheGlzLmZvbnRbMV0gKiBsaW5lTXVsdDtcblxuXHRcdFx0bGV0IGNhbk9mZnMgPSBfc3BsaXRzLm1hcCh2YWwgPT4gcHhSb3VuZChnZXRQb3ModmFsLCBzY2FsZSwgcGxvdERpbSwgcGxvdE9mZikpKTtcblxuXHRcdFx0YXhpcy5fdmFsdWVzLmZvckVhY2goKHZhbCwgaSkgPT4ge1xuXHRcdFx0XHRpZiAodmFsID09IG51bGwpXG5cdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdGlmIChvcmkgPT0gMClcblx0XHRcdFx0XHR4ID0gY2FuT2Zmc1tpXTtcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdHkgPSBjYW5PZmZzW2ldO1xuXG5cdFx0XHRcdChcIlwiK3ZhbCkuc3BsaXQoL1xcbi9nbSkuZm9yRWFjaCgodGV4dCwgaikgPT4ge1xuXHRcdFx0XHRcdGlmIChhbmdsZSkge1xuXHRcdFx0XHRcdFx0Y3R4LnNhdmUoKTtcblx0XHRcdFx0XHRcdGN0eC50cmFuc2xhdGUoeCwgeSArIGogKiBsaW5lSGVpZ2h0KTtcblx0XHRcdFx0XHRcdGN0eC5yb3RhdGUoYW5nbGUpO1xuXHRcdFx0XHRcdFx0Y3R4LmZpbGxUZXh0KHRleHQsIDAsIDApO1xuXHRcdFx0XHRcdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0Y3R4LmZpbGxUZXh0KHRleHQsIHgsIHkgKyBqICogbGluZUhlaWdodCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIHRpY2tzXG5cdFx0XHRpZiAodGlja3Muc2hvdykge1xuXHRcdFx0XHRkcmF3T3J0aG9MaW5lcyhcblx0XHRcdFx0XHRjYW5PZmZzLFxuXHRcdFx0XHRcdHRpY2tzLmZpbHRlcihzZWxmLCBzcGxpdHMsIGksIF9zcGFjZSwgaW5jciksXG5cdFx0XHRcdFx0b3JpLFxuXHRcdFx0XHRcdHNpZGUsXG5cdFx0XHRcdFx0YmFzZVBvcyxcblx0XHRcdFx0XHR0aWNrU2l6ZSxcblx0XHRcdFx0XHRyb3VuZERlYyh0aWNrcy53aWR0aCAqIHB4UmF0aW8sIDMpLFxuXHRcdFx0XHRcdHRpY2tzLnN0cm9rZShzZWxmLCBpKSxcblx0XHRcdFx0XHR0aWNrcy5kYXNoLFxuXHRcdFx0XHRcdHRpY2tzLmNhcCxcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gZ3JpZFxuXHRcdFx0bGV0IGdyaWQgPSBheGlzLmdyaWQ7XG5cblx0XHRcdGlmIChncmlkLnNob3cpIHtcblx0XHRcdFx0ZHJhd09ydGhvTGluZXMoXG5cdFx0XHRcdFx0Y2FuT2Zmcyxcblx0XHRcdFx0XHRncmlkLmZpbHRlcihzZWxmLCBzcGxpdHMsIGksIF9zcGFjZSwgaW5jciksXG5cdFx0XHRcdFx0b3JpLFxuXHRcdFx0XHRcdG9yaSA9PSAwID8gMiA6IDEsXG5cdFx0XHRcdFx0b3JpID09IDAgPyBwbG90VG9wIDogcGxvdExmdCxcblx0XHRcdFx0XHRvcmkgPT0gMCA/IHBsb3RIZ3QgOiBwbG90V2lkLFxuXHRcdFx0XHRcdHJvdW5kRGVjKGdyaWQud2lkdGggKiBweFJhdGlvLCAzKSxcblx0XHRcdFx0XHRncmlkLnN0cm9rZShzZWxmLCBpKSxcblx0XHRcdFx0XHRncmlkLmRhc2gsXG5cdFx0XHRcdFx0Z3JpZC5jYXAsXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRmaXJlKFwiZHJhd0F4ZXNcIik7XG5cdH1cblxuXHRmdW5jdGlvbiByZXNldFlTZXJpZXMobWluTWF4KSB7XG5cdC8vXHRsb2coXCJyZXNldFlTZXJpZXMoKVwiLCBhcmd1bWVudHMpO1xuXG5cdFx0c2VyaWVzLmZvckVhY2goKHMsIGkpID0+IHtcblx0XHRcdGlmIChpID4gMCkge1xuXHRcdFx0XHRzLl9wYXRocyA9IG51bGw7XG5cblx0XHRcdFx0aWYgKG1pbk1heCkge1xuXHRcdFx0XHRcdHMubWluID0gbnVsbDtcblx0XHRcdFx0XHRzLm1heCA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdGxldCBxdWV1ZWRDb21taXQgPSBmYWxzZTtcblxuXHRmdW5jdGlvbiBjb21taXQoKSB7XG5cdFx0aWYgKCFxdWV1ZWRDb21taXQpIHtcblx0XHRcdG1pY3JvVGFzayhfY29tbWl0KTtcblx0XHRcdHF1ZXVlZENvbW1pdCA9IHRydWU7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gX2NvbW1pdCgpIHtcblx0Ly9cdGxvZyhcIl9jb21taXQoKVwiLCBhcmd1bWVudHMpO1xuXG5cdFx0aWYgKHNob3VsZFNldFNjYWxlcykge1xuXHRcdFx0c2V0U2NhbGVzKCk7XG5cdFx0XHRzaG91bGRTZXRTY2FsZXMgPSBmYWxzZTtcblx0XHR9XG5cblx0XHRpZiAoc2hvdWxkQ29udmVyZ2VTaXplKSB7XG5cdFx0XHRjb252ZXJnZVNpemUoKTtcblx0XHRcdHNob3VsZENvbnZlcmdlU2l6ZSA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdGlmIChzaG91bGRTZXRTaXplKSB7XG5cdFx0XHRzZXRTdHlsZVB4KHVuZGVyLCBMRUZULCAgIHBsb3RMZnRDc3MpO1xuXHRcdFx0c2V0U3R5bGVQeCh1bmRlciwgVE9QLCAgICBwbG90VG9wQ3NzKTtcblx0XHRcdHNldFN0eWxlUHgodW5kZXIsIFdJRFRILCAgcGxvdFdpZENzcyk7XG5cdFx0XHRzZXRTdHlsZVB4KHVuZGVyLCBIRUlHSFQsIHBsb3RIZ3RDc3MpO1xuXG5cdFx0XHRzZXRTdHlsZVB4KG92ZXIsIExFRlQsICAgIHBsb3RMZnRDc3MpO1xuXHRcdFx0c2V0U3R5bGVQeChvdmVyLCBUT1AsICAgICBwbG90VG9wQ3NzKTtcblx0XHRcdHNldFN0eWxlUHgob3ZlciwgV0lEVEgsICAgcGxvdFdpZENzcyk7XG5cdFx0XHRzZXRTdHlsZVB4KG92ZXIsIEhFSUdIVCwgIHBsb3RIZ3RDc3MpO1xuXG5cdFx0XHRzZXRTdHlsZVB4KHdyYXAsIFdJRFRILCAgIGZ1bGxXaWRDc3MpO1xuXHRcdFx0c2V0U3R5bGVQeCh3cmFwLCBIRUlHSFQsICBmdWxsSGd0Q3NzKTtcblxuXHRcdFx0Y2FuLndpZHRoICA9IHJvdW5kKGZ1bGxXaWRDc3MgKiBweFJhdGlvKTtcblx0XHRcdGNhbi5oZWlnaHQgPSByb3VuZChmdWxsSGd0Q3NzICogcHhSYXRpbyk7XG5cblx0XHRcdHN5bmNSZWN0KGZhbHNlKTtcblxuXHRcdFx0ZmlyZShcInNldFNpemVcIik7XG5cblx0XHRcdHNob3VsZFNldFNpemUgPSBmYWxzZTtcblx0XHR9XG5cblx0XHRpZiAoZnVsbFdpZENzcyA+IDAgJiYgZnVsbEhndENzcyA+IDApIHtcblx0XHRcdGN0eC5jbGVhclJlY3QoMCwgMCwgY2FuLndpZHRoLCBjYW4uaGVpZ2h0KTtcblx0XHRcdGZpcmUoXCJkcmF3Q2xlYXJcIik7XG5cdFx0XHRkcmF3T3JkZXIuZm9yRWFjaChmbiA9PiBmbigpKTtcblx0XHRcdGZpcmUoXCJkcmF3XCIpO1xuXHRcdH1cblxuXHQvL1x0aWYgKHNob3VsZFNldFNlbGVjdCkge1xuXHRcdC8vIFRPRE86IHVwZGF0ZSAudS1zZWxlY3QgbWV0cmljcyAoaWYgdmlzaWJsZSlcblx0XHQvL1x0c2V0U3R5bGVQeChzZWxlY3REaXYsIFRPUCwgc2VsZWN0LnRvcCA9IDApO1xuXHRcdC8vXHRzZXRTdHlsZVB4KHNlbGVjdERpdiwgTEVGVCwgc2VsZWN0LmxlZnQgPSAwKTtcblx0XHQvL1x0c2V0U3R5bGVQeChzZWxlY3REaXYsIFdJRFRILCBzZWxlY3Qud2lkdGggPSAwKTtcblx0XHQvL1x0c2V0U3R5bGVQeChzZWxlY3REaXYsIEhFSUdIVCwgc2VsZWN0LmhlaWdodCA9IDApO1xuXHRcdC8vXHRzaG91bGRTZXRTZWxlY3QgPSBmYWxzZTtcblx0Ly9cdH1cblxuXHRcdGlmIChjdXJzb3Iuc2hvdyAmJiBzaG91bGRTZXRDdXJzb3IpIHtcblx0XHRcdHVwZGF0ZUN1cnNvcigpO1xuXHRcdFx0c2hvdWxkU2V0Q3Vyc29yID0gZmFsc2U7XG5cdFx0fVxuXG5cdC8vXHRpZiAoRkVBVF9MRUdFTkQgJiYgbGVnZW5kLnNob3cgJiYgbGVnZW5kLmxpdmUgJiYgc2hvdWxkU2V0TGVnZW5kKSB7fVxuXG5cdFx0aWYgKCFyZWFkeSkge1xuXHRcdFx0cmVhZHkgPSB0cnVlO1xuXHRcdFx0c2VsZi5zdGF0dXMgPSAxO1xuXG5cdFx0XHRmaXJlKFwicmVhZHlcIik7XG5cdFx0fVxuXG5cdFx0dmlhQXV0b1NjYWxlWCA9IGZhbHNlO1xuXG5cdFx0cXVldWVkQ29tbWl0ID0gZmFsc2U7XG5cdH1cblxuXHRzZWxmLnJlZHJhdyA9IChyZWJ1aWxkUGF0aHMsIHJlY2FsY0F4ZXMpID0+IHtcblx0XHRzaG91bGRDb252ZXJnZVNpemUgPSByZWNhbGNBeGVzIHx8IGZhbHNlO1xuXG5cdFx0aWYgKHJlYnVpbGRQYXRocyAhPT0gZmFsc2UpXG5cdFx0XHRfc2V0U2NhbGUoeFNjYWxlS2V5LCBzY2FsZVgubWluLCBzY2FsZVgubWF4KTtcblx0XHRlbHNlXG5cdFx0XHRjb21taXQoKTtcblx0fTtcblxuXHQvLyByZWRyYXcoKSA9PiBzZXRTY2FsZSgneCcsIHNjYWxlcy54Lm1pbiwgc2NhbGVzLngubWF4KTtcblxuXHQvLyBleHBsaWNpdCwgbmV2ZXIgcmUtcmFuZ2VkIChpcyB0aGlzIGFjdHVhbGx5IHRydWU/IGZvciB4IGFuZCB5KVxuXHRmdW5jdGlvbiBzZXRTY2FsZShrZXksIG9wdHMpIHtcblx0XHRsZXQgc2MgPSBzY2FsZXNba2V5XTtcblxuXHRcdGlmIChzYy5mcm9tID09IG51bGwpIHtcblx0XHRcdGlmIChkYXRhTGVuID09IDApIHtcblx0XHRcdFx0bGV0IG1pbk1heCA9IHNjLnJhbmdlKHNlbGYsIG9wdHMubWluLCBvcHRzLm1heCwga2V5KTtcblx0XHRcdFx0b3B0cy5taW4gPSBtaW5NYXhbMF07XG5cdFx0XHRcdG9wdHMubWF4ID0gbWluTWF4WzFdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAob3B0cy5taW4gPiBvcHRzLm1heCkge1xuXHRcdFx0XHRsZXQgX21pbiA9IG9wdHMubWluO1xuXHRcdFx0XHRvcHRzLm1pbiA9IG9wdHMubWF4O1xuXHRcdFx0XHRvcHRzLm1heCA9IF9taW47XG5cdFx0XHR9XG5cblx0XHRcdGlmIChkYXRhTGVuID4gMSAmJiBvcHRzLm1pbiAhPSBudWxsICYmIG9wdHMubWF4ICE9IG51bGwgJiYgb3B0cy5tYXggLSBvcHRzLm1pbiA8IDFlLTE2KVxuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdGlmIChrZXkgPT0geFNjYWxlS2V5KSB7XG5cdFx0XHRcdGlmIChzYy5kaXN0ciA9PSAyICYmIGRhdGFMZW4gPiAwKSB7XG5cdFx0XHRcdFx0b3B0cy5taW4gPSBjbG9zZXN0SWR4KG9wdHMubWluLCBkYXRhWzBdKTtcblx0XHRcdFx0XHRvcHRzLm1heCA9IGNsb3Nlc3RJZHgob3B0cy5tYXgsIGRhdGFbMF0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvL1x0bG9nKFwic2V0U2NhbGUoKVwiLCBhcmd1bWVudHMpO1xuXG5cdFx0XHRwZW5kU2NhbGVzW2tleV0gPSBvcHRzO1xuXG5cdFx0XHRzaG91bGRTZXRTY2FsZXMgPSB0cnVlO1xuXHRcdFx0Y29tbWl0KCk7XG5cdFx0fVxuXHR9XG5cblx0c2VsZi5zZXRTY2FsZSA9IHNldFNjYWxlO1xuXG4vL1x0SU5URVJBQ1RJT05cblxuXHRsZXQgeEN1cnNvcjtcblx0bGV0IHlDdXJzb3I7XG5cdGxldCB2Q3Vyc29yO1xuXHRsZXQgaEN1cnNvcjtcblxuXHQvLyBzdGFydGluZyBwb3NpdGlvbiBiZWZvcmUgY3Vyc29yLm1vdmVcblx0bGV0IHJhd01vdXNlTGVmdDA7XG5cdGxldCByYXdNb3VzZVRvcDA7XG5cblx0Ly8gc3RhcnRpbmcgcG9zaXRpb25cblx0bGV0IG1vdXNlTGVmdDA7XG5cdGxldCBtb3VzZVRvcDA7XG5cblx0Ly8gY3VycmVudCBwb3NpdGlvbiBiZWZvcmUgY3Vyc29yLm1vdmVcblx0bGV0IHJhd01vdXNlTGVmdDE7XG5cdGxldCByYXdNb3VzZVRvcDE7XG5cblx0Ly8gY3VycmVudCBwb3NpdGlvblxuXHRsZXQgbW91c2VMZWZ0MTtcblx0bGV0IG1vdXNlVG9wMTtcblxuXHRsZXQgZHJhZ2dpbmcgPSBmYWxzZTtcblxuXHRjb25zdCBkcmFnID0gY3Vyc29yLmRyYWc7XG5cblx0bGV0IGRyYWdYID0gZHJhZy54O1xuXHRsZXQgZHJhZ1kgPSBkcmFnLnk7XG5cblx0aWYgKGN1cnNvci5zaG93KSB7XG5cdFx0aWYgKGN1cnNvci54KVxuXHRcdFx0eEN1cnNvciA9IHBsYWNlRGl2KENVUlNPUl9YLCBvdmVyKTtcblx0XHRpZiAoY3Vyc29yLnkpXG5cdFx0XHR5Q3Vyc29yID0gcGxhY2VEaXYoQ1VSU09SX1ksIG92ZXIpO1xuXG5cdFx0aWYgKHNjYWxlWC5vcmkgPT0gMCkge1xuXHRcdFx0dkN1cnNvciA9IHhDdXJzb3I7XG5cdFx0XHRoQ3Vyc29yID0geUN1cnNvcjtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHR2Q3Vyc29yID0geUN1cnNvcjtcblx0XHRcdGhDdXJzb3IgPSB4Q3Vyc29yO1xuXHRcdH1cblxuXHRcdG1vdXNlTGVmdDEgPSBjdXJzb3IubGVmdDtcblx0XHRtb3VzZVRvcDEgPSBjdXJzb3IudG9wO1xuXHR9XG5cblx0Y29uc3Qgc2VsZWN0ID0gc2VsZi5zZWxlY3QgPSBhc3NpZ24oe1xuXHRcdHNob3c6ICAgdHJ1ZSxcblx0XHRvdmVyOiAgIHRydWUsXG5cdFx0bGVmdDogICAwLFxuXHRcdHdpZHRoOiAgMCxcblx0XHR0b3A6ICAgIDAsXG5cdFx0aGVpZ2h0OiAwLFxuXHR9LCBvcHRzLnNlbGVjdCk7XG5cblx0Y29uc3Qgc2VsZWN0RGl2ID0gc2VsZWN0LnNob3cgPyBwbGFjZURpdihTRUxFQ1QsIHNlbGVjdC5vdmVyID8gb3ZlciA6IHVuZGVyKSA6IG51bGw7XG5cblx0ZnVuY3Rpb24gc2V0U2VsZWN0KG9wdHMsIF9maXJlKSB7XG5cdFx0aWYgKHNlbGVjdC5zaG93KSB7XG5cdFx0XHRmb3IgKGxldCBwcm9wIGluIG9wdHMpXG5cdFx0XHRcdHNldFN0eWxlUHgoc2VsZWN0RGl2LCBwcm9wLCBzZWxlY3RbcHJvcF0gPSBvcHRzW3Byb3BdKTtcblxuXHRcdFx0X2ZpcmUgIT09IGZhbHNlICYmIGZpcmUoXCJzZXRTZWxlY3RcIik7XG5cdFx0fVxuXHR9XG5cblx0c2VsZi5zZXRTZWxlY3QgPSBzZXRTZWxlY3Q7XG5cblx0ZnVuY3Rpb24gdG9nZ2xlRE9NKGksIG9uT2ZmKSB7XG5cdFx0bGV0IHMgPSBzZXJpZXNbaV07XG5cdFx0bGV0IGxhYmVsID0gc2hvd0xlZ2VuZCA/IGxlZ2VuZFJvd3NbaV0gOiBudWxsO1xuXG5cdFx0aWYgKHMuc2hvdylcblx0XHRcdGxhYmVsICYmIHJlbUNsYXNzKGxhYmVsLCBPRkYpO1xuXHRcdGVsc2Uge1xuXHRcdFx0bGFiZWwgJiYgYWRkQ2xhc3MobGFiZWwsIE9GRik7XG5cdFx0XHRjdXJzb3JQdHMubGVuZ3RoID4gMSAmJiB0cmFucyhjdXJzb3JQdHNbaV0sIC0xMCwgLTEwLCBwbG90V2lkQ3NzLCBwbG90SGd0Q3NzKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBfc2V0U2NhbGUoa2V5LCBtaW4sIG1heCkge1xuXHRcdHNldFNjYWxlKGtleSwge21pbiwgbWF4fSk7XG5cdH1cblxuXHRmdW5jdGlvbiBzZXRTZXJpZXMoaSwgb3B0cywgcHViKSB7XG5cdC8vXHRsb2coXCJzZXRTZXJpZXMoKVwiLCBhcmd1bWVudHMpO1xuXG5cdFx0bGV0IHMgPSBzZXJpZXNbaV07XG5cblx0XHRpZiAob3B0cy5mb2N1cyAhPSBudWxsKVxuXHRcdFx0c2V0Rm9jdXMoaSk7XG5cblx0XHRpZiAob3B0cy5zaG93ICE9IG51bGwpIHtcblx0XHRcdHMuc2hvdyA9IG9wdHMuc2hvdztcblx0XHRcdHRvZ2dsZURPTShpLCBvcHRzLnNob3cpO1xuXG5cdFx0XHRfc2V0U2NhbGUocy5zY2FsZSwgbnVsbCwgbnVsbCk7XG5cdFx0XHRjb21taXQoKTtcblx0XHR9XG5cblx0XHRmaXJlKFwic2V0U2VyaWVzXCIsIGksIG9wdHMpO1xuXG5cdFx0cHViICYmIHB1YlN5bmMoXCJzZXRTZXJpZXNcIiwgc2VsZiwgaSwgb3B0cyk7XG5cdH1cblxuXHRzZWxmLnNldFNlcmllcyA9IHNldFNlcmllcztcblxuXHRmdW5jdGlvbiBzZXRCYW5kKGJpLCBvcHRzKSB7XG5cdFx0YXNzaWduKGJhbmRzW2JpXSwgb3B0cyk7XG5cdH1cblxuXHRmdW5jdGlvbiBhZGRCYW5kKG9wdHMsIGJpKSB7XG5cdFx0b3B0cy5maWxsID0gZm5PclNlbGYob3B0cy5maWxsIHx8IG51bGwpO1xuXHRcdGJpID0gYmkgPT0gbnVsbCA/IGJhbmRzLmxlbmd0aCA6IGJpO1xuXHRcdGJhbmRzLnNwbGljZShiaSwgMCwgb3B0cyk7XG5cdH1cblxuXHRmdW5jdGlvbiBkZWxCYW5kKGJpKSB7XG5cdFx0aWYgKGJpID09IG51bGwpXG5cdFx0XHRiYW5kcy5sZW5ndGggPSAwO1xuXHRcdGVsc2Vcblx0XHRcdGJhbmRzLnNwbGljZShiaSwgMSk7XG5cdH1cblxuXHRzZWxmLmFkZEJhbmQgPSBhZGRCYW5kO1xuXHRzZWxmLnNldEJhbmQgPSBzZXRCYW5kO1xuXHRzZWxmLmRlbEJhbmQgPSBkZWxCYW5kO1xuXG5cdGZ1bmN0aW9uIHNldEFscGhhKGksIHZhbHVlKSB7XG5cdFx0c2VyaWVzW2ldLmFscGhhID0gdmFsdWU7XG5cblx0XHRpZiAoY3Vyc29yLnNob3cgJiYgY3Vyc29yUHRzW2ldKVxuXHRcdFx0Y3Vyc29yUHRzW2ldLnN0eWxlLm9wYWNpdHkgPSB2YWx1ZTtcblxuXHRcdGlmIChzaG93TGVnZW5kICYmIGxlZ2VuZFJvd3NbaV0pXG5cdFx0XHRsZWdlbmRSb3dzW2ldLnN0eWxlLm9wYWNpdHkgPSB2YWx1ZTtcblx0fVxuXG5cdC8vIHktZGlzdGFuY2Vcblx0bGV0IGNsb3Nlc3REaXN0O1xuXHRsZXQgY2xvc2VzdFNlcmllcztcblx0bGV0IGZvY3VzZWRTZXJpZXM7XG5cdGNvbnN0IEZPQ1VTX1RSVUUgID0ge2ZvY3VzOiB0cnVlfTtcblx0Y29uc3QgRk9DVVNfRkFMU0UgPSB7Zm9jdXM6IGZhbHNlfTtcblxuXHRmdW5jdGlvbiBzZXRGb2N1cyhpKSB7XG5cdFx0aWYgKGkgIT0gZm9jdXNlZFNlcmllcykge1xuXHRcdC8vXHRsb2coXCJzZXRGb2N1cygpXCIsIGFyZ3VtZW50cyk7XG5cblx0XHRcdGxldCBhbGxGb2N1c2VkID0gaSA9PSBudWxsO1xuXG5cdFx0XHRsZXQgX3NldEFscGhhID0gZm9jdXMuYWxwaGEgIT0gMTtcblxuXHRcdFx0c2VyaWVzLmZvckVhY2goKHMsIGkyKSA9PiB7XG5cdFx0XHRcdGxldCBpc0ZvY3VzZWQgPSBhbGxGb2N1c2VkIHx8IGkyID09IDAgfHwgaTIgPT0gaTtcblx0XHRcdFx0cy5fZm9jdXMgPSBhbGxGb2N1c2VkID8gbnVsbCA6IGlzRm9jdXNlZDtcblx0XHRcdFx0X3NldEFscGhhICYmIHNldEFscGhhKGkyLCBpc0ZvY3VzZWQgPyAxIDogZm9jdXMuYWxwaGEpO1xuXHRcdFx0fSk7XG5cblx0XHRcdGZvY3VzZWRTZXJpZXMgPSBpO1xuXHRcdFx0X3NldEFscGhhICYmIGNvbW1pdCgpO1xuXHRcdH1cblx0fVxuXG5cdGlmIChzaG93TGVnZW5kICYmIGN1cnNvckZvY3VzKSB7XG5cdFx0b24obW91c2VsZWF2ZSwgbGVnZW5kRWwsIGUgPT4ge1xuXHRcdFx0aWYgKGN1cnNvci5fbG9jaylcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0c2V0U2VyaWVzKG51bGwsIEZPQ1VTX0ZBTFNFLCBzeW5jT3B0cy5zZXRTZXJpZXMpO1xuXHRcdFx0dXBkYXRlQ3Vyc29yKCk7XG5cdFx0fSk7XG5cdH1cblxuXHRmdW5jdGlvbiBwb3NUb1ZhbChwb3MsIHNjYWxlKSB7XG5cdFx0bGV0IHNjID0gc2NhbGVzW3NjYWxlXTtcblxuXHRcdGxldCBkaW0gPSBwbG90V2lkQ3NzO1xuXG5cdFx0aWYgKHNjLm9yaSA9PSAxKSB7XG5cdFx0XHRkaW0gPSBwbG90SGd0Q3NzO1xuXHRcdFx0cG9zID0gZGltIC0gcG9zO1xuXHRcdH1cblxuXHRcdGlmIChzYy5kaXIgPT0gLTEpXG5cdFx0XHRwb3MgPSBkaW0gLSBwb3M7XG5cblx0XHRsZXQgX21pbiA9IHNjLl9taW4sXG5cdFx0XHRfbWF4ID0gc2MuX21heCxcblx0XHRcdHBjdCA9IHBvcyAvIGRpbTtcblxuXHRcdGxldCBzdiA9IF9taW4gKyAoX21heCAtIF9taW4pICogcGN0O1xuXG5cdFx0bGV0IGRpc3RyID0gc2MuZGlzdHI7XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0ZGlzdHIgPT0gMyA/IHBvdygxMCwgc3YpIDpcblx0XHRcdGRpc3RyID09IDQgPyBzaW5oKHN2LCBzYy5hc2luaCkgOlxuXHRcdFx0c3Zcblx0XHQpO1xuXHR9XG5cblx0ZnVuY3Rpb24gY2xvc2VzdElkeEZyb21YcG9zKHBvcykge1xuXHRcdGxldCB2ID0gcG9zVG9WYWwocG9zLCB4U2NhbGVLZXkpO1xuXHRcdHJldHVybiBjbG9zZXN0SWR4KHYsIGRhdGFbMF0sIGkwLCBpMSk7XG5cdH1cblxuXHRzZWxmLnZhbFRvSWR4ID0gdmFsID0+IGNsb3Nlc3RJZHgodmFsLCBkYXRhWzBdKTtcblx0c2VsZi5wb3NUb0lkeCA9IGNsb3Nlc3RJZHhGcm9tWHBvcztcblx0c2VsZi5wb3NUb1ZhbCA9IHBvc1RvVmFsO1xuXHRzZWxmLnZhbFRvUG9zID0gKHZhbCwgc2NhbGUsIGNhbikgPT4gKFxuXHRcdHNjYWxlc1tzY2FsZV0ub3JpID09IDAgP1xuXHRcdGdldEhQb3ModmFsLCBzY2FsZXNbc2NhbGVdLFxuXHRcdFx0Y2FuID8gcGxvdFdpZCA6IHBsb3RXaWRDc3MsXG5cdFx0XHRjYW4gPyBwbG90TGZ0IDogMCxcblx0XHQpIDpcblx0XHRnZXRWUG9zKHZhbCwgc2NhbGVzW3NjYWxlXSxcblx0XHRcdGNhbiA/IHBsb3RIZ3QgOiBwbG90SGd0Q3NzLFxuXHRcdFx0Y2FuID8gcGxvdFRvcCA6IDAsXG5cdFx0KVxuXHQpO1xuXG5cdC8vIGRlZmVycyBjYWxsaW5nIGV4cGVuc2l2ZSBmdW5jdGlvbnNcblx0ZnVuY3Rpb24gYmF0Y2goZm4pIHtcblx0XHRmbihzZWxmKTtcblx0XHRjb21taXQoKTtcblx0fVxuXG5cdHNlbGYuYmF0Y2ggPSBiYXRjaDtcblxuXHQoc2VsZi5zZXRDdXJzb3IgPSAob3B0cywgX2ZpcmUpID0+IHtcblx0XHRtb3VzZUxlZnQxID0gb3B0cy5sZWZ0O1xuXHRcdG1vdXNlVG9wMSA9IG9wdHMudG9wO1xuXHQvL1x0YXNzaWduKGN1cnNvciwgb3B0cyk7XG5cdFx0dXBkYXRlQ3Vyc29yKG51bGwsIG51bGwsIF9maXJlKTtcblx0fSk7XG5cblx0ZnVuY3Rpb24gc2V0U2VsSChvZmYsIGRpbSkge1xuXHRcdHNldFN0eWxlUHgoc2VsZWN0RGl2LCBMRUZULCAgc2VsZWN0LmxlZnQgPSBvZmYpO1xuXHRcdHNldFN0eWxlUHgoc2VsZWN0RGl2LCBXSURUSCwgc2VsZWN0LndpZHRoID0gZGltKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNldFNlbFYob2ZmLCBkaW0pIHtcblx0XHRzZXRTdHlsZVB4KHNlbGVjdERpdiwgVE9QLCAgICBzZWxlY3QudG9wID0gb2ZmKTtcblx0XHRzZXRTdHlsZVB4KHNlbGVjdERpdiwgSEVJR0hULCBzZWxlY3QuaGVpZ2h0ID0gZGltKTtcblx0fVxuXG5cdGxldCBzZXRTZWxYID0gc2NhbGVYLm9yaSA9PSAwID8gc2V0U2VsSCA6IHNldFNlbFY7XG5cdGxldCBzZXRTZWxZID0gc2NhbGVYLm9yaSA9PSAxID8gc2V0U2VsSCA6IHNldFNlbFY7XG5cblx0ZnVuY3Rpb24gc3luY0xlZ2VuZCgpIHtcblx0XHRpZiAoc2hvd0xlZ2VuZCAmJiBsZWdlbmQubGl2ZSkge1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBzZXJpZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKGkgPT0gMCAmJiBtdWx0aVZhbExlZ2VuZClcblx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHRsZXQgdmFscyA9IGxlZ2VuZC52YWx1ZXNbaV07XG5cblx0XHRcdFx0bGV0IGogPSAwO1xuXG5cdFx0XHRcdGZvciAobGV0IGsgaW4gdmFscylcblx0XHRcdFx0XHRsZWdlbmRDZWxsc1tpXVtqKytdLmZpcnN0Q2hpbGQubm9kZVZhbHVlID0gdmFsc1trXTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBzZXRMZWdlbmQob3B0cywgX2ZpcmUpIHtcblx0XHRpZiAob3B0cyAhPSBudWxsKSB7XG5cdFx0XHRsZXQgaWR4ID0gb3B0cy5pZHg7XG5cblx0XHRcdGxlZ2VuZC5pZHggPSBpZHg7XG5cdFx0XHRzZXJpZXMuZm9yRWFjaCgocywgc2lkeCkgPT4ge1xuXHRcdFx0XHQoc2lkeCA+IDAgfHwgIW11bHRpVmFsTGVnZW5kKSAmJiBzZXRMZWdlbmRWYWx1ZXMoc2lkeCwgaWR4KTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGlmIChzaG93TGVnZW5kICYmIGxlZ2VuZC5saXZlKVxuXHRcdFx0c3luY0xlZ2VuZCgpO1xuXG5cdFx0c2hvdWxkU2V0TGVnZW5kID0gZmFsc2U7XG5cblx0XHRfZmlyZSAhPT0gZmFsc2UgJiYgZmlyZShcInNldExlZ2VuZFwiKTtcblx0fVxuXG5cdHNlbGYuc2V0TGVnZW5kID0gc2V0TGVnZW5kO1xuXG5cdGZ1bmN0aW9uIHNldExlZ2VuZFZhbHVlcyhzaWR4LCBpZHgpIHtcblx0XHRsZXQgdmFsO1xuXG5cdFx0aWYgKGlkeCA9PSBudWxsKVxuXHRcdFx0dmFsID0gTlVMTF9MRUdFTkRfVkFMVUVTO1xuXHRcdGVsc2Uge1xuXHRcdFx0bGV0IHMgPSBzZXJpZXNbc2lkeF07XG5cdFx0XHRsZXQgc3JjID0gc2lkeCA9PSAwICYmIHhTY2FsZURpc3RyID09IDIgPyBkYXRhMCA6IGRhdGFbc2lkeF07XG5cdFx0XHR2YWwgPSBtdWx0aVZhbExlZ2VuZCA/IHMudmFsdWVzKHNlbGYsIHNpZHgsIGlkeCkgOiB7Xzogcy52YWx1ZShzZWxmLCBzcmNbaWR4XSwgc2lkeCwgaWR4KX07XG5cdFx0fVxuXG5cdFx0bGVnZW5kLnZhbHVlc1tzaWR4XSA9IHZhbDtcblx0fVxuXG5cdGZ1bmN0aW9uIHVwZGF0ZUN1cnNvcih0cywgc3JjLCBfZmlyZSkge1xuXHQvL1x0dHMgPT0gbnVsbCAmJiBsb2coXCJ1cGRhdGVDdXJzb3IoKVwiLCBhcmd1bWVudHMpO1xuXG5cdFx0cmF3TW91c2VMZWZ0MSA9IG1vdXNlTGVmdDE7XG5cdFx0cmF3TW91c2VUb3AxID0gbW91c2VUb3AxO1xuXG5cdFx0W21vdXNlTGVmdDEsIG1vdXNlVG9wMV0gPSBjdXJzb3IubW92ZShzZWxmLCBtb3VzZUxlZnQxLCBtb3VzZVRvcDEpO1xuXG5cdFx0aWYgKGN1cnNvci5zaG93KSB7XG5cdFx0XHR2Q3Vyc29yICYmIHRyYW5zKHZDdXJzb3IsIHJvdW5kKG1vdXNlTGVmdDEpLCAwLCBwbG90V2lkQ3NzLCBwbG90SGd0Q3NzKTtcblx0XHRcdGhDdXJzb3IgJiYgdHJhbnMoaEN1cnNvciwgMCwgcm91bmQobW91c2VUb3AxKSwgcGxvdFdpZENzcywgcGxvdEhndENzcyk7XG5cdFx0fVxuXG5cdFx0bGV0IGlkeDtcblx0XHRsZXQgaWR4Q2hhbmdlZCA9IGZhbHNlO1xuXG5cdFx0Ly8gd2hlbiB6b29taW5nIHRvIGFuIHggc2NhbGUgcmFuZ2UgYmV0d2VlbiBkYXRhcG9pbnRzIHRoZSBiaW5hcnkgc2VhcmNoXG5cdFx0Ly8gZm9yIG5lYXJlc3QgbWluL21heCBpbmRpY2VzIHJlc3VsdHMgaW4gdGhpcyBjb25kaXRpb24uIGNoZWFwIGhhY2sgOkRcblx0XHRsZXQgbm9EYXRhSW5SYW5nZSA9IGkwID4gaTE7XG5cblx0XHRjbG9zZXN0RGlzdCA9IGluZjtcblxuXHRcdC8vIFRPRE86IGV4dHJhY3Rcblx0XHRsZXQgeERpbSA9IHNjYWxlWC5vcmkgPT0gMCA/IHBsb3RXaWRDc3MgOiBwbG90SGd0Q3NzO1xuXHRcdGxldCB5RGltID0gc2NhbGVYLm9yaSA9PSAxID8gcGxvdFdpZENzcyA6IHBsb3RIZ3RDc3M7XG5cblx0XHQvLyBpZiBjdXJzb3IgaGlkZGVuLCBoaWRlIHBvaW50cyAmIGNsZWFyIGxlZ2VuZCB2YWxzXG5cdFx0aWYgKG1vdXNlTGVmdDEgPCAwIHx8IGRhdGFMZW4gPT0gMCB8fCBub0RhdGFJblJhbmdlKSB7XG5cdFx0XHRpZHggPSBudWxsO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHNlcmllcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAoaSA+IDApIHtcblx0XHRcdFx0XHRjdXJzb3JQdHMubGVuZ3RoID4gMSAmJiB0cmFucyhjdXJzb3JQdHNbaV0sIC0xMCwgLTEwLCBwbG90V2lkQ3NzLCBwbG90SGd0Q3NzKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoY3Vyc29yRm9jdXMpXG5cdFx0XHRcdHNldFNlcmllcyhudWxsLCBGT0NVU19UUlVFLCBzeW5jT3B0cy5zZXRTZXJpZXMpO1xuXG5cdFx0XHRpZiAobGVnZW5kLmxpdmUpIHtcblx0XHRcdFx0aWR4Q2hhbmdlZCA9IHRydWU7XG5cblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBzZXJpZXMubGVuZ3RoOyBpKyspXG5cdFx0XHRcdFx0bGVnZW5kLnZhbHVlc1tpXSA9IE5VTExfTEVHRU5EX1ZBTFVFUztcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0Ly9cdGxldCBwY3RZID0gMSAtICh5IC8gcmVjdC5oZWlnaHQpO1xuXG5cdFx0XHRsZXQgbW91c2VYUG9zID0gc2NhbGVYLm9yaSA9PSAwID8gbW91c2VMZWZ0MSA6IG1vdXNlVG9wMTtcblxuXHRcdFx0bGV0IHZhbEF0UG9zWCA9IHBvc1RvVmFsKG1vdXNlWFBvcywgeFNjYWxlS2V5KTtcblxuXHRcdFx0aWR4ID0gY2xvc2VzdElkeCh2YWxBdFBvc1gsIGRhdGFbMF0sIGkwLCBpMSk7XG5cblx0XHRcdGxldCB4UG9zID0gaW5jclJvdW5kVXAodmFsVG9Qb3NYKGRhdGFbMF1baWR4XSwgc2NhbGVYLCB4RGltLCAwKSwgMC41KTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBzZXJpZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0bGV0IHMgPSBzZXJpZXNbaV07XG5cblx0XHRcdFx0bGV0IGlkeDIgID0gY3Vyc29yLmRhdGFJZHgoc2VsZiwgaSwgaWR4LCB2YWxBdFBvc1gpO1xuXHRcdFx0XHRsZXQgeFBvczIgPSBpZHgyID09IGlkeCA/IHhQb3MgOiBpbmNyUm91bmRVcCh2YWxUb1Bvc1goZGF0YVswXVtpZHgyXSwgc2NhbGVYLCB4RGltLCAwKSwgMC41KTtcblxuXHRcdFx0XHRpZiAoaSA+IDAgJiYgcy5zaG93KSB7XG5cdFx0XHRcdFx0bGV0IHZhbEF0SWR4ID0gZGF0YVtpXVtpZHgyXTtcblxuXHRcdFx0XHRcdGxldCB5UG9zID0gdmFsQXRJZHggPT0gbnVsbCA/IC0xMCA6IGluY3JSb3VuZFVwKHZhbFRvUG9zWSh2YWxBdElkeCwgc2NhbGVzW3Muc2NhbGVdLCB5RGltLCAwKSwgMC41KTtcblxuXHRcdFx0XHRcdGlmICh5UG9zID4gMCkge1xuXHRcdFx0XHRcdFx0bGV0IGRpc3QgPSBhYnMoeVBvcyAtIG1vdXNlVG9wMSk7XG5cblx0XHRcdFx0XHRcdGlmIChkaXN0IDw9IGNsb3Nlc3REaXN0KSB7XG5cdFx0XHRcdFx0XHRcdGNsb3Nlc3REaXN0ID0gZGlzdDtcblx0XHRcdFx0XHRcdFx0Y2xvc2VzdFNlcmllcyA9IGk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0bGV0IGhQb3MsIHZQb3M7XG5cblx0XHRcdFx0XHRpZiAoc2NhbGVYLm9yaSA9PSAwKSB7XG5cdFx0XHRcdFx0XHRoUG9zID0geFBvczI7XG5cdFx0XHRcdFx0XHR2UG9zID0geVBvcztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRoUG9zID0geVBvcztcblx0XHRcdFx0XHRcdHZQb3MgPSB4UG9zMjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjdXJzb3JQdHMubGVuZ3RoID4gMSAmJiB0cmFucyhjdXJzb3JQdHNbaV0sIGhQb3MsIHZQb3MsIHBsb3RXaWRDc3MsIHBsb3RIZ3RDc3MpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGxlZ2VuZC5saXZlKSB7XG5cdFx0XHRcdFx0aWYgKChpZHgyID09IGN1cnNvci5pZHggJiYgIXNob3VsZFNldExlZ2VuZCkgfHwgaSA9PSAwICYmIG11bHRpVmFsTGVnZW5kKVxuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0XHRpZHhDaGFuZ2VkID0gdHJ1ZTtcblxuXHRcdFx0XHRcdHNldExlZ2VuZFZhbHVlcyhpLCBpZHgyKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChpZHhDaGFuZ2VkKSB7XG5cdFx0XHRsZWdlbmQuaWR4ID0gaWR4O1xuXHRcdFx0c2V0TGVnZW5kKCk7XG5cdFx0fVxuXG5cdFx0Ly8gbml0OiBjdXJzb3IuZHJhZy5zZXRTZWxlY3QgaXMgYXNzdW1lZCBhbHdheXMgdHJ1ZVxuXHRcdGlmIChzZWxlY3Quc2hvdyAmJiBkcmFnZ2luZykge1xuXHRcdFx0aWYgKHNyYyAhPSBudWxsKSB7XG5cdFx0XHRcdGxldCBbeEtleSwgeUtleV0gPSBzeW5jT3B0cy5zY2FsZXM7XG5cdFx0XHRcdGxldCBbbWF0Y2hYS2V5cywgbWF0Y2hZS2V5c10gPSBzeW5jT3B0cy5tYXRjaDtcblx0XHRcdFx0bGV0IFt4S2V5U3JjLCB5S2V5U3JjXSA9IHNyYy5jdXJzb3Iuc3luYy5zY2FsZXM7XG5cblx0XHRcdFx0Ly8gbWF0Y2ggdGhlIGRyYWdYL2RyYWdZIGltcGxpY2l0bmVzcy9leHBsaWNpdG5lc3Mgb2Ygc3JjXG5cdFx0XHRcdGxldCBzZHJhZyA9IHNyYy5jdXJzb3IuZHJhZztcblx0XHRcdFx0ZHJhZ1ggPSBzZHJhZy5feDtcblx0XHRcdFx0ZHJhZ1kgPSBzZHJhZy5feTtcblxuXHRcdFx0XHRsZXQgeyBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQgfSA9IHNyYy5zZWxlY3Q7XG5cblx0XHRcdFx0bGV0IHNvcmkgPSBzcmMuc2NhbGVzW3hLZXldLm9yaTtcblx0XHRcdFx0bGV0IHNQb3NUb1ZhbCA9IHNyYy5wb3NUb1ZhbDtcblxuXHRcdFx0XHRsZXQgc09mZiwgc0RpbSwgc2MsIGEsIGI7XG5cblx0XHRcdFx0bGV0IG1hdGNoaW5nWCA9IHhLZXkgIT0gbnVsbCAmJiBtYXRjaFhLZXlzKHhLZXksIHhLZXlTcmMpO1xuXHRcdFx0XHRsZXQgbWF0Y2hpbmdZID0geUtleSAhPSBudWxsICYmIG1hdGNoWUtleXMoeUtleSwgeUtleVNyYyk7XG5cblx0XHRcdFx0aWYgKG1hdGNoaW5nWCkge1xuXHRcdFx0XHRcdGlmIChzb3JpID09IDApIHtcblx0XHRcdFx0XHRcdHNPZmYgPSBsZWZ0O1xuXHRcdFx0XHRcdFx0c0RpbSA9IHdpZHRoO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdHNPZmYgPSB0b3A7XG5cdFx0XHRcdFx0XHRzRGltID0gaGVpZ2h0O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChkcmFnWCkge1xuXHRcdFx0XHRcdFx0c2MgPSBzY2FsZXNbeEtleV07XG5cblx0XHRcdFx0XHRcdGEgPSB2YWxUb1Bvc1goc1Bvc1RvVmFsKHNPZmYsIHhLZXlTcmMpLCAgICAgICAgc2MsIHhEaW0sIDApO1xuXHRcdFx0XHRcdFx0YiA9IHZhbFRvUG9zWChzUG9zVG9WYWwoc09mZiArIHNEaW0sIHhLZXlTcmMpLCBzYywgeERpbSwgMCk7XG5cblx0XHRcdFx0XHRcdHNldFNlbFgobWluKGEsYiksIGFicyhiLWEpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0c2V0U2VsWCgwLCB4RGltKTtcblxuXHRcdFx0XHRcdGlmICghbWF0Y2hpbmdZKVxuXHRcdFx0XHRcdFx0c2V0U2VsWSgwLCB5RGltKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChtYXRjaGluZ1kpIHtcblx0XHRcdFx0XHRpZiAoc29yaSA9PSAxKSB7XG5cdFx0XHRcdFx0XHRzT2ZmID0gbGVmdDtcblx0XHRcdFx0XHRcdHNEaW0gPSB3aWR0aDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRzT2ZmID0gdG9wO1xuXHRcdFx0XHRcdFx0c0RpbSA9IGhlaWdodDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoZHJhZ1kpIHtcblx0XHRcdFx0XHRcdHNjID0gc2NhbGVzW3lLZXldO1xuXG5cdFx0XHRcdFx0XHRhID0gdmFsVG9Qb3NZKHNQb3NUb1ZhbChzT2ZmLCB5S2V5U3JjKSwgICAgICAgIHNjLCB5RGltLCAwKTtcblx0XHRcdFx0XHRcdGIgPSB2YWxUb1Bvc1koc1Bvc1RvVmFsKHNPZmYgKyBzRGltLCB5S2V5U3JjKSwgc2MsIHlEaW0sIDApO1xuXG5cdFx0XHRcdFx0XHRzZXRTZWxZKG1pbihhLGIpLCBhYnMoYi1hKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdHNldFNlbFkoMCwgeURpbSk7XG5cblx0XHRcdFx0XHRpZiAoIW1hdGNoaW5nWClcblx0XHRcdFx0XHRcdHNldFNlbFgoMCwgeERpbSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRsZXQgcmF3RFggPSBhYnMocmF3TW91c2VMZWZ0MSAtIHJhd01vdXNlTGVmdDApO1xuXHRcdFx0XHRsZXQgcmF3RFkgPSBhYnMocmF3TW91c2VUb3AxIC0gcmF3TW91c2VUb3AwKTtcblxuXHRcdFx0XHRpZiAoc2NhbGVYLm9yaSA9PSAxKSB7XG5cdFx0XHRcdFx0bGV0IF9yYXdEWCA9IHJhd0RYO1xuXHRcdFx0XHRcdHJhd0RYID0gcmF3RFk7XG5cdFx0XHRcdFx0cmF3RFkgPSBfcmF3RFg7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkcmFnWCA9IGRyYWcueCAmJiByYXdEWCA+PSBkcmFnLmRpc3Q7XG5cdFx0XHRcdGRyYWdZID0gZHJhZy55ICYmIHJhd0RZID49IGRyYWcuZGlzdDtcblxuXHRcdFx0XHRsZXQgdW5pID0gZHJhZy51bmk7XG5cblx0XHRcdFx0aWYgKHVuaSAhPSBudWxsKSB7XG5cdFx0XHRcdFx0Ly8gb25seSBjYWxjIGRyYWcgc3RhdHVzIGlmIHRoZXkgcGFzcyB0aGUgZGlzdCB0aHJlc2hcblx0XHRcdFx0XHRpZiAoZHJhZ1ggJiYgZHJhZ1kpIHtcblx0XHRcdFx0XHRcdGRyYWdYID0gcmF3RFggPj0gdW5pO1xuXHRcdFx0XHRcdFx0ZHJhZ1kgPSByYXdEWSA+PSB1bmk7XG5cblx0XHRcdFx0XHRcdC8vIGZvcmNlIHVuaWRpcmVjdGlvbmFsaXR5IHdoZW4gYm90aCBhcmUgdW5kZXIgdW5pIGxpbWl0XG5cdFx0XHRcdFx0XHRpZiAoIWRyYWdYICYmICFkcmFnWSkge1xuXHRcdFx0XHRcdFx0XHRpZiAocmF3RFkgPiByYXdEWClcblx0XHRcdFx0XHRcdFx0XHRkcmFnWSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdFx0XHRkcmFnWCA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKGRyYWcueCAmJiBkcmFnLnkgJiYgKGRyYWdYIHx8IGRyYWdZKSlcblx0XHRcdFx0XHQvLyBpZiBvbW5pIHdpdGggbm8gdW5pIHRoZW4gYm90aCBkcmFnWCAvIGRyYWdZIHNob3VsZCBiZSB0cnVlIGlmIGVpdGhlciBpcyB0cnVlXG5cdFx0XHRcdFx0ZHJhZ1ggPSBkcmFnWSA9IHRydWU7XG5cblx0XHRcdFx0bGV0IHAwLCBwMTtcblxuXHRcdFx0XHRpZiAoZHJhZ1gpIHtcblx0XHRcdFx0XHRpZiAoc2NhbGVYLm9yaSA9PSAwKSB7XG5cdFx0XHRcdFx0XHRwMCA9IG1vdXNlTGVmdDA7XG5cdFx0XHRcdFx0XHRwMSA9IG1vdXNlTGVmdDE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0cDAgPSBtb3VzZVRvcDA7XG5cdFx0XHRcdFx0XHRwMSA9IG1vdXNlVG9wMTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRzZXRTZWxYKG1pbihwMCwgcDEpLCBhYnMocDEgLSBwMCkpO1xuXG5cdFx0XHRcdFx0aWYgKCFkcmFnWSlcblx0XHRcdFx0XHRcdHNldFNlbFkoMCwgeURpbSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoZHJhZ1kpIHtcblx0XHRcdFx0XHRpZiAoc2NhbGVYLm9yaSA9PSAxKSB7XG5cdFx0XHRcdFx0XHRwMCA9IG1vdXNlTGVmdDA7XG5cdFx0XHRcdFx0XHRwMSA9IG1vdXNlTGVmdDE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0cDAgPSBtb3VzZVRvcDA7XG5cdFx0XHRcdFx0XHRwMSA9IG1vdXNlVG9wMTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRzZXRTZWxZKG1pbihwMCwgcDEpLCBhYnMocDEgLSBwMCkpO1xuXG5cdFx0XHRcdFx0aWYgKCFkcmFnWClcblx0XHRcdFx0XHRcdHNldFNlbFgoMCwgeERpbSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyB0aGUgZHJhZyBkaWRuJ3QgcGFzcyB0aGUgZGlzdCByZXF1aXJlbWVudFxuXHRcdFx0XHRpZiAoIWRyYWdYICYmICFkcmFnWSkge1xuXHRcdFx0XHRcdHNldFNlbFgoMCwgMCk7XG5cdFx0XHRcdFx0c2V0U2VsWSgwLCAwKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGN1cnNvci5pZHggPSBpZHg7XG5cdFx0Y3Vyc29yLmxlZnQgPSBtb3VzZUxlZnQxO1xuXHRcdGN1cnNvci50b3AgPSBtb3VzZVRvcDE7XG5cdFx0ZHJhZy5feCA9IGRyYWdYO1xuXHRcdGRyYWcuX3kgPSBkcmFnWTtcblxuXHRcdC8vIGlmIHRzIGlzIHByZXNlbnQsIG1lYW5zIHdlJ3JlIGltcGxpY2l0bHkgc3luY2luZyBvd24gY3Vyc29yXG5cdFx0aWYgKHRzICE9IG51bGwpIHtcblx0XHRcdGlmIChzeW5jS2V5ICE9IG51bGwpIHtcblx0XHRcdFx0bGV0IFt4U3luY0tleSwgeVN5bmNLZXldID0gc3luY09wdHMuc2NhbGVzO1xuXG5cdFx0XHRcdHN5bmNPcHRzLnZhbHVlc1swXSA9IHhTeW5jS2V5ICE9IG51bGwgPyBwb3NUb1ZhbChzY2FsZVgub3JpID09IDAgPyBtb3VzZUxlZnQxIDogbW91c2VUb3AxLCB4U3luY0tleSkgOiBudWxsO1xuXHRcdFx0XHRzeW5jT3B0cy52YWx1ZXNbMV0gPSB5U3luY0tleSAhPSBudWxsID8gcG9zVG9WYWwoc2NhbGVYLm9yaSA9PSAxID8gbW91c2VMZWZ0MSA6IG1vdXNlVG9wMSwgeVN5bmNLZXkpIDogbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gdGhpcyBpcyBub3QgdGVjaG5pY2FsbHkgYSBcIm1vdXNlbW92ZVwiIGV2ZW50LCBzaW5jZSBpdCdzIGRlYm91bmNlZCwgcmVuYW1lIHRvIHNldEN1cnNvcj9cblx0XHRcdC8vIHNpbmNlIHRoaXMgaXMgaW50ZXJuYWwsIHdlIGNhbiB0d2VhayBpdCBsYXRlclxuXHRcdFx0cHViU3luYyhtb3VzZW1vdmUsIHNlbGYsIG1vdXNlTGVmdDEsIG1vdXNlVG9wMSwgcGxvdFdpZENzcywgcGxvdEhndENzcywgaWR4KTtcblxuXHRcdFx0aWYgKGN1cnNvckZvY3VzKSB7XG5cdFx0XHRcdGxldCBvID0gc3luY09wdHMuc2V0U2VyaWVzO1xuXHRcdFx0XHRsZXQgcCA9IGZvY3VzLnByb3g7XG5cblx0XHRcdFx0aWYgKGZvY3VzZWRTZXJpZXMgPT0gbnVsbCkge1xuXHRcdFx0XHRcdGlmIChjbG9zZXN0RGlzdCA8PSBwKVxuXHRcdFx0XHRcdFx0c2V0U2VyaWVzKGNsb3Nlc3RTZXJpZXMsIEZPQ1VTX1RSVUUsIG8pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGlmIChjbG9zZXN0RGlzdCA+IHApXG5cdFx0XHRcdFx0XHRzZXRTZXJpZXMobnVsbCwgRk9DVVNfVFJVRSwgbyk7XG5cdFx0XHRcdFx0ZWxzZSBpZiAoY2xvc2VzdFNlcmllcyAhPSBmb2N1c2VkU2VyaWVzKVxuXHRcdFx0XHRcdFx0c2V0U2VyaWVzKGNsb3Nlc3RTZXJpZXMsIEZPQ1VTX1RSVUUsIG8pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmVhZHkgJiYgX2ZpcmUgIT09IGZhbHNlICYmIGZpcmUoXCJzZXRDdXJzb3JcIik7XG5cdH1cblxuXHRsZXQgcmVjdCA9IG51bGw7XG5cblx0ZnVuY3Rpb24gc3luY1JlY3QoZGVmZXIpIHtcblx0XHRpZiAoZGVmZXIgPT09IHRydWUpXG5cdFx0XHRyZWN0ID0gbnVsbDtcblx0XHRlbHNlIHtcblx0XHRcdHJlY3QgPSBvdmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdFx0ZmlyZShcInN5bmNSZWN0XCIsIHJlY3QpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIG1vdXNlTW92ZShlLCBzcmMsIF9sLCBfdCwgX3csIF9oLCBfaSkge1xuXHRcdGlmIChjdXJzb3IuX2xvY2spXG5cdFx0XHRyZXR1cm47XG5cblx0XHRjYWNoZU1vdXNlKGUsIHNyYywgX2wsIF90LCBfdywgX2gsIF9pLCBmYWxzZSwgZSAhPSBudWxsKTtcblxuXHRcdGlmIChlICE9IG51bGwpXG5cdFx0XHR1cGRhdGVDdXJzb3IoMSk7XG5cdFx0ZWxzZVxuXHRcdFx0dXBkYXRlQ3Vyc29yKG51bGwsIHNyYyk7XG5cdH1cblxuXHRmdW5jdGlvbiBjYWNoZU1vdXNlKGUsIHNyYywgX2wsIF90LCBfdywgX2gsIF9pLCBpbml0aWFsLCBzbmFwKSB7XG5cdFx0aWYgKHJlY3QgPT0gbnVsbClcblx0XHRcdHN5bmNSZWN0KGZhbHNlKTtcblxuXHRcdGlmIChlICE9IG51bGwpIHtcblx0XHRcdF9sID0gZS5jbGllbnRYIC0gcmVjdC5sZWZ0O1xuXHRcdFx0X3QgPSBlLmNsaWVudFkgLSByZWN0LnRvcDtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRpZiAoX2wgPCAwIHx8IF90IDwgMCkge1xuXHRcdFx0XHRtb3VzZUxlZnQxID0gLTEwO1xuXHRcdFx0XHRtb3VzZVRvcDEgPSAtMTA7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0bGV0IFt4S2V5LCB5S2V5XSA9IHN5bmNPcHRzLnNjYWxlcztcblxuXHRcdFx0bGV0IHN5bmNPcHRzU3JjID0gc3JjLmN1cnNvci5zeW5jO1xuXHRcdFx0bGV0IFt4VmFsU3JjLCB5VmFsU3JjXSA9IHN5bmNPcHRzU3JjLnZhbHVlcztcblx0XHRcdGxldCBbeEtleVNyYywgeUtleVNyY10gPSBzeW5jT3B0c1NyYy5zY2FsZXM7XG5cdFx0XHRsZXQgW21hdGNoWEtleXMsIG1hdGNoWUtleXNdID0gc3luY09wdHMubWF0Y2g7XG5cblx0XHRcdGxldCByb3RTcmMgPSBzcmMuc2NhbGVzW3hLZXlTcmNdLm9yaSA9PSAxO1xuXG5cdFx0XHRsZXQgeERpbSA9IHNjYWxlWC5vcmkgPT0gMCA/IHBsb3RXaWRDc3MgOiBwbG90SGd0Q3NzLFxuXHRcdFx0XHR5RGltID0gc2NhbGVYLm9yaSA9PSAxID8gcGxvdFdpZENzcyA6IHBsb3RIZ3RDc3MsXG5cdFx0XHRcdF94RGltID0gcm90U3JjID8gX2ggOiBfdyxcblx0XHRcdFx0X3lEaW0gPSByb3RTcmMgPyBfdyA6IF9oLFxuXHRcdFx0XHRfeFBvcyA9IHJvdFNyYyA/IF90IDogX2wsXG5cdFx0XHRcdF95UG9zID0gcm90U3JjID8gX2wgOiBfdDtcblxuXHRcdFx0aWYgKHhLZXlTcmMgIT0gbnVsbClcblx0XHRcdFx0X2wgPSBtYXRjaFhLZXlzKHhLZXksIHhLZXlTcmMpID8gZ2V0UG9zKHhWYWxTcmMsIHNjYWxlc1t4S2V5XSwgeERpbSwgMCkgOiAtMTA7XG5cdFx0XHRlbHNlXG5cdFx0XHRcdF9sID0geERpbSAqIChfeFBvcy9feERpbSk7XG5cblx0XHRcdGlmICh5S2V5U3JjICE9IG51bGwpXG5cdFx0XHRcdF90ID0gbWF0Y2hZS2V5cyh5S2V5LCB5S2V5U3JjKSA/IGdldFBvcyh5VmFsU3JjLCBzY2FsZXNbeUtleV0sIHlEaW0sIDApIDogLTEwO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHRfdCA9IHlEaW0gKiAoX3lQb3MvX3lEaW0pO1xuXG5cdFx0XHRpZiAoc2NhbGVYLm9yaSA9PSAxKSB7XG5cdFx0XHRcdGxldCBfX2wgPSBfbDtcblx0XHRcdFx0X2wgPSBfdDtcblx0XHRcdFx0X3QgPSBfX2w7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHNuYXApIHtcblx0XHRcdGlmIChfbCA8PSAxIHx8IF9sID49IHBsb3RXaWRDc3MgLSAxKVxuXHRcdFx0XHRfbCA9IGluY3JSb3VuZChfbCwgcGxvdFdpZENzcyk7XG5cblx0XHRcdGlmIChfdCA8PSAxIHx8IF90ID49IHBsb3RIZ3RDc3MgLSAxKVxuXHRcdFx0XHRfdCA9IGluY3JSb3VuZChfdCwgcGxvdEhndENzcyk7XG5cdFx0fVxuXG5cdFx0aWYgKGluaXRpYWwpIHtcblx0XHRcdHJhd01vdXNlTGVmdDAgPSBfbDtcblx0XHRcdHJhd01vdXNlVG9wMCA9IF90O1xuXG5cdFx0XHRbbW91c2VMZWZ0MCwgbW91c2VUb3AwXSA9IGN1cnNvci5tb3ZlKHNlbGYsIF9sLCBfdCk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0bW91c2VMZWZ0MSA9IF9sO1xuXHRcdFx0bW91c2VUb3AxID0gX3Q7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gaGlkZVNlbGVjdCgpIHtcblx0XHRzZXRTZWxlY3Qoe1xuXHRcdFx0d2lkdGg6IDAsXG5cdFx0XHRoZWlnaHQ6IDAsXG5cdFx0fSwgZmFsc2UpO1xuXHR9XG5cblx0ZnVuY3Rpb24gbW91c2VEb3duKGUsIHNyYywgX2wsIF90LCBfdywgX2gsIF9pKSB7XG5cdFx0ZHJhZ2dpbmcgPSB0cnVlO1xuXHRcdGRyYWdYID0gZHJhZ1kgPSBkcmFnLl94ID0gZHJhZy5feSA9IGZhbHNlO1xuXG5cdFx0Y2FjaGVNb3VzZShlLCBzcmMsIF9sLCBfdCwgX3csIF9oLCBfaSwgdHJ1ZSwgZmFsc2UpO1xuXG5cdFx0aWYgKGUgIT0gbnVsbCkge1xuXHRcdFx0b25Nb3VzZShtb3VzZXVwLCBkb2MsIG1vdXNlVXApO1xuXHRcdFx0cHViU3luYyhtb3VzZWRvd24sIHNlbGYsIG1vdXNlTGVmdDAsIG1vdXNlVG9wMCwgcGxvdFdpZENzcywgcGxvdEhndENzcywgbnVsbCk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gbW91c2VVcChlLCBzcmMsIF9sLCBfdCwgX3csIF9oLCBfaSkge1xuXHRcdGRyYWdnaW5nID0gZHJhZy5feCA9IGRyYWcuX3kgPSBmYWxzZTtcblxuXHRcdGNhY2hlTW91c2UoZSwgc3JjLCBfbCwgX3QsIF93LCBfaCwgX2ksIGZhbHNlLCB0cnVlKTtcblxuXHRcdGxldCB7IGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCB9ID0gc2VsZWN0O1xuXG5cdFx0bGV0IGhhc1NlbGVjdCA9IHdpZHRoID4gMCB8fCBoZWlnaHQgPiAwO1xuXG5cdFx0aGFzU2VsZWN0ICYmIHNldFNlbGVjdChzZWxlY3QpO1xuXG5cdFx0aWYgKGRyYWcuc2V0U2NhbGUgJiYgaGFzU2VsZWN0KSB7XG5cdFx0Ly9cdGlmIChzeW5jS2V5ICE9IG51bGwpIHtcblx0XHQvL1x0XHRkcmFnWCA9IGRyYWcueDtcblx0XHQvL1x0XHRkcmFnWSA9IGRyYWcueTtcblx0XHQvL1x0fVxuXG5cdFx0XHRsZXQgeE9mZiA9IGxlZnQsXG5cdFx0XHRcdHhEaW0gPSB3aWR0aCxcblx0XHRcdFx0eU9mZiA9IHRvcCxcblx0XHRcdFx0eURpbSA9IGhlaWdodDtcblxuXHRcdFx0aWYgKHNjYWxlWC5vcmkgPT0gMSkge1xuXHRcdFx0XHR4T2ZmID0gdG9wLFxuXHRcdFx0XHR4RGltID0gaGVpZ2h0LFxuXHRcdFx0XHR5T2ZmID0gbGVmdCxcblx0XHRcdFx0eURpbSA9IHdpZHRoO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZHJhZ1gpIHtcblx0XHRcdFx0X3NldFNjYWxlKHhTY2FsZUtleSxcblx0XHRcdFx0XHRwb3NUb1ZhbCh4T2ZmLCB4U2NhbGVLZXkpLFxuXHRcdFx0XHRcdHBvc1RvVmFsKHhPZmYgKyB4RGltLCB4U2NhbGVLZXkpXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChkcmFnWSkge1xuXHRcdFx0XHRmb3IgKGxldCBrIGluIHNjYWxlcykge1xuXHRcdFx0XHRcdGxldCBzYyA9IHNjYWxlc1trXTtcblxuXHRcdFx0XHRcdGlmIChrICE9IHhTY2FsZUtleSAmJiBzYy5mcm9tID09IG51bGwgJiYgc2MubWluICE9IGluZikge1xuXHRcdFx0XHRcdFx0X3NldFNjYWxlKGssXG5cdFx0XHRcdFx0XHRcdHBvc1RvVmFsKHlPZmYgKyB5RGltLCBrKSxcblx0XHRcdFx0XHRcdFx0cG9zVG9WYWwoeU9mZiwgaylcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGhpZGVTZWxlY3QoKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoY3Vyc29yLmxvY2spIHtcblx0XHRcdGN1cnNvci5fbG9jayA9ICFjdXJzb3IuX2xvY2s7XG5cblx0XHRcdGlmICghY3Vyc29yLl9sb2NrKVxuXHRcdFx0XHR1cGRhdGVDdXJzb3IoKTtcblx0XHR9XG5cblx0XHRpZiAoZSAhPSBudWxsKSB7XG5cdFx0XHRvZmZNb3VzZShtb3VzZXVwLCBkb2MpO1xuXHRcdFx0cHViU3luYyhtb3VzZXVwLCBzZWxmLCBtb3VzZUxlZnQxLCBtb3VzZVRvcDEsIHBsb3RXaWRDc3MsIHBsb3RIZ3RDc3MsIG51bGwpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIG1vdXNlTGVhdmUoZSwgc3JjLCBfbCwgX3QsIF93LCBfaCwgX2kpIHtcblx0XHRpZiAoIWN1cnNvci5fbG9jaykge1xuXHRcdFx0bGV0IF9kcmFnZ2luZyA9IGRyYWdnaW5nO1xuXG5cdFx0XHRpZiAoZHJhZ2dpbmcpIHtcblx0XHRcdFx0Ly8gaGFuZGxlIGNhc2Ugd2hlbiBtb3VzZW1vdmUgYXJlbid0IGZpcmVkIGFsbCB0aGUgd2F5IHRvIGVkZ2VzIGJ5IGJyb3dzZXJcblx0XHRcdFx0bGV0IHNuYXBIID0gdHJ1ZTtcblx0XHRcdFx0bGV0IHNuYXBWID0gdHJ1ZTtcblx0XHRcdFx0bGV0IHNuYXBQcm94ID0gMTA7XG5cblx0XHRcdFx0bGV0IGRyYWdILCBkcmFnVjtcblxuXHRcdFx0XHRpZiAoc2NhbGVYLm9yaSA9PSAwKSB7XG5cdFx0XHRcdFx0ZHJhZ0ggPSBkcmFnWDtcblx0XHRcdFx0XHRkcmFnViA9IGRyYWdZO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGRyYWdIID0gZHJhZ1k7XG5cdFx0XHRcdFx0ZHJhZ1YgPSBkcmFnWDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChkcmFnSCAmJiBkcmFnVikge1xuXHRcdFx0XHRcdC8vIG1heWJlIG9tbmkgY29ybmVyIHNuYXBcblx0XHRcdFx0XHRzbmFwSCA9IG1vdXNlTGVmdDEgPD0gc25hcFByb3ggfHwgbW91c2VMZWZ0MSA+PSBwbG90V2lkQ3NzIC0gc25hcFByb3g7XG5cdFx0XHRcdFx0c25hcFYgPSBtb3VzZVRvcDEgIDw9IHNuYXBQcm94IHx8IG1vdXNlVG9wMSAgPj0gcGxvdEhndENzcyAtIHNuYXBQcm94O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGRyYWdIICYmIHNuYXBIKVxuXHRcdFx0XHRcdG1vdXNlTGVmdDEgPSBtb3VzZUxlZnQxIDwgbW91c2VMZWZ0MCA/IDAgOiBwbG90V2lkQ3NzO1xuXG5cdFx0XHRcdGlmIChkcmFnViAmJiBzbmFwVilcblx0XHRcdFx0XHRtb3VzZVRvcDEgPSBtb3VzZVRvcDEgPCBtb3VzZVRvcDAgPyAwIDogcGxvdEhndENzcztcblxuXHRcdFx0XHR1cGRhdGVDdXJzb3IoMSk7XG5cblx0XHRcdFx0ZHJhZ2dpbmcgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0bW91c2VMZWZ0MSA9IC0xMDtcblx0XHRcdG1vdXNlVG9wMSA9IC0xMDtcblxuXHRcdFx0Ly8gcGFzc2luZyBhIG5vbi1udWxsIHRpbWVzdGFtcCB0byBmb3JjZSBzeW5jL21vdXNlbW92ZSBldmVudFxuXHRcdFx0dXBkYXRlQ3Vyc29yKDEpO1xuXG5cdFx0XHRpZiAoX2RyYWdnaW5nKVxuXHRcdFx0XHRkcmFnZ2luZyA9IF9kcmFnZ2luZztcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBkYmxDbGljayhlLCBzcmMsIF9sLCBfdCwgX3csIF9oLCBfaSkge1xuXHRcdGF1dG9TY2FsZVgoKTtcblxuXHRcdGhpZGVTZWxlY3QoKTtcblxuXHRcdGlmIChlICE9IG51bGwpXG5cdFx0XHRwdWJTeW5jKGRibGNsaWNrLCBzZWxmLCBtb3VzZUxlZnQxLCBtb3VzZVRvcDEsIHBsb3RXaWRDc3MsIHBsb3RIZ3RDc3MsIG51bGwpO1xuXHR9XG5cblx0Ly8gaW50ZXJuYWwgcHViL3N1YlxuXHRjb25zdCBldmVudHMgPSB7fTtcblxuXHRldmVudHMubW91c2Vkb3duID0gbW91c2VEb3duO1xuXHRldmVudHMubW91c2Vtb3ZlID0gbW91c2VNb3ZlO1xuXHRldmVudHMubW91c2V1cCA9IG1vdXNlVXA7XG5cdGV2ZW50cy5kYmxjbGljayA9IGRibENsaWNrO1xuXHRldmVudHNbXCJzZXRTZXJpZXNcIl0gPSAoZSwgc3JjLCBpZHgsIG9wdHMpID0+IHtcblx0XHRzZXRTZXJpZXMoaWR4LCBvcHRzKTtcblx0fTtcblxuXHRpZiAoY3Vyc29yLnNob3cpIHtcblx0XHRvbk1vdXNlKG1vdXNlZG93biwgIG92ZXIsIG1vdXNlRG93bik7XG5cdFx0b25Nb3VzZShtb3VzZW1vdmUsICBvdmVyLCBtb3VzZU1vdmUpO1xuXHRcdG9uTW91c2UobW91c2VlbnRlciwgb3Zlciwgc3luY1JlY3QpO1xuXHRcdG9uTW91c2UobW91c2VsZWF2ZSwgb3ZlciwgbW91c2VMZWF2ZSk7XG5cblx0XHRvbk1vdXNlKGRibGNsaWNrLCBvdmVyLCBkYmxDbGljayk7XG5cblx0XHRjdXJzb3JQbG90cy5hZGQoc2VsZik7XG5cblx0XHRzZWxmLnN5bmNSZWN0ID0gc3luY1JlY3Q7XG5cdH1cblxuXHQvLyBleHRlcm5hbCBvbi9vZmZcblx0Y29uc3QgaG9va3MgPSBzZWxmLmhvb2tzID0gb3B0cy5ob29rcyB8fCB7fTtcblxuXHRmdW5jdGlvbiBmaXJlKGV2TmFtZSwgYTEsIGEyKSB7XG5cdFx0aWYgKGV2TmFtZSBpbiBob29rcykge1xuXHRcdFx0aG9va3NbZXZOYW1lXS5mb3JFYWNoKGZuID0+IHtcblx0XHRcdFx0Zm4uY2FsbChudWxsLCBzZWxmLCBhMSwgYTIpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblx0KG9wdHMucGx1Z2lucyB8fCBbXSkuZm9yRWFjaChwID0+IHtcblx0XHRmb3IgKGxldCBldk5hbWUgaW4gcC5ob29rcylcblx0XHRcdGhvb2tzW2V2TmFtZV0gPSAoaG9va3NbZXZOYW1lXSB8fCBbXSkuY29uY2F0KHAuaG9va3NbZXZOYW1lXSk7XG5cdH0pO1xuXG5cdGNvbnN0IHN5bmNPcHRzID0gYXNzaWduKHtcblx0XHRrZXk6IG51bGwsXG5cdFx0c2V0U2VyaWVzOiBmYWxzZSxcblx0XHRmaWx0ZXJzOiB7XG5cdFx0XHRwdWI6IHJldFRydWUsXG5cdFx0XHRzdWI6IHJldFRydWUsXG5cdFx0fSxcblx0XHRzY2FsZXM6IFt4U2NhbGVLZXksIHNlcmllc1sxXSA/IHNlcmllc1sxXS5zY2FsZSA6IG51bGxdLFxuXHRcdG1hdGNoOiBbcmV0RXEsIHJldEVxXSxcblx0XHR2YWx1ZXM6IFtudWxsLCBudWxsXSxcblx0fSwgY3Vyc29yLnN5bmMpO1xuXG5cdChjdXJzb3Iuc3luYyA9IHN5bmNPcHRzKTtcblxuXHRjb25zdCBzeW5jS2V5ID0gc3luY09wdHMua2V5O1xuXG5cdGNvbnN0IHN5bmMgPSBfc3luYyhzeW5jS2V5KTtcblxuXHRmdW5jdGlvbiBwdWJTeW5jKHR5cGUsIHNyYywgeCwgeSwgdywgaCwgaSkge1xuXHRcdGlmIChzeW5jT3B0cy5maWx0ZXJzLnB1Yih0eXBlLCBzcmMsIHgsIHksIHcsIGgsIGkpKVxuXHRcdFx0c3luYy5wdWIodHlwZSwgc3JjLCB4LCB5LCB3LCBoLCBpKTtcblx0fVxuXG5cdHN5bmMuc3ViKHNlbGYpO1xuXG5cdGZ1bmN0aW9uIHB1Yih0eXBlLCBzcmMsIHgsIHksIHcsIGgsIGkpIHtcblx0XHRpZiAoc3luY09wdHMuZmlsdGVycy5zdWIodHlwZSwgc3JjLCB4LCB5LCB3LCBoLCBpKSlcblx0XHRcdGV2ZW50c1t0eXBlXShudWxsLCBzcmMsIHgsIHksIHcsIGgsIGkpO1xuXHR9XG5cblx0KHNlbGYucHViID0gcHViKTtcblxuXHRmdW5jdGlvbiBkZXN0cm95KCkge1xuXHRcdHN5bmMudW5zdWIoc2VsZik7XG5cdFx0Y3Vyc29yUGxvdHMuZGVsZXRlKHNlbGYpO1xuXHRcdG1vdXNlTGlzdGVuZXJzLmNsZWFyKCk7XG5cdFx0cm9vdC5yZW1vdmUoKTtcblx0XHRmaXJlKFwiZGVzdHJveVwiKTtcblx0fVxuXG5cdHNlbGYuZGVzdHJveSA9IGRlc3Ryb3k7XG5cblx0ZnVuY3Rpb24gX2luaXQoKSB7XG5cdFx0ZmlyZShcImluaXRcIiwgb3B0cywgZGF0YSk7XG5cblx0XHRzZXREYXRhKGRhdGEgfHwgb3B0cy5kYXRhLCBmYWxzZSk7XG5cblx0XHRpZiAocGVuZFNjYWxlc1t4U2NhbGVLZXldKVxuXHRcdFx0c2V0U2NhbGUoeFNjYWxlS2V5LCBwZW5kU2NhbGVzW3hTY2FsZUtleV0pO1xuXHRcdGVsc2Vcblx0XHRcdGF1dG9TY2FsZVgoKTtcblxuXHRcdF9zZXRTaXplKG9wdHMud2lkdGgsIG9wdHMuaGVpZ2h0KTtcblxuXHRcdHVwZGF0ZUN1cnNvcigpO1xuXG5cdFx0c2V0U2VsZWN0KHNlbGVjdCwgZmFsc2UpO1xuXHR9XG5cblx0c2VyaWVzLmZvckVhY2goaW5pdFNlcmllcyk7XG5cblx0YXhlcy5mb3JFYWNoKGluaXRBeGlzKTtcblxuXHRpZiAodGhlbikge1xuXHRcdGlmICh0aGVuIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcblx0XHRcdHRoZW4uYXBwZW5kQ2hpbGQocm9vdCk7XG5cdFx0XHRfaW5pdCgpO1xuXHRcdH1cblx0XHRlbHNlXG5cdFx0XHR0aGVuKHNlbGYsIF9pbml0KTtcblx0fVxuXHRlbHNlXG5cdFx0X2luaXQoKTtcblxuXHRyZXR1cm4gc2VsZjtcbn1cblxudVBsb3QuYXNzaWduID0gYXNzaWduO1xudVBsb3QuZm10TnVtID0gZm10TnVtO1xudVBsb3QucmFuZ2VOdW0gPSByYW5nZU51bTtcbnVQbG90LnJhbmdlTG9nID0gcmFuZ2VMb2c7XG51UGxvdC5yYW5nZUFzaW5oID0gcmFuZ2VBc2luaDtcbnVQbG90Lm9yaWVudCAgID0gb3JpZW50O1xuXG57XG5cdHVQbG90LmpvaW4gPSBqb2luO1xufVxuXG57XG5cdHVQbG90LmZtdERhdGUgPSBmbXREYXRlO1xuXHR1UGxvdC50ekRhdGUgID0gdHpEYXRlO1xufVxuXG57XG5cdHVQbG90LnN5bmMgPSBfc3luYztcbn1cblxue1xuXHR1UGxvdC5hZGRHYXAgPSBhZGRHYXA7XG5cdHVQbG90LmNsaXBHYXBzID0gY2xpcEdhcHM7XG5cblx0bGV0IHBhdGhzID0gdVBsb3QucGF0aHMgPSB7fTtcblxuXHQocGF0aHMubGluZWFyICA9IGxpbmVhcik7XG5cdChwYXRocy5zdGVwcGVkID0gc3RlcHBlZCk7XG5cdChwYXRocy5iYXJzICAgID0gYmFycyk7XG5cdChwYXRocy5zcGxpbmUgID0gbW9ub3RvbmVDdWJpYyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHVQbG90O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///28890\n");

/***/ })

}]);